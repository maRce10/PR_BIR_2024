{"title":"<font size=\"7\"><b>Import annotations into R</b></font>","markdown":{"yaml":{"title":"<font size=\"7\"><b>Import annotations into R</b></font>"},"headingText":"**Objetives**","headingAttr":{"id":"","classes":["unnumbered","unlisted"],"keyvalue":[]},"containsRefs":false,"markdown":"\n\n \n\n::: {.alert .alert-info}\n\n-   Learn various methods to import and export annotations in R\n\n-   Get familiar with the data structure used for representing annotations in R\n:::\n\n \n\n## Annotation tables\n\nAn annotation table (or selection table in Raven's terminology and **warbleR**) is a spreadsheet that contains information about the location (and frequency) of the sounds of interest in one or more sound files. Therefore, the basic annotation table should contain at least 3 columns:\n\n```{r, echo = FALSE}\n\noptions(digits=3)\n\nstart <- rnorm(n = 4, mean = 3)\nend <- start + abs(rnorm(n = 4, mean = 1))\n\ncd.anot <- data.frame(sound.files = rep(c(\"sound_file_1.wav\", \"sound_file_2.wav\"), each = 2), start, end) \n\nkbl <- knitr::kable(cd.anot, align = \"c\", row.names = F,  format = \"html\")\n\nkbl <-  kableExtra::kable_styling(kbl, bootstrap_options = \"striped\", font_size = 14)\n\nkbl\n\n```\n\n \n\nIdeally we should also include the frequency range of the annotations:\n\n```{r, echo = FALSE}\n\ncd.anot$bottom.freq <- rnorm(n = 4, mean = 5)\ncd.anot$top.freq <- rnorm(n = 4, mean = 9)\n\nkbl <- knitr::kable(cd.anot, align = \"c\", row.names = F,  format = \"html\")\n\nkbl <-  kableExtra::column_spec(kbl, 4:5, background = \"#ccebff\")\n\nkbl <-  kableExtra::kable_styling(kbl, bootstrap_options = \"striped\", font_size = 14)\n\nkbl\n\n```\n\n \n\n.. and a unique identifier (at least within each sound file) for each annotation:\n\n```{r, echo = FALSE}\n\ncd.anot$selec <- rep(1:2, 2)\n\ncd.anot <- cd.anot[, c(1, 6, 2:5)]\n\nkbl <- knitr::kable(cd.anot, align = \"c\", row.names = F,  format = \"html\")\n\nkbl <-  kableExtra::column_spec(kbl, 2, background = \"#ccebff\")\n\nkbl <-  kableExtra::kable_styling(kbl, bootstrap_options = \"striped\", font_size = 14)\n\nkbl\n\n```\n\nFinally, for sound files with multiple channels, the annotation table should indicate in which channel the sound of interest is located:\n\n```{r, echo = FALSE}\n\ncd.anot$channel <- rep(1, 4)\n\ncd.anot <- cd.anot[, c(1, 7, 2:6)]\n\nkbl <- knitr::kable(cd.anot, align = \"c\", row.names = F,  format = \"html\")\n\nkbl <-  kableExtra::column_spec(kbl, 2, background = \"#ccebff\")\n\nkbl <-  kableExtra::kable_styling(kbl, bootstrap_options = \"striped\", font_size = 14)\n\nkbl\n\n```\n\n \n\nThis format, with the same column names as in the previous example, is the one used by the **warbleR** package as a basic data object to work on batches of sounds (\"batches\"). The mandatory columns are \"sound.files\", \"selec\", \"start\", and \"end\". The frequency range columns (\"bottom.freq\" and \"top.freq\") and the channel number (\"channel\") are optional.\n\nAnnotation tables can be generated within R, or imported from sound analysis programs (mainly, Raven, Avisoft, Syrinx and Audacity).\n\n## Raven\n\n[Raven sound analysis software](https://www.birds.cornell.edu/ccb/raven/RavenOverview.html) ([Cornell Lab of Ornithology](http://www.birds.cornell.edu)) provides very powerful tools for the analysis of sounds (animals). **Raven** allows you to use the cursor to manually define the frequency and time limits of the signals. It is a very flexible and user friendly program. The annotations can be saved in a selection file (selection table) in .txt format:\n\n \n\n<img src=\"images/Raven.selec.gif\" alt=\"Raven\" width=\"820\"/>\n\n \n\nSelections can be reopened on the original file where they were made:\n\n \n\n<img src=\"images/Raven.open.st.gif\" alt=\"Raven\" width=\"820\"/>\n\n \n\nThe selections with sound (sound selection table) are a special type of annotation that contains all the information about the address of the files and allows to be opened directly without opening the sound file first. To create these selections, you must include the 'Begin File', 'Begin Path' and \"File offset (s) 'columns (the latter only if the file contains annotations for more than one sound file):\n\n \n\n<img src=\"images/Raven.create.sst.gif\" alt=\"Raven\" width=\"820\"/>\n\n \n\nThese selections open easily in Raven, as long as the sound files are kept in the original folders:\n\n \n\n<img src=\"images/Raven.open.sst.gif\" alt=\"Raven\" width=\"820\"/>\n\n \n\n## Rraven\n\n \n\nThe **Rraven** package is designed to facilitate data exchange between R and [Raven sound analysis software](http://www.birds.cornell.edu/brp/raven/RavenOverview.html). R can simplify the automation of complex analysis routines. In addition, R packages such as **warbleR**, **seewave** and **monitorR** (among others) provide additional methods of analysis, which work as a perfect complement to those found in Raven. Therefore, bridging these applications can greatly expand the bioacoustic toolkit.\n\nCurrently, most Raven analyzes cannot be run in the background from a command terminal. Therefore, most of the **Rraven** functions are designed to simplify the exchange of data between the two programs, and in some cases, export files to Raven for further analysis. This tutorial provides detailed examples for each function in **Rraven**, including both the R code and the additional steps required to fully conduct the analyses. Raven Pro must be installed in order to run some of the code.\n\nIn this link you will find several videos that show in detail the different tools in Raven.\n\nhttp://ravensoundsoftware.com/video-tutorials/\n\n \n\n## Import Raven data\n\n### *imp_raven*\n\nThis function imports Raven selection tables. You can import several files at once. Raven can also import selection tables that include data from multiple recordings. The function returns a single data frame with the information contained in the selection files. We already have 4 Raven selection tables in the example directory:\n\n```{r, eval=T, echo=T}\n\nlist.files(path = \"./examples\", pattern = \"\\\\.txt$\")\n\n```\n\n \n\nThis code shows how to import all the data contained in those files into R:\n\n```{r, eval=FALSE}\n\nrvn.dat <- imp_raven(all.data = TRUE, path = \"./examples\")\n\nhead(rvn.dat)\n\n```\n\n```{r, eval=TRUE, echo=F, message=F}\n\nlibrary(Rraven)\n\nrvn.dat <- imp_raven(all.data = TRUE, path = \"./examples\")\n\nkbl <- knitr::kable(head(rvn.dat), align = \"c\", row.names = F, escape = FALSE) \n\nkbl <- kableExtra::kable_styling(kbl, bootstrap_options = c(\"striped\", \"hover\", \"condensed\", \"responsive\"), full_width = FALSE, font_size = 11)\n\nkableExtra::scroll_box(kbl, width = \"808px\",\nbox_css = \"border: 1px solid #ddd; padding: 5px; \", extra_css = NULL)\n\n```\n\n \n\nNote that the 'waveform' view data has been deleted. It can also be imported as follows (but note that the example selection tables do not have waveform data):\n\n```{r, eval=FALSE}\n\nrvn.dat <- imp_raven(all.data = TRUE, waveform = TRUE, path = \"./examples\")\n\n```\n\n \n\nRaven selections can also be imported in 'selection.table' format so that you can input directly into **warbleR** functions. To do this, you only need to set `warbler.format = TRUE`:\n\n```{r, eval=FALSE}\n\nrvn.dat <- imp_raven(all.data = FALSE, freq.cols = TRUE, path = \"./examples\", warbler.format = TRUE, all.data = FALSE)\n\nhead(rvn.dat)\n\n```\n\n```{r, eval=TRUE, echo=FALSE}\n\nrvn.dat <- imp_raven(warbler.format = TRUE, all.data = FALSE, freq.cols = TRUE, path = \"./examples/\")\n\nkbl <- knitr::kable(head(rvn.dat), align = \"c\", row.names = F, escape = FALSE)\n\nkableExtra::kable_styling(kbl, bootstrap_options = c(\"striped\", \"hover\", \"condensed\", \"responsive\"), full_width = TRUE, font_size = 12)\n\n# kableExtra::scroll_box(kbl, width = \"808\",\n# box_css = \"border: 1px solid #ddd; padding: 5px; \", extra_css = NULL)\n```\n\n \n\nThe output data frame contains the following columns: \"sound.files\", \"channel\", \"selec\", \"start\", \"end\" and \"selec.file.\" You can also import the frequency range parameters in 'selection.table' by setting 'freq.cols' tp `TRUE`. The data frame returned by `imp_raven()` (when in the **warbleR** format) can be entered into several functions of **warbleR** for a more detailed analysis.\n\n### *relabel_colms*\n\nThis is a simple function to re-label the columns to match the format of the selection table used in **warbleR**:\n\n```{r, eval = F, echo = T}\n\n# para simplificar solo las primeras 7 columnas\nst1 <- rvn.dat[ ,1:7]\n\nst1\n```\n\n```{r, eval = T, echo = F}\n\n#to simplify the example select a subset of the columns \nst1 <- rvn.dat[ ,1:7]\n\n#check original column names\nkbl <- knitr::kable(st1, align = \"c\", row.names = F, escape = FALSE) \n\nkbl <- kableExtra::kable_styling(kbl, bootstrap_options = c(\"striped\", \"hover\", \"condensed\", \"responsive\"), full_width = FALSE, font_size = 14)\n\n```\n\n```{r, eval = F, echo = T}\n\nrelabel_colms(st1)\n\n```\n\n```{r, eval = T, echo = F}\nrc <- relabel_colms(st1)\n\nkbl <- knitr::kable(rc, align = \"c\", row.names = F, escape = FALSE) \n\nkbl <- kableExtra::kable_styling(kbl, bootstrap_options = c(\"striped\", \"hover\", \"condensed\", \"responsive\"), full_width = FALSE, font_size = 14)\n\n```\n\n \n\nAdditional columns can also be re-labeled:\n\n```{r, eval = F, echo = T}\n\nrelabel_colms(st1, extra.cols.name = \"View\",\n              extra.cols.new.name = \"Raven view\")\n\n```\n\n```{r, eval = T, echo = F}\n\nrc <- relabel_colms(st1, extra.cols.name = \"View\",\n \"Raven view\")\n\nkbl <- knitr::kable(rc, align = \"c\", row.names = F, escape = FALSE) \n\nkableExtra::kable_styling(kbl, bootstrap_options = c(\"striped\", \"hover\", \"condensed\", \"responsive\"), full_width = FALSE, font_size = 14)\n\n```\n\n \n\n## Export R data to Raven\n\n### *exp_raven*\n\n*exp_raven* saves a selection table in '.txt' format that can be opened directly in Raven. No objects are returned to the R environment. The following code exports a selection table from a single sound file:\n\n```{r, eval=FALSE, echo=T}\n\nst1 <- lbh_selec_table[lbh_selec_table$sound.files == \"Phae.long1.wav\",]\n\nexp_raven(st1, file.name = \"Phaethornis 1\", khz.to.hz = TRUE)\n```\n\n \n\nIf the path to the sound file is provided, the functions export a 'sound selection table' that can be opened directly by Raven (and which will also open the associated sound file):\n\n```{r, eval=FALSE, echo=T}\n\nst1 <- lbh_selec_table[lbh_selec_table$sound.files == \"Phae.long1.wav\",]\n\nexp_raven(st1, file.name = \"Phaethornis 1\", khz.to.hz = TRUE, sound.file.path = \"./examples\")\n\n```\n\n![](images/exp_raven1.gif)\n\n \n\nThis is useful for adding new selections or even new measurements:\n\n![](images/exp_raven2.gif)  \n\nIf there are several sound files available, users can export them as a single selection file or as multiple selection files (one for each sound file). This example creates a multiple selection of sound files:\n\n```{r, eval=FALSE, echo=T}\n\nexp_raven(X = lbh_selec_table, file.name = \"Phaethornis multiple sound files\", \nsound.file.path = \"./examples\", single.file = TRUE)\n```\n\n \n\nThese types of tables can be opened as a multi-file display in Raven:\n\n![ex](images/exp_raven3.gif)\n\n \n\n------------------------------------------------------------------------\n\n \n\n::: {.alert .alert-info}\n<font size=\"5\">Exercise</font>\n\n \n\n-   Annotate 2 sound files from the \"./examples\" folder using **Raven**\n\n \n\n-   Import the annotation files into R using Rraven's `imp_raven()`\n:::\n\n \n\n## warbleR formats\n\n### Selection tables\n\nThese objects are created with the `selection_table()` function. The function takes data frames containing selection data (name of the sound file, selection, start, end ...), verifies if the information is consistent (see the function `check_sels()` for details) and saves the 'diagnostic' metadata as an attribute. The selection tables are basically data frames in which the information contained has been corroborated so it can be read by other **warbleR** functions. The selection tables must contain (at least) the following columns:\n\n1.  sound files (sound.files)\n2.  selection (selec)\n3.  start\n4.  end\n\nThe sample data \"lbh_selec_table\" contains these columns:\n\n```{r extn_sel_2, echo = FALSE, message = FALSE}\n\nrm(list = ls())\n\n# unload all non-based packages\nout <- sapply(paste('package:', names(sessionInfo()$otherPkgs), sep = \"\"), function(x) try(detach(x, unload = FALSE, character.only = TRUE), silent = T))\n\n#load packages\nlibrary(warbleR)\nlibrary(knitr)\nlibrary(kableExtra)\n\n\ncf <- read.csv(\"./data/cuadro de funciones warbleR.csv\", stringsAsFactors = FALSE)\n\nwarbleR_options(wav.path = \"./examples\") \n\noptions(knitr.table.format = \"html\") \nopts_chunk$set(comment = \"\")\nopts_knit$set(root.dir = tempdir())\noptions(width = 100, max.print = 100)\n\n```\n\n```{r extn_sel_4.1, eval=FALSE}\n\nlibrary(warbleR)\n\ndata(\"lbh_selec_table\")\n\nlbh_selec_table\n\n```\n\n```{r extn_sel_4.2, echo=FALSE}\n\nkbl <- knitr::kable(lbh_selec_table, align = \"c\", row.names = F,  format = \"html\")\n\nkbl <-  kableExtra::kable_styling(kbl, bootstrap_options = \"striped\", font_size = 14)\n\nkbl <- kableExtra::scroll_box(kbl, width = \"740px\",\nbox_css = \"border: 1px solid #ddd; padding: 1px; \", extra_css = NULL)\n\nkbl\n\n```\n\n \n\n... and can be converted to the *selection_table* format like this:\n\n```{r extn_sel_4.32, eval = FALSE}\n\n# global parameters\nwarbleR_options(wav.path = \"./examples\")\n\nst <- selection_table(X = lbh_selec_table, pb = FALSE)\n\nst\n```\n\n```{r, eval = TRUE, echo = FALSE}\n\nst <- selection_table(X = lbh_selec_table, pb = FALSE)\n\nkbl <- knitr::kable(st)\n\nkbl <-  kableExtra::kable_styling(kbl, bootstrap_options = \"striped\", font_size = 14)\n\nkbl <- kableExtra::scroll_box(kbl, width = \"740px\",\nbox_css = \"border: 1px solid #ddd; padding: 1px; \", extra_css = NULL)\n\nkbl\n\n```\n\nNote that the path to the sound files has been provided. This is necessary in order to verify that the data provided conforms to the characteristics of the audio files.\n\nSelection tables have their own class in R:\n\n```{r}\n\nclass(st)\n\n```\n\n \n\n### Extended selection tables\n\nWhen the `extended = TRUE` argument the function generates an object of the *extended_selection_table* class that also contains a list of 'wave' objects corresponding to each of the selections in the data. Therefore, the function **transforms the selection table into self-contained objects** since the original sound files are no longer needed to perform most of the acoustic analysis in **warbleR**. This can greatly facilitate the storage and exchange of (bio)acoustic data. In addition, it also speeds up analysis, since it is not necessary to read the sound files every time the data is analyzed.\n\nNow, as mentioned earlier, you need the `selection_table()` function to create an extended selection table. You must also set the argument `extended = TRUE` (otherwise, the class would be a selection table). The following code converts the sample data into an extended selection table:\n\n```{r extn_sel_4.3, eval = FALSE}\n\n\n#  global parameters\nwarbleR_options(wav.path = \"./examples\")\n\next_st <- selection_table(X = lbh_selec_table, pb = FALSE, \n          extended = TRUE)\n\n```\n\n```{r extn_sel_4.33, eval = TRUE, echo = FALSE}\n\next_st <- selection_table(X = lbh_selec_table, pb = FALSE, \n          extended = TRUE)\n\n\n```\n\n \n\nAnd that is. Now the acoustic data and the selection data (as well as the additional metadata) are all together in a single R object. The wave objects contained in the *extended_selection_table* can be easily extracted using the **warbleR** function [read_sound_file](https://marce10.github.io/warbleR/reference/read_sound_file.html):\n\n```{r}\n\nw1 <- read_sound_file(ext_st, index = 1)\n\nw1\n```\n\n \n\nThe index argument indicates the row of the selection that will be read.\n\nThis new object class allows to share complete data sets, including acoustic data. For example, the following code downloads a subset of the data used in [Araya-Salas *et al* (2017)](https://github.com/maRce10/OTS_BIR_2024/raw/master/data/extended.selection.table.araya-salas.et.al.2017.bioacoustics.100.sels.rds):\n\n```{r extn.sel_19, eval = T}\n\nURL <- \"https://github.com/maRce10/OTS_BIR_2024/raw/master/data/extended.selection.table.araya-salas.et.al.2017.bioacoustics.100.sels.rds\"\n\ndat <- readRDS(gzcon(url(URL)))\n\nnrow(dat)\n\nformat(object.size(dat), units = \"auto\")\n\n```\n\nThe total size of the 100 sound files from which these selections were taken adds up to 1.1 GB. The size of the extended selection table is only 10.1 MB.\n\nThis data is ready to be used. For instance, here I create a multipanel graph with the spectrograms of the first 6 selections:\n\n```{r extn.sel_21, out.width= 750}\n\npar(mfrow = c(3, 2), mar = rep(0, 4))\n\nfor(i in 1:6){\n  \n  wv <- read_wave(X = dat, index = i, from = 0.17, to = 0.4)\n\n  spectro(\n    wv,\n    wl = 250,\n    grid = FALSE,\n    scale = FALSE,\n    axisX = FALSE,\n    axisY = FALSE,\n    ovlp = 90,\n    flim = c(0, 12),\n    palette = viridis::viridis,\n    collevels = seq(-120, 0, 5)\n      \n  )\n}\n\n```\n\n \n\n::: {.alert .alert-info}\n<font size=\"5\">Exercise</font>\n\n \n\n-   Run the example code in the `selection_table()` function documentation\n\n-   What do the arguments \"mar\" and \"by.song\" from `selection_table()` do?\n\n-   Measure the peak frequency of the 8th selection (hint: use seewave's `fpeaks()`)\n:::\n\n \n\n------------------------------------------------------------------------\n\n## References\n\n-   Araya-Salas (2017), *Rraven: connecting R and Raven bioacoustic software*. R package version 1.0.2.\n\n------------------------------------------------------------------------\n\n \n\n<font size=\"4\">Session information</font>\n\n```{r session info, echo=F}\n\nsessionInfo()\n\n```\n","srcMarkdownNoYaml":"\n\n \n\n::: {.alert .alert-info}\n## **Objetives** {.unnumbered .unlisted}\n\n-   Learn various methods to import and export annotations in R\n\n-   Get familiar with the data structure used for representing annotations in R\n:::\n\n \n\n## Annotation tables\n\nAn annotation table (or selection table in Raven's terminology and **warbleR**) is a spreadsheet that contains information about the location (and frequency) of the sounds of interest in one or more sound files. Therefore, the basic annotation table should contain at least 3 columns:\n\n```{r, echo = FALSE}\n\noptions(digits=3)\n\nstart <- rnorm(n = 4, mean = 3)\nend <- start + abs(rnorm(n = 4, mean = 1))\n\ncd.anot <- data.frame(sound.files = rep(c(\"sound_file_1.wav\", \"sound_file_2.wav\"), each = 2), start, end) \n\nkbl <- knitr::kable(cd.anot, align = \"c\", row.names = F,  format = \"html\")\n\nkbl <-  kableExtra::kable_styling(kbl, bootstrap_options = \"striped\", font_size = 14)\n\nkbl\n\n```\n\n \n\nIdeally we should also include the frequency range of the annotations:\n\n```{r, echo = FALSE}\n\ncd.anot$bottom.freq <- rnorm(n = 4, mean = 5)\ncd.anot$top.freq <- rnorm(n = 4, mean = 9)\n\nkbl <- knitr::kable(cd.anot, align = \"c\", row.names = F,  format = \"html\")\n\nkbl <-  kableExtra::column_spec(kbl, 4:5, background = \"#ccebff\")\n\nkbl <-  kableExtra::kable_styling(kbl, bootstrap_options = \"striped\", font_size = 14)\n\nkbl\n\n```\n\n \n\n.. and a unique identifier (at least within each sound file) for each annotation:\n\n```{r, echo = FALSE}\n\ncd.anot$selec <- rep(1:2, 2)\n\ncd.anot <- cd.anot[, c(1, 6, 2:5)]\n\nkbl <- knitr::kable(cd.anot, align = \"c\", row.names = F,  format = \"html\")\n\nkbl <-  kableExtra::column_spec(kbl, 2, background = \"#ccebff\")\n\nkbl <-  kableExtra::kable_styling(kbl, bootstrap_options = \"striped\", font_size = 14)\n\nkbl\n\n```\n\nFinally, for sound files with multiple channels, the annotation table should indicate in which channel the sound of interest is located:\n\n```{r, echo = FALSE}\n\ncd.anot$channel <- rep(1, 4)\n\ncd.anot <- cd.anot[, c(1, 7, 2:6)]\n\nkbl <- knitr::kable(cd.anot, align = \"c\", row.names = F,  format = \"html\")\n\nkbl <-  kableExtra::column_spec(kbl, 2, background = \"#ccebff\")\n\nkbl <-  kableExtra::kable_styling(kbl, bootstrap_options = \"striped\", font_size = 14)\n\nkbl\n\n```\n\n \n\nThis format, with the same column names as in the previous example, is the one used by the **warbleR** package as a basic data object to work on batches of sounds (\"batches\"). The mandatory columns are \"sound.files\", \"selec\", \"start\", and \"end\". The frequency range columns (\"bottom.freq\" and \"top.freq\") and the channel number (\"channel\") are optional.\n\nAnnotation tables can be generated within R, or imported from sound analysis programs (mainly, Raven, Avisoft, Syrinx and Audacity).\n\n## Raven\n\n[Raven sound analysis software](https://www.birds.cornell.edu/ccb/raven/RavenOverview.html) ([Cornell Lab of Ornithology](http://www.birds.cornell.edu)) provides very powerful tools for the analysis of sounds (animals). **Raven** allows you to use the cursor to manually define the frequency and time limits of the signals. It is a very flexible and user friendly program. The annotations can be saved in a selection file (selection table) in .txt format:\n\n \n\n<img src=\"images/Raven.selec.gif\" alt=\"Raven\" width=\"820\"/>\n\n \n\nSelections can be reopened on the original file where they were made:\n\n \n\n<img src=\"images/Raven.open.st.gif\" alt=\"Raven\" width=\"820\"/>\n\n \n\nThe selections with sound (sound selection table) are a special type of annotation that contains all the information about the address of the files and allows to be opened directly without opening the sound file first. To create these selections, you must include the 'Begin File', 'Begin Path' and \"File offset (s) 'columns (the latter only if the file contains annotations for more than one sound file):\n\n \n\n<img src=\"images/Raven.create.sst.gif\" alt=\"Raven\" width=\"820\"/>\n\n \n\nThese selections open easily in Raven, as long as the sound files are kept in the original folders:\n\n \n\n<img src=\"images/Raven.open.sst.gif\" alt=\"Raven\" width=\"820\"/>\n\n \n\n## Rraven\n\n \n\nThe **Rraven** package is designed to facilitate data exchange between R and [Raven sound analysis software](http://www.birds.cornell.edu/brp/raven/RavenOverview.html). R can simplify the automation of complex analysis routines. In addition, R packages such as **warbleR**, **seewave** and **monitorR** (among others) provide additional methods of analysis, which work as a perfect complement to those found in Raven. Therefore, bridging these applications can greatly expand the bioacoustic toolkit.\n\nCurrently, most Raven analyzes cannot be run in the background from a command terminal. Therefore, most of the **Rraven** functions are designed to simplify the exchange of data between the two programs, and in some cases, export files to Raven for further analysis. This tutorial provides detailed examples for each function in **Rraven**, including both the R code and the additional steps required to fully conduct the analyses. Raven Pro must be installed in order to run some of the code.\n\nIn this link you will find several videos that show in detail the different tools in Raven.\n\nhttp://ravensoundsoftware.com/video-tutorials/\n\n \n\n## Import Raven data\n\n### *imp_raven*\n\nThis function imports Raven selection tables. You can import several files at once. Raven can also import selection tables that include data from multiple recordings. The function returns a single data frame with the information contained in the selection files. We already have 4 Raven selection tables in the example directory:\n\n```{r, eval=T, echo=T}\n\nlist.files(path = \"./examples\", pattern = \"\\\\.txt$\")\n\n```\n\n \n\nThis code shows how to import all the data contained in those files into R:\n\n```{r, eval=FALSE}\n\nrvn.dat <- imp_raven(all.data = TRUE, path = \"./examples\")\n\nhead(rvn.dat)\n\n```\n\n```{r, eval=TRUE, echo=F, message=F}\n\nlibrary(Rraven)\n\nrvn.dat <- imp_raven(all.data = TRUE, path = \"./examples\")\n\nkbl <- knitr::kable(head(rvn.dat), align = \"c\", row.names = F, escape = FALSE) \n\nkbl <- kableExtra::kable_styling(kbl, bootstrap_options = c(\"striped\", \"hover\", \"condensed\", \"responsive\"), full_width = FALSE, font_size = 11)\n\nkableExtra::scroll_box(kbl, width = \"808px\",\nbox_css = \"border: 1px solid #ddd; padding: 5px; \", extra_css = NULL)\n\n```\n\n \n\nNote that the 'waveform' view data has been deleted. It can also be imported as follows (but note that the example selection tables do not have waveform data):\n\n```{r, eval=FALSE}\n\nrvn.dat <- imp_raven(all.data = TRUE, waveform = TRUE, path = \"./examples\")\n\n```\n\n \n\nRaven selections can also be imported in 'selection.table' format so that you can input directly into **warbleR** functions. To do this, you only need to set `warbler.format = TRUE`:\n\n```{r, eval=FALSE}\n\nrvn.dat <- imp_raven(all.data = FALSE, freq.cols = TRUE, path = \"./examples\", warbler.format = TRUE, all.data = FALSE)\n\nhead(rvn.dat)\n\n```\n\n```{r, eval=TRUE, echo=FALSE}\n\nrvn.dat <- imp_raven(warbler.format = TRUE, all.data = FALSE, freq.cols = TRUE, path = \"./examples/\")\n\nkbl <- knitr::kable(head(rvn.dat), align = \"c\", row.names = F, escape = FALSE)\n\nkableExtra::kable_styling(kbl, bootstrap_options = c(\"striped\", \"hover\", \"condensed\", \"responsive\"), full_width = TRUE, font_size = 12)\n\n# kableExtra::scroll_box(kbl, width = \"808\",\n# box_css = \"border: 1px solid #ddd; padding: 5px; \", extra_css = NULL)\n```\n\n \n\nThe output data frame contains the following columns: \"sound.files\", \"channel\", \"selec\", \"start\", \"end\" and \"selec.file.\" You can also import the frequency range parameters in 'selection.table' by setting 'freq.cols' tp `TRUE`. The data frame returned by `imp_raven()` (when in the **warbleR** format) can be entered into several functions of **warbleR** for a more detailed analysis.\n\n### *relabel_colms*\n\nThis is a simple function to re-label the columns to match the format of the selection table used in **warbleR**:\n\n```{r, eval = F, echo = T}\n\n# para simplificar solo las primeras 7 columnas\nst1 <- rvn.dat[ ,1:7]\n\nst1\n```\n\n```{r, eval = T, echo = F}\n\n#to simplify the example select a subset of the columns \nst1 <- rvn.dat[ ,1:7]\n\n#check original column names\nkbl <- knitr::kable(st1, align = \"c\", row.names = F, escape = FALSE) \n\nkbl <- kableExtra::kable_styling(kbl, bootstrap_options = c(\"striped\", \"hover\", \"condensed\", \"responsive\"), full_width = FALSE, font_size = 14)\n\n```\n\n```{r, eval = F, echo = T}\n\nrelabel_colms(st1)\n\n```\n\n```{r, eval = T, echo = F}\nrc <- relabel_colms(st1)\n\nkbl <- knitr::kable(rc, align = \"c\", row.names = F, escape = FALSE) \n\nkbl <- kableExtra::kable_styling(kbl, bootstrap_options = c(\"striped\", \"hover\", \"condensed\", \"responsive\"), full_width = FALSE, font_size = 14)\n\n```\n\n \n\nAdditional columns can also be re-labeled:\n\n```{r, eval = F, echo = T}\n\nrelabel_colms(st1, extra.cols.name = \"View\",\n              extra.cols.new.name = \"Raven view\")\n\n```\n\n```{r, eval = T, echo = F}\n\nrc <- relabel_colms(st1, extra.cols.name = \"View\",\n \"Raven view\")\n\nkbl <- knitr::kable(rc, align = \"c\", row.names = F, escape = FALSE) \n\nkableExtra::kable_styling(kbl, bootstrap_options = c(\"striped\", \"hover\", \"condensed\", \"responsive\"), full_width = FALSE, font_size = 14)\n\n```\n\n \n\n## Export R data to Raven\n\n### *exp_raven*\n\n*exp_raven* saves a selection table in '.txt' format that can be opened directly in Raven. No objects are returned to the R environment. The following code exports a selection table from a single sound file:\n\n```{r, eval=FALSE, echo=T}\n\nst1 <- lbh_selec_table[lbh_selec_table$sound.files == \"Phae.long1.wav\",]\n\nexp_raven(st1, file.name = \"Phaethornis 1\", khz.to.hz = TRUE)\n```\n\n \n\nIf the path to the sound file is provided, the functions export a 'sound selection table' that can be opened directly by Raven (and which will also open the associated sound file):\n\n```{r, eval=FALSE, echo=T}\n\nst1 <- lbh_selec_table[lbh_selec_table$sound.files == \"Phae.long1.wav\",]\n\nexp_raven(st1, file.name = \"Phaethornis 1\", khz.to.hz = TRUE, sound.file.path = \"./examples\")\n\n```\n\n![](images/exp_raven1.gif)\n\n \n\nThis is useful for adding new selections or even new measurements:\n\n![](images/exp_raven2.gif)  \n\nIf there are several sound files available, users can export them as a single selection file or as multiple selection files (one for each sound file). This example creates a multiple selection of sound files:\n\n```{r, eval=FALSE, echo=T}\n\nexp_raven(X = lbh_selec_table, file.name = \"Phaethornis multiple sound files\", \nsound.file.path = \"./examples\", single.file = TRUE)\n```\n\n \n\nThese types of tables can be opened as a multi-file display in Raven:\n\n![ex](images/exp_raven3.gif)\n\n \n\n------------------------------------------------------------------------\n\n \n\n::: {.alert .alert-info}\n<font size=\"5\">Exercise</font>\n\n \n\n-   Annotate 2 sound files from the \"./examples\" folder using **Raven**\n\n \n\n-   Import the annotation files into R using Rraven's `imp_raven()`\n:::\n\n \n\n## warbleR formats\n\n### Selection tables\n\nThese objects are created with the `selection_table()` function. The function takes data frames containing selection data (name of the sound file, selection, start, end ...), verifies if the information is consistent (see the function `check_sels()` for details) and saves the 'diagnostic' metadata as an attribute. The selection tables are basically data frames in which the information contained has been corroborated so it can be read by other **warbleR** functions. The selection tables must contain (at least) the following columns:\n\n1.  sound files (sound.files)\n2.  selection (selec)\n3.  start\n4.  end\n\nThe sample data \"lbh_selec_table\" contains these columns:\n\n```{r extn_sel_2, echo = FALSE, message = FALSE}\n\nrm(list = ls())\n\n# unload all non-based packages\nout <- sapply(paste('package:', names(sessionInfo()$otherPkgs), sep = \"\"), function(x) try(detach(x, unload = FALSE, character.only = TRUE), silent = T))\n\n#load packages\nlibrary(warbleR)\nlibrary(knitr)\nlibrary(kableExtra)\n\n\ncf <- read.csv(\"./data/cuadro de funciones warbleR.csv\", stringsAsFactors = FALSE)\n\nwarbleR_options(wav.path = \"./examples\") \n\noptions(knitr.table.format = \"html\") \nopts_chunk$set(comment = \"\")\nopts_knit$set(root.dir = tempdir())\noptions(width = 100, max.print = 100)\n\n```\n\n```{r extn_sel_4.1, eval=FALSE}\n\nlibrary(warbleR)\n\ndata(\"lbh_selec_table\")\n\nlbh_selec_table\n\n```\n\n```{r extn_sel_4.2, echo=FALSE}\n\nkbl <- knitr::kable(lbh_selec_table, align = \"c\", row.names = F,  format = \"html\")\n\nkbl <-  kableExtra::kable_styling(kbl, bootstrap_options = \"striped\", font_size = 14)\n\nkbl <- kableExtra::scroll_box(kbl, width = \"740px\",\nbox_css = \"border: 1px solid #ddd; padding: 1px; \", extra_css = NULL)\n\nkbl\n\n```\n\n \n\n... and can be converted to the *selection_table* format like this:\n\n```{r extn_sel_4.32, eval = FALSE}\n\n# global parameters\nwarbleR_options(wav.path = \"./examples\")\n\nst <- selection_table(X = lbh_selec_table, pb = FALSE)\n\nst\n```\n\n```{r, eval = TRUE, echo = FALSE}\n\nst <- selection_table(X = lbh_selec_table, pb = FALSE)\n\nkbl <- knitr::kable(st)\n\nkbl <-  kableExtra::kable_styling(kbl, bootstrap_options = \"striped\", font_size = 14)\n\nkbl <- kableExtra::scroll_box(kbl, width = \"740px\",\nbox_css = \"border: 1px solid #ddd; padding: 1px; \", extra_css = NULL)\n\nkbl\n\n```\n\nNote that the path to the sound files has been provided. This is necessary in order to verify that the data provided conforms to the characteristics of the audio files.\n\nSelection tables have their own class in R:\n\n```{r}\n\nclass(st)\n\n```\n\n \n\n### Extended selection tables\n\nWhen the `extended = TRUE` argument the function generates an object of the *extended_selection_table* class that also contains a list of 'wave' objects corresponding to each of the selections in the data. Therefore, the function **transforms the selection table into self-contained objects** since the original sound files are no longer needed to perform most of the acoustic analysis in **warbleR**. This can greatly facilitate the storage and exchange of (bio)acoustic data. In addition, it also speeds up analysis, since it is not necessary to read the sound files every time the data is analyzed.\n\nNow, as mentioned earlier, you need the `selection_table()` function to create an extended selection table. You must also set the argument `extended = TRUE` (otherwise, the class would be a selection table). The following code converts the sample data into an extended selection table:\n\n```{r extn_sel_4.3, eval = FALSE}\n\n\n#  global parameters\nwarbleR_options(wav.path = \"./examples\")\n\next_st <- selection_table(X = lbh_selec_table, pb = FALSE, \n          extended = TRUE)\n\n```\n\n```{r extn_sel_4.33, eval = TRUE, echo = FALSE}\n\next_st <- selection_table(X = lbh_selec_table, pb = FALSE, \n          extended = TRUE)\n\n\n```\n\n \n\nAnd that is. Now the acoustic data and the selection data (as well as the additional metadata) are all together in a single R object. The wave objects contained in the *extended_selection_table* can be easily extracted using the **warbleR** function [read_sound_file](https://marce10.github.io/warbleR/reference/read_sound_file.html):\n\n```{r}\n\nw1 <- read_sound_file(ext_st, index = 1)\n\nw1\n```\n\n \n\nThe index argument indicates the row of the selection that will be read.\n\nThis new object class allows to share complete data sets, including acoustic data. For example, the following code downloads a subset of the data used in [Araya-Salas *et al* (2017)](https://github.com/maRce10/OTS_BIR_2024/raw/master/data/extended.selection.table.araya-salas.et.al.2017.bioacoustics.100.sels.rds):\n\n```{r extn.sel_19, eval = T}\n\nURL <- \"https://github.com/maRce10/OTS_BIR_2024/raw/master/data/extended.selection.table.araya-salas.et.al.2017.bioacoustics.100.sels.rds\"\n\ndat <- readRDS(gzcon(url(URL)))\n\nnrow(dat)\n\nformat(object.size(dat), units = \"auto\")\n\n```\n\nThe total size of the 100 sound files from which these selections were taken adds up to 1.1 GB. The size of the extended selection table is only 10.1 MB.\n\nThis data is ready to be used. For instance, here I create a multipanel graph with the spectrograms of the first 6 selections:\n\n```{r extn.sel_21, out.width= 750}\n\npar(mfrow = c(3, 2), mar = rep(0, 4))\n\nfor(i in 1:6){\n  \n  wv <- read_wave(X = dat, index = i, from = 0.17, to = 0.4)\n\n  spectro(\n    wv,\n    wl = 250,\n    grid = FALSE,\n    scale = FALSE,\n    axisX = FALSE,\n    axisY = FALSE,\n    ovlp = 90,\n    flim = c(0, 12),\n    palette = viridis::viridis,\n    collevels = seq(-120, 0, 5)\n      \n  )\n}\n\n```\n\n \n\n::: {.alert .alert-info}\n<font size=\"5\">Exercise</font>\n\n \n\n-   Run the example code in the `selection_table()` function documentation\n\n-   What do the arguments \"mar\" and \"by.song\" from `selection_table()` do?\n\n-   Measure the peak frequency of the 8th selection (hint: use seewave's `fpeaks()`)\n:::\n\n \n\n------------------------------------------------------------------------\n\n## References\n\n-   Araya-Salas (2017), *Rraven: connecting R and Raven bioacoustic software*. R package version 1.0.2.\n\n------------------------------------------------------------------------\n\n \n\n<font size=\"4\">Session information</font>\n\n```{r session info, echo=F}\n\nsessionInfo()\n\n```\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"kable","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"show","code-overflow":"wrap","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":true,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"toc-depth":2,"number-sections":true,"highlight-style":"pygments","css":["styles.css"],"output-file":"annotations.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.4.551","toc-location":"left","toc-title":"Contents","code-copy":true,"date":"today","title":"<font size=\"7\"><b>Import annotations into R</b></font>"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}