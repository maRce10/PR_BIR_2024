{"title":"Building spectrograms","markdown":{"yaml":{"title":"Building spectrograms"},"headingText":"**Objetives**","headingAttr":{"id":"","classes":["unnumbered","unlisted"],"keyvalue":[]},"containsRefs":false,"markdown":"\n\n \n\n::: {.alert .alert-info}\n\n-   Understand how spectrograms are created\n\n-   Learn to create and customize spectrograms in R\n:::\n\n \n\n```{r, echo = FALSE}\nlibrary(knitr)\n\nopts_chunk$set(tidy = TRUE, warning = FALSE, message = FALSE)\n\n```\n\nThe spectrogram is a fundamental tool in the study of acoustic communication in vertebrates. They are basically a visual representation of the sound where the variation in energy (or power spectral density) is shown on both the frequency and the time domains. Spectrograms allow us to visually explore acoustic variation in our study systems, which makes it easy to distinguish structural differences at small temporal/spectral scales that our ears cannot detect.\n\nWe will use the **seewave** package and its sample data:\n\n```{r, echo=TRUE, warning=FALSE, message=FALSE}\n\nlibrary(seewave)\n\n# load examples\ndata(tico)\n\ndata(orni)\n\n```\n\n## Fourier transform\n\nIn order to understand the information contained in a spectrogram it is necessary to understand, at least briefly, the [Fourier transform](https://en.wikipedia.org/wiki/Fourier_transform). In simple words, this is a mathematical transformation that detects the periodicity in time series, identifying the different frequencies that compose them and their relative energy. Therefore it is said that it transforms the signals from the time domain to the frequency domain.\n\nTo better understand how it works, we can simulate time series composed of pre-defined frequencies. In this example we simulate 3 frequencies and join them in a single time series:\n\n```{r}\n# freq\nf <- 11025\n\n# time sequence\nt <- seq(1/f, 1, length.out=f)\n\n# period\npr <- 1/440\nw0 <- 2 * pi/pr\n\n# frec 1\nh1 <- 5 * cos(w0*t)\n\nplot(h1[1:75], type = \"l\", col = \"blue\", xlab = \"Time (samples)\", ylab = \"Amplitude (no units)\")\n\n# frec 2\nh2 <- 10 * cos(2 * w0 * t)\n\nplot(h2[1:75], type = \"l\", col = \"blue\", xlab = \"Time (samples)\", ylab = \"Amplitude (no units)\")\n\n# frec 3\nh3 <- 15 * sin(3 * w0 * t)\n\nplot(h3[1:75], type = \"l\", col = \"blue\", xlab = \"Time (samples)\", ylab = \"Amplitude (no units)\")\n\n```\n\nThis is what the union of the three frequencies looks like:\n\n```{r}\nH0 <- 0.5 + h1 + h2 + h3\n\nplot(H0[1:75], type = \"l\", col = \"blue\", xlab = \"Time (samples)\", ylab = \"Amplitude (no units)\")\n\n```\n\nNow we can apply the Fourier transform to this time series and graph the frequencies detected using a periodogram:\n\n```{r}\n\nfspc <- Mod(fft(H0))\n\nplot(fspc, type=\"h\", col=\"blue\",\nxlab=\"Frecuency (Hz)\",\nylab=\"Amplitude (no units)\")\n\nabline(v = f / 2, lty = 2)\n\ntext(x = (f / 2) + 1650, y = 8000, \"Nyquist Frequency\")\n\n```\n\nWe can make zoom in to frequencies below the Nyquist frequency:\n\n```{r}\n\nplot(fspc[1:(length(fspc) / 2)], type=\"h\", col=\"blue\",\nxlab=\"Frecuency (Hz)\",\nylab=\"Amplitude (no units)\")\n\n```\n\nThis diagram (taken from Sueur 2018) summarizes the process we just simulated:\n\n```{r songs 2.3, out.width = \"400px\", echo = FALSE, fig.align= \"center\"}\n\nknitr::include_graphics(\"images/FFT_decomp.png\")\n\n```\n\n<font size=\"1\"><b>Tomado de Sueur 2018</b></font>\n\nThe periodogram next to the spectrogram of these simulated sounds looks like this:\n\n```{r, echo = FALSE, warning=FALSE, message=FALSE}\n\nopar <- par()\n\npar(mfrow = c(1, 2), mar =c(4, 4, 1, 0))\nplot(fspc[1:(length(fspc) / 2)], 1:(length(fspc) / 2), type=\"l\", col=\"blue\", ylab=\"Frequency (Hz)\",\nxlab=\"Amplitude (no units)\", ylim = c(110, 2890), lwd = 3, xlim = c(10000, 90000))\n\npar(mar = c(4, 0, 1, 1))\nspectro(H0, palette = reverse.gray.colors.1, scale = FALSE, grid = FALSE, f = f, flim = c(0.1, 2.9),  flab = NULL, axisY = FALSE)\n\npar(opar)\n\n```\n\n \n\n## From the Fourier transform to the spectrogram\n\nThe spectrograms are constructed of the spectral decomposition of discrete time segments of amplitude values. Each segment (or window) of time is a column of spectral density values in a frequency range. Take for example this simple modulated sound, which goes up and down in frequency:\n\n```{r, echo = FALSE}\n\nnorm <- dnorm(-4000:3999, sd=1000)\n\ns <- synth2(env=norm, ifreq=500+(norm/max(norm))*1000, f=8000, plot=FALSE, osc=TRUE, ovlp=0)\n\ns.wav <- tuneR::Wave(left = s, samp.rate = 8000, bit = 16)\n\nmonitoR::viewSpec(s.wav,  ovlp = 95, main = NA, frq.lim = c(0, 3))\n\n```\n\n \n\nIf we divide the sound into 10 segments and make periodograms for each of them we can see this pattern in the frequencies:\n\n```{r, eval = F, echo = FALSE}\n\n# animacion de periodograma junto a espectrograma\nnorm <- dnorm(-4000:3999, sd=1000)\n\ns <- synth2(env=norm, ifreq=500+(norm/max(norm))*1000, f=8000, plot=FALSE, osc=TRUE, ovlp=0)\n\n\nlibrary(\"animation\")\n\n\nnum.segmts <- 10\nsq <- round(seq(1, length(s), length.out = num.segmts + 1))\n\nsq.spc <- seq(0, duration(s, f), length.out = num.segmts + 1)\n\n# loop over different number of time windows\nsaveGIF(\n  for(x in 2:length(sq))\n{\n  # modulus fft \n  fspc1 <- Mod(fft(s[sq[(x-1)]:sq[x]]))\n  \n  par(mfrow = c(1, 2), mar =c(4, 4, 1, 0), xaxt = \"n\", yaxt = \"n\")\n  \n  plot(fspc1[1:(length(fspc1) / 2)], 1:(length(fspc1) / 2), type=\"l\", col=\"blue\", ylab=\"Frecuency (Hz)\", xlab=\"Amplitude (no units)\", lwd = 3, ylim = c(20, 220))#, xlim = c(100, max(fspc)))\n\n  usr <- par(\"usr\")\n  \n  axis(side = 2, at = seq(usr[3], usr[4], length.out = 4), labels = seq(0, 3, length.out = 4))\n  \n  \n  par(mar = c(4, 0, 1, 1))\n  spectro(s, palette = reverse.gray.colors.1, scale = FALSE, grid = FALSE, f = f, flim = c(0.2, 3),  flab = NULL, axisY = FALSE, collevels = seq(-100, 0 , 5), wl = 250)\n\n  rect(xleft = sq.spc[x - 1], xright = sq.spc[x], ytop = 4, ybottom = 0, col = adjustcolor(\"blue\", 0.1), border = NA)\n  \n  text(x = mean(sq.spc[x - 1], sq.spc[x]), y = 2.5, labels = (1:num.segmts)[x - 1], cex = 3, pos = 4)\n  \n  },\nmovie.name =  \"periodogram_spectro.gif\", interval = 0.7, ani.width = 480 * 1.5)\n\n\n```\n\n```{r, eval = F, echo = FALSE}\n\n# animacion de periodograma\nnorm <- dnorm(-4000:3999, sd=1000)\n\ns <- synth2(env=norm, ifreq=500+(norm/max(norm))*1000, f=8000, plot=FALSE, osc=TRUE, ovlp=0)\n\n# plot(s[1:1000], type = \"l\", col = \"blue\", xlab = \"Time (samples)\", ylab = \"Amplitude (no units)\")\n# \n# plot(s[7000:8000], type = \"l\", col = \"blue\", xlab = \"Time (samples)\", ylab = \"Amplitude (no units)\")\n# \n# \n# plot(s, type = \"l\", col = \"blue\", xlab = \"Time (samples)\", ylab = \"Amplitude (no units)\")\n\nlibrary(\"animation\")\n\nsq <- round(seq(1, length(s), length.out = 10))\n\n# loop over different number of time windows\nsaveGIF(\n  for(x in 2:length(sq))\n{\n  # modulus fft \n  fspc <- Mod(fft(s[sq[(x-1)]:sq[x]]))\n  \n  plot(fspc, type=\"h\", col=\"blue\",\n  xlab=\"Frecuency (Hz)\",\n  ylab=\"Amplitude (no units)\",\n  xlim = c(0, 400),\n  xaxt = \"n\",\n  yaxt = \"n\" \n  )\n},\nmovie.name =  \"periodogram.gif\", interval = 0.5, ani.width = 480 * 1.5)\n\n\n```\n\n<img src=\"images/periodogram_spectro.gif\" alt=\"Spectrogram resolution\" width=\"600\"/>\n\nThis animation shows in a very simple way the logic behind the spectrograms: if we calculate Fourier transforms for short segments of time through a sound (e.g. amplitude changes in time) and concatenate them, we can visualize the variation in frequencies over time.  \n\n## Overlap\n\nWhen frequency spectra are combined to produce a spectrogram, the frequency and amplitude modulations are not gradual:\n\n```{r, echo = FALSE}\n\ns.wav <- tuneR::Wave(left = s, samp.rate = 8000, bit = 16)\n\nmonitoR::viewSpec(s.wav, main = NA, frq.lim = c(0, 3))\n\n```\n\n \n\nThere are several \"tricks\" to smooth out the contours of signals with high modulation in a spectrogram, although the main and most common is window overlap. The overlap recycles a percentage of the amplitude samples of a window to calculate the next window. For example, the sound used as an example, with a window size of 512 points divides the sound into 15 segments:\n\n```{r, echo = FALSE}\n\nmonitoR::viewSpec(s.wav, main = NA, frq.lim = c(0, 3), wl = 512)\n\nnum.segmts <- 15\n\nusr <- par(\"usr\")\n  \nsq.spc <- seq(usr[1], usr[2], length.out = num.segmts + 1)\n\nfor(x in 2:length(sq.spc))\n  rect(xleft = sq.spc[x - 1], xright = sq.spc[x], ytop = (usr[4] - usr[1]) / 2, ybottom = usr[3], col = adjustcolor(\"blue\", 0.1), border = \"blue\")\n  \n```\n\nA 50% overlap generates windows that share 50% of the amplitude values with the adjacent windows. This has the visual effect of making modulations much more gradual:\n\n```{r, echo = FALSE}\n\nmonitoR::viewSpec(s.wav, main = NA, frq.lim = c(0, 3), wl = 512)\n\nnum.segmts <- 15\n\nusr <- par(\"usr\")\n  \nsq.spc <- seq(usr[1], usr[2], length.out = num.segmts + 1)\n\nfor(x in 2:length(sq.spc))\n  rect(xleft = sq.spc[x - 1], xright = sq.spc[x], ytop = (usr[4] - usr[1]) / 2, ybottom = usr[3], col = adjustcolor(\"blue\", 0.1), border = \"blue\")\n  \n\nsq.spc <- sq.spc + sq.spc[1]\n\nfor(x in 2:(length(sq.spc) - 1))\n  rect(xleft = sq.spc[x - 1], xright = sq.spc[x], ybottom = (usr[4] - usr[1]) / 3, ytop = (usr[4] - usr[1]) / 8 * 7, col = adjustcolor(\"blue\", 0.1), border = \"blue\")\n  \n```\n\nWhich increases (in some way artificially) the number of time windows, without changing the resolution in frequency. In this example, the number of time windows is doubled:\n\n```{r, echo = FALSE}\n\nmonitoR::viewSpec(s.wav, main = NA, frq.lim = c(0, 3), wl = 512, ovlp = 50)\n\nnum.segmts <- 30\n\nusr <- par(\"usr\")\n  \nsq.spc <- seq(usr[1], usr[2], length.out = num.segmts + 1)\n\nfor(x in 2:length(sq.spc))\n  rect(xleft = sq.spc[x - 1], xright = sq.spc[x], ytop = usr[4], ybottom = usr[3], col = adjustcolor(\"blue\", 0.1), border = \"blue\")\n\n\n```\n\nTherefore, the greater the overlap the greater the smoothing of the contours of the sounds:\n\n```{r, eval = FALSE, echo = FALSE}\n\n# animacion resolucion spectrograma\n\nlibrary(animation)\n\n# loop over different number of time windows\nsaveGIF(for(i in c(seq(0, 99, by = 5), rep(99, 15)))\n{\n  monitoR::viewSpec(s.wav, main = paste(\"overlap =\", i), frq.lim = c(0, 3), wl = 512, ovlp = i)\n  \n  \n  num.segmts <- 15  * 100 / (100 - i) \n  \n  usr <- par(\"usr\")\n    \n  sq.spc <- seq(usr[1], usr[2], length.out = num.segmts + 1)\n  \n  for(x in 2:length(sq.spc))\n    rect(xleft = sq.spc[x - 1], xright = sq.spc[x], ytop = usr[4], ybottom = usr[4] * 3/4, col = adjustcolor(\"blue\", 0.1), border = adjustcolor(\"blue\", 1 - (i / 100)))\n  \n  },movie.name =  \"spectro.overlap.gif\", interval = 0.2, ani.width = 480 * 1.5)\n\n```\n\n<img src=\"images/spectro.overlap.gif\" alt=\"Spectrogram overlap\" width=\"600\"/>\n\nThis increases the number of windows as a function of the overlap for this particular sound:\n\n```{r, echo = FALSE}\n\nvnts <- sapply(seq(0, 99, 1), function(i) (8000/512)  * 100 / (100 - i)) \n\npar(mar = c(4, 4, 1, 1))\n\nplot(seq(0, 99, 1), vnts, type =  \"l\", col = \"red\", lwd = 4, ylab = \"# of time windows\", xlab = \"Overlap (%)\")\n\n```\n\n \n\nThis increase in spectrogram sharpness does not come without a cost. The longer the time windows, the greater the number of Fourier transforms to compute, and therefore, the greater the duration of the process. This graphic shows the increase in duration as a function of the number of windows on my computer:\n\n```{r, eval = FALSE, echo = FALSE}\n\ntme <- sapply(seq(0, 99, 1), function(i) \n a <- system.time(monitoR::viewSpec(s.wav, main = paste(\"overlap =\", i), frq.lim = c(0, 3), wl = 512, ovlp = i, plot = FALSE)))\n\n return(a[3])  \n ) \n\nwrite.csv(data.frame(t(tme)), \"time of overlap.csv\", row.names = FALSE)\n```\n\n```{r, eval = TRUE, echo = FALSE}\n\ntme <- read.csv(\"./data/time of overlap.csv\")[, 3]\n\npar(mar = c(4, 4, 1, 1))\n\nplot(vnts, tme * 1000, type =  \"l\", col = \"red\", lwd = 4, xlab = \"# of time windows\", ylab = \"Duration (ms)\")\n\n```\n\n \n\nIt is necessary to take this cost into account when producing spectrograms of long sound files (\\> 1 min).\n\n \n\n## Limitations\n\nHowever, there is a trade-off between the resolution between the 2 domains: the higher the frequency resolution, the lower the resolution in time. The following animation shows, for the sound of the previous example, how the resolution in frequency decreases as the resolution in time increases:\n\n<img src=\"images/spectro.precision.tradeoff2.gif\" alt=\"Spectrogram resolution 2\"/>\n\n```{r, eval = F, echo = FALSE}\n\n# animacion resolucion spectrograma\n\nlibrary(animation)\n\n# loop over different number of time windows\nsaveGIF(for(x in seq(10, 402, 4))\n{\n  # time windows \n  tw <- seq(1, 8000, length.out = x)\n\n  # fourier transform for each time window\n  fspc <- lapply(2:length(tw), function(i) {\n    \n    # transform and log\n    ft <- log(Mod(fft(s[tw[i - 1]:tw[i]])))\n\n    # standardize\n    ft <- ft / max(ft)\n\n    return(ft)\n    })\n\n  # put results together in a matrix\n  spc <- do.call(rbind, fspc)\n  \n  # remover valores sobre frec Nyquist\n  spc <- spc[, 1:(ncol(spc) / 2)]\n  \n  spc[spc > 1] <- 2.2\n  \n  # plot spectrogram\n  image(z = spc, col  = c(\"red\", \"white\"), main = paste0(x, \" time windows (~\", round(1/x * 1000, 1), \" ms each)\"), xlab = \"Time (s)\", axes = FALSE, ylab = \"Frequency (kHz)\", ylim = c(0, 0.75))\n  \n  # add axis\n  axis(side = 1)\n  axis(side = 2, at = seq(0, 0.75, length.out = 4), labels = seq(0, 3, length.out = 4))\n  \n  # wait\n  # Sys.sleep(0.1)\n},movie.name =  \"spectro.precision.tradeoff2.gif\", interval = 0.12, ani.width = 480 * 1.5)\n\n```\n\n \n\nThis is the relationship between frequency resolution and time resolution for the example signal:\n\n```{r, eval = TRUE, echo = FALSE}\n\nout <- lapply(seq(10, 402, 4), function(x)\n{\n\n tw <- seq(1, 8000, length.out = x)\n \n  # transform and log\n  ft <- log(Mod(fft(s[tw[1]:tw[2]])))\n\n\n  return(data.frame(wl = x, res.t = 1 / x, res.f = 4000 / length(ft)))\n  })\n\nres <- do.call(rbind, out)\n\n\npar( mar =c(4, 4, 1, 1))\n\nplot(res$res.t, res$res.f, type =  \"l\", col = \"blue\", lwd = 4, xlab = \"Time window size (s)\", ylab = \"Frequency bin size (Hz)\")\n\n```\n\n \n\n \n\n## Creating spectrograms in R\n\nThere are several R packages with functions that produce spectrograms in the graphical device. This chart (taken from Sueur 2018) summarizes the functions and their arguments: <img src=\"images/r-spectrogram-funs.png\" alt=\"Spectrogram functions\" width=\"700\"/>\n\n \n\nWe will focus on making spectrograms using the `spectro ()` function of **seewave**:\n\n```{r, eval = TRUE, echo = TRUE}\n\ntico2 <- cutw(tico, from = 0.55, to = 0.9, output = \"Wave\")\n\nspectro(tico2,  f = 22050, wl = 512, ovlp = 90,\n        collevels = seq(-40, 0, 0.5),\n        flim = c(2, 6), scale = FALSE)\n\n```\n\n \n\n::: {.alert .alert-info}\n<font size=\"5\">Exercise</font>\n\n-   How can I increase the overlap between time windows?\n\n-   How much longer it takes to create a 99%-overlap spectrogram compare to a 5%-overlap spectrogram?\n\n-   What does the argument 'collevels' do? Increase the range and look at the spectrogram.\n\n-   What do the 'flim' and 'tlim' arguments determine?\n\n-   Run the examples that come in the `spectro()` function documentation\n:::\n\n \n\nAlmost all components of a spectrogram in **seewave** can be modified. We can add scales:\n\n```{r, eval = TRUE, echo = TRUE}\n\nspectro(tico2,  f = 22050, wl = 512, ovlp = 90,\n        collevels = seq(-40, 0, 0.5),\n        flim = c(2, 6), scale = TRUE)\n\n```\n\nChange the color palette:\n\n```{r, eval = TRUE, echo = TRUE}\n\nspectro(tico2,  f = 22050, wl = 512, ovlp = 90,\n        collevels = seq(-40, 0, 0.5),\n        flim = c(2, 6), scale = TRUE,\n          palette = reverse.cm.colors)\n\n```\n\n```{r, eval = TRUE, echo = TRUE}\n\nspectro(tico2,  f = 22050, wl = 512, ovlp = 90,\n        collevels = seq(-40, 0, 0.5),\n        flim = c(2, 6), scale = TRUE,\n          palette = reverse.gray.colors.1)\n\n```\n\nRemove the vertical lines:\n\n```{r, eval = TRUE, echo = TRUE}\n\nspectro(tico2,  f = 22050, wl = 512, ovlp = 90,\n        collevels = seq(-40, 0, 0.5),\n        flim = c(2, 6), scale = TRUE,\n          palette = reverse.gray.colors.1,\n        grid = FALSE)\n\n```\n\nAdd oscillograms (waveforms):\n\n```{r, eval = TRUE, echo = TRUE}\n\nspectro(tico2,  f = 22050, wl = 512, ovlp = 90,\n        collevels = seq(-40, 0, 0.5),\n        flim = c(2, 6), scale = TRUE,\n          palette = reverse.gray.colors.1,\n        grid = FALSE, \n        osc = TRUE)\n\n```\n\n \n\n::: {.alert .alert-info}\n<font size=\"5\">Exercise</font>\n\n-   Change the color of the oscillogram to red\n\n-   These are some of the color palettes that fit well the gradients in spectrograms:  \n\n    <img src=\"images/palletes.png\" alt=\"Spectrogram palletes\" width=\"480\"/>\n\n<font size=\"1\"><b>From Sueur 2018</b></font>\n\n \n\nUse at least 3 palettes to generate the \"tico2\" spectrogram\n\n \n\n-   Change the relative height of the oscillogram so that it corresponds to 1/3 of the height of the spectrogram\n\n-   Change the relative width of the amplitude scale so that it corresponds to 1/8 of the spectrogram width\n\n-   What does the \"zp\" argument do? (hint: try `zp = 100` and notice the effect on the spectrogram)\n\n-   Which value of \"wl\" (window size) generates smoother spectrograms for the example \"orni\" object?\n\n-   The package `viridis` provides some color palettes that are better perceived by people with forms of color blindness and/or color vision deficiency. Install the package and try some of the color palettes available (try `?viridis`)\n:::\n\n \n\n## Dynamic spectrograms\n\nThe package [dynaSpec](https://marce10.github.io/dynaSpec) allows to create static and dynamic visualizations of sounds, ready for publication or presentation. These dynamic spectrograms are produced natively with base graphics, and are save as an .mp4 video in the working directory:\n\n```{r, eval = FALSE}\n\n\nngh_wren <- read_sound_file(\"https://www.xeno-canto.org/518334/download\")\n\ncustom_pal <- colorRampPalette( c(\"#2d2d86\", \"#2d2d86\", reverse.terrain.colors(10)[5:10]))\n\nlibrary(dynaSpec)\n\nscrolling_spectro(wave = ngh_wren, wl = 600, \n    t.display = 3, ovlp = 95, pal = custom_pal, \n    grid = FALSE, flim = c(2, 8), width = 700, \n    height = 250, res = 100, collevels = seq(-40, 0, 5),\n    file.name = \"../nightingale_wren.mp4\", colbg = \"#2d2d86\", lcol = \"#FFFFFFE6\")\n```\n\n<iframe width=\"100%\" height=\"297\" src=\"images/nightingale_wren.mp4\" allowtransparency=\"true\" style=\"background: #FFFFFF;\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen>\n\n</iframe>\n\n \n\n------------------------------------------------------------------------\n\n## References\n\n1.  Araya-Salas, Marcelo and Wilkins, Matthew R. (2020), dynaSpec: dynamic spectrogram visualizations in R. R package version 1.0.0.\n\n2.  Sueur J, Aubin T, Simonis C. 2008. Equipment review: seewave, a free modular tool for sound analysis and synthesis. Bioacoustics 18(2):213--226.\n\n3.  Sueur, J. (2018). Sound Analysis and Synthesis with R.\n\n------------------------------------------------------------------------\n\n \n\n<font size=\"4\">Session information</font>\n\n```{r session info, echo=F}\n\nsessionInfo()\n\n```\n","srcMarkdownNoYaml":"\n\n \n\n::: {.alert .alert-info}\n## **Objetives** {.unnumbered .unlisted}\n\n-   Understand how spectrograms are created\n\n-   Learn to create and customize spectrograms in R\n:::\n\n \n\n```{r, echo = FALSE}\nlibrary(knitr)\n\nopts_chunk$set(tidy = TRUE, warning = FALSE, message = FALSE)\n\n```\n\nThe spectrogram is a fundamental tool in the study of acoustic communication in vertebrates. They are basically a visual representation of the sound where the variation in energy (or power spectral density) is shown on both the frequency and the time domains. Spectrograms allow us to visually explore acoustic variation in our study systems, which makes it easy to distinguish structural differences at small temporal/spectral scales that our ears cannot detect.\n\nWe will use the **seewave** package and its sample data:\n\n```{r, echo=TRUE, warning=FALSE, message=FALSE}\n\nlibrary(seewave)\n\n# load examples\ndata(tico)\n\ndata(orni)\n\n```\n\n## Fourier transform\n\nIn order to understand the information contained in a spectrogram it is necessary to understand, at least briefly, the [Fourier transform](https://en.wikipedia.org/wiki/Fourier_transform). In simple words, this is a mathematical transformation that detects the periodicity in time series, identifying the different frequencies that compose them and their relative energy. Therefore it is said that it transforms the signals from the time domain to the frequency domain.\n\nTo better understand how it works, we can simulate time series composed of pre-defined frequencies. In this example we simulate 3 frequencies and join them in a single time series:\n\n```{r}\n# freq\nf <- 11025\n\n# time sequence\nt <- seq(1/f, 1, length.out=f)\n\n# period\npr <- 1/440\nw0 <- 2 * pi/pr\n\n# frec 1\nh1 <- 5 * cos(w0*t)\n\nplot(h1[1:75], type = \"l\", col = \"blue\", xlab = \"Time (samples)\", ylab = \"Amplitude (no units)\")\n\n# frec 2\nh2 <- 10 * cos(2 * w0 * t)\n\nplot(h2[1:75], type = \"l\", col = \"blue\", xlab = \"Time (samples)\", ylab = \"Amplitude (no units)\")\n\n# frec 3\nh3 <- 15 * sin(3 * w0 * t)\n\nplot(h3[1:75], type = \"l\", col = \"blue\", xlab = \"Time (samples)\", ylab = \"Amplitude (no units)\")\n\n```\n\nThis is what the union of the three frequencies looks like:\n\n```{r}\nH0 <- 0.5 + h1 + h2 + h3\n\nplot(H0[1:75], type = \"l\", col = \"blue\", xlab = \"Time (samples)\", ylab = \"Amplitude (no units)\")\n\n```\n\nNow we can apply the Fourier transform to this time series and graph the frequencies detected using a periodogram:\n\n```{r}\n\nfspc <- Mod(fft(H0))\n\nplot(fspc, type=\"h\", col=\"blue\",\nxlab=\"Frecuency (Hz)\",\nylab=\"Amplitude (no units)\")\n\nabline(v = f / 2, lty = 2)\n\ntext(x = (f / 2) + 1650, y = 8000, \"Nyquist Frequency\")\n\n```\n\nWe can make zoom in to frequencies below the Nyquist frequency:\n\n```{r}\n\nplot(fspc[1:(length(fspc) / 2)], type=\"h\", col=\"blue\",\nxlab=\"Frecuency (Hz)\",\nylab=\"Amplitude (no units)\")\n\n```\n\nThis diagram (taken from Sueur 2018) summarizes the process we just simulated:\n\n```{r songs 2.3, out.width = \"400px\", echo = FALSE, fig.align= \"center\"}\n\nknitr::include_graphics(\"images/FFT_decomp.png\")\n\n```\n\n<font size=\"1\"><b>Tomado de Sueur 2018</b></font>\n\nThe periodogram next to the spectrogram of these simulated sounds looks like this:\n\n```{r, echo = FALSE, warning=FALSE, message=FALSE}\n\nopar <- par()\n\npar(mfrow = c(1, 2), mar =c(4, 4, 1, 0))\nplot(fspc[1:(length(fspc) / 2)], 1:(length(fspc) / 2), type=\"l\", col=\"blue\", ylab=\"Frequency (Hz)\",\nxlab=\"Amplitude (no units)\", ylim = c(110, 2890), lwd = 3, xlim = c(10000, 90000))\n\npar(mar = c(4, 0, 1, 1))\nspectro(H0, palette = reverse.gray.colors.1, scale = FALSE, grid = FALSE, f = f, flim = c(0.1, 2.9),  flab = NULL, axisY = FALSE)\n\npar(opar)\n\n```\n\n \n\n## From the Fourier transform to the spectrogram\n\nThe spectrograms are constructed of the spectral decomposition of discrete time segments of amplitude values. Each segment (or window) of time is a column of spectral density values in a frequency range. Take for example this simple modulated sound, which goes up and down in frequency:\n\n```{r, echo = FALSE}\n\nnorm <- dnorm(-4000:3999, sd=1000)\n\ns <- synth2(env=norm, ifreq=500+(norm/max(norm))*1000, f=8000, plot=FALSE, osc=TRUE, ovlp=0)\n\ns.wav <- tuneR::Wave(left = s, samp.rate = 8000, bit = 16)\n\nmonitoR::viewSpec(s.wav,  ovlp = 95, main = NA, frq.lim = c(0, 3))\n\n```\n\n \n\nIf we divide the sound into 10 segments and make periodograms for each of them we can see this pattern in the frequencies:\n\n```{r, eval = F, echo = FALSE}\n\n# animacion de periodograma junto a espectrograma\nnorm <- dnorm(-4000:3999, sd=1000)\n\ns <- synth2(env=norm, ifreq=500+(norm/max(norm))*1000, f=8000, plot=FALSE, osc=TRUE, ovlp=0)\n\n\nlibrary(\"animation\")\n\n\nnum.segmts <- 10\nsq <- round(seq(1, length(s), length.out = num.segmts + 1))\n\nsq.spc <- seq(0, duration(s, f), length.out = num.segmts + 1)\n\n# loop over different number of time windows\nsaveGIF(\n  for(x in 2:length(sq))\n{\n  # modulus fft \n  fspc1 <- Mod(fft(s[sq[(x-1)]:sq[x]]))\n  \n  par(mfrow = c(1, 2), mar =c(4, 4, 1, 0), xaxt = \"n\", yaxt = \"n\")\n  \n  plot(fspc1[1:(length(fspc1) / 2)], 1:(length(fspc1) / 2), type=\"l\", col=\"blue\", ylab=\"Frecuency (Hz)\", xlab=\"Amplitude (no units)\", lwd = 3, ylim = c(20, 220))#, xlim = c(100, max(fspc)))\n\n  usr <- par(\"usr\")\n  \n  axis(side = 2, at = seq(usr[3], usr[4], length.out = 4), labels = seq(0, 3, length.out = 4))\n  \n  \n  par(mar = c(4, 0, 1, 1))\n  spectro(s, palette = reverse.gray.colors.1, scale = FALSE, grid = FALSE, f = f, flim = c(0.2, 3),  flab = NULL, axisY = FALSE, collevels = seq(-100, 0 , 5), wl = 250)\n\n  rect(xleft = sq.spc[x - 1], xright = sq.spc[x], ytop = 4, ybottom = 0, col = adjustcolor(\"blue\", 0.1), border = NA)\n  \n  text(x = mean(sq.spc[x - 1], sq.spc[x]), y = 2.5, labels = (1:num.segmts)[x - 1], cex = 3, pos = 4)\n  \n  },\nmovie.name =  \"periodogram_spectro.gif\", interval = 0.7, ani.width = 480 * 1.5)\n\n\n```\n\n```{r, eval = F, echo = FALSE}\n\n# animacion de periodograma\nnorm <- dnorm(-4000:3999, sd=1000)\n\ns <- synth2(env=norm, ifreq=500+(norm/max(norm))*1000, f=8000, plot=FALSE, osc=TRUE, ovlp=0)\n\n# plot(s[1:1000], type = \"l\", col = \"blue\", xlab = \"Time (samples)\", ylab = \"Amplitude (no units)\")\n# \n# plot(s[7000:8000], type = \"l\", col = \"blue\", xlab = \"Time (samples)\", ylab = \"Amplitude (no units)\")\n# \n# \n# plot(s, type = \"l\", col = \"blue\", xlab = \"Time (samples)\", ylab = \"Amplitude (no units)\")\n\nlibrary(\"animation\")\n\nsq <- round(seq(1, length(s), length.out = 10))\n\n# loop over different number of time windows\nsaveGIF(\n  for(x in 2:length(sq))\n{\n  # modulus fft \n  fspc <- Mod(fft(s[sq[(x-1)]:sq[x]]))\n  \n  plot(fspc, type=\"h\", col=\"blue\",\n  xlab=\"Frecuency (Hz)\",\n  ylab=\"Amplitude (no units)\",\n  xlim = c(0, 400),\n  xaxt = \"n\",\n  yaxt = \"n\" \n  )\n},\nmovie.name =  \"periodogram.gif\", interval = 0.5, ani.width = 480 * 1.5)\n\n\n```\n\n<img src=\"images/periodogram_spectro.gif\" alt=\"Spectrogram resolution\" width=\"600\"/>\n\nThis animation shows in a very simple way the logic behind the spectrograms: if we calculate Fourier transforms for short segments of time through a sound (e.g. amplitude changes in time) and concatenate them, we can visualize the variation in frequencies over time.  \n\n## Overlap\n\nWhen frequency spectra are combined to produce a spectrogram, the frequency and amplitude modulations are not gradual:\n\n```{r, echo = FALSE}\n\ns.wav <- tuneR::Wave(left = s, samp.rate = 8000, bit = 16)\n\nmonitoR::viewSpec(s.wav, main = NA, frq.lim = c(0, 3))\n\n```\n\n \n\nThere are several \"tricks\" to smooth out the contours of signals with high modulation in a spectrogram, although the main and most common is window overlap. The overlap recycles a percentage of the amplitude samples of a window to calculate the next window. For example, the sound used as an example, with a window size of 512 points divides the sound into 15 segments:\n\n```{r, echo = FALSE}\n\nmonitoR::viewSpec(s.wav, main = NA, frq.lim = c(0, 3), wl = 512)\n\nnum.segmts <- 15\n\nusr <- par(\"usr\")\n  \nsq.spc <- seq(usr[1], usr[2], length.out = num.segmts + 1)\n\nfor(x in 2:length(sq.spc))\n  rect(xleft = sq.spc[x - 1], xright = sq.spc[x], ytop = (usr[4] - usr[1]) / 2, ybottom = usr[3], col = adjustcolor(\"blue\", 0.1), border = \"blue\")\n  \n```\n\nA 50% overlap generates windows that share 50% of the amplitude values with the adjacent windows. This has the visual effect of making modulations much more gradual:\n\n```{r, echo = FALSE}\n\nmonitoR::viewSpec(s.wav, main = NA, frq.lim = c(0, 3), wl = 512)\n\nnum.segmts <- 15\n\nusr <- par(\"usr\")\n  \nsq.spc <- seq(usr[1], usr[2], length.out = num.segmts + 1)\n\nfor(x in 2:length(sq.spc))\n  rect(xleft = sq.spc[x - 1], xright = sq.spc[x], ytop = (usr[4] - usr[1]) / 2, ybottom = usr[3], col = adjustcolor(\"blue\", 0.1), border = \"blue\")\n  \n\nsq.spc <- sq.spc + sq.spc[1]\n\nfor(x in 2:(length(sq.spc) - 1))\n  rect(xleft = sq.spc[x - 1], xright = sq.spc[x], ybottom = (usr[4] - usr[1]) / 3, ytop = (usr[4] - usr[1]) / 8 * 7, col = adjustcolor(\"blue\", 0.1), border = \"blue\")\n  \n```\n\nWhich increases (in some way artificially) the number of time windows, without changing the resolution in frequency. In this example, the number of time windows is doubled:\n\n```{r, echo = FALSE}\n\nmonitoR::viewSpec(s.wav, main = NA, frq.lim = c(0, 3), wl = 512, ovlp = 50)\n\nnum.segmts <- 30\n\nusr <- par(\"usr\")\n  \nsq.spc <- seq(usr[1], usr[2], length.out = num.segmts + 1)\n\nfor(x in 2:length(sq.spc))\n  rect(xleft = sq.spc[x - 1], xright = sq.spc[x], ytop = usr[4], ybottom = usr[3], col = adjustcolor(\"blue\", 0.1), border = \"blue\")\n\n\n```\n\nTherefore, the greater the overlap the greater the smoothing of the contours of the sounds:\n\n```{r, eval = FALSE, echo = FALSE}\n\n# animacion resolucion spectrograma\n\nlibrary(animation)\n\n# loop over different number of time windows\nsaveGIF(for(i in c(seq(0, 99, by = 5), rep(99, 15)))\n{\n  monitoR::viewSpec(s.wav, main = paste(\"overlap =\", i), frq.lim = c(0, 3), wl = 512, ovlp = i)\n  \n  \n  num.segmts <- 15  * 100 / (100 - i) \n  \n  usr <- par(\"usr\")\n    \n  sq.spc <- seq(usr[1], usr[2], length.out = num.segmts + 1)\n  \n  for(x in 2:length(sq.spc))\n    rect(xleft = sq.spc[x - 1], xright = sq.spc[x], ytop = usr[4], ybottom = usr[4] * 3/4, col = adjustcolor(\"blue\", 0.1), border = adjustcolor(\"blue\", 1 - (i / 100)))\n  \n  },movie.name =  \"spectro.overlap.gif\", interval = 0.2, ani.width = 480 * 1.5)\n\n```\n\n<img src=\"images/spectro.overlap.gif\" alt=\"Spectrogram overlap\" width=\"600\"/>\n\nThis increases the number of windows as a function of the overlap for this particular sound:\n\n```{r, echo = FALSE}\n\nvnts <- sapply(seq(0, 99, 1), function(i) (8000/512)  * 100 / (100 - i)) \n\npar(mar = c(4, 4, 1, 1))\n\nplot(seq(0, 99, 1), vnts, type =  \"l\", col = \"red\", lwd = 4, ylab = \"# of time windows\", xlab = \"Overlap (%)\")\n\n```\n\n \n\nThis increase in spectrogram sharpness does not come without a cost. The longer the time windows, the greater the number of Fourier transforms to compute, and therefore, the greater the duration of the process. This graphic shows the increase in duration as a function of the number of windows on my computer:\n\n```{r, eval = FALSE, echo = FALSE}\n\ntme <- sapply(seq(0, 99, 1), function(i) \n a <- system.time(monitoR::viewSpec(s.wav, main = paste(\"overlap =\", i), frq.lim = c(0, 3), wl = 512, ovlp = i, plot = FALSE)))\n\n return(a[3])  \n ) \n\nwrite.csv(data.frame(t(tme)), \"time of overlap.csv\", row.names = FALSE)\n```\n\n```{r, eval = TRUE, echo = FALSE}\n\ntme <- read.csv(\"./data/time of overlap.csv\")[, 3]\n\npar(mar = c(4, 4, 1, 1))\n\nplot(vnts, tme * 1000, type =  \"l\", col = \"red\", lwd = 4, xlab = \"# of time windows\", ylab = \"Duration (ms)\")\n\n```\n\n \n\nIt is necessary to take this cost into account when producing spectrograms of long sound files (\\> 1 min).\n\n \n\n## Limitations\n\nHowever, there is a trade-off between the resolution between the 2 domains: the higher the frequency resolution, the lower the resolution in time. The following animation shows, for the sound of the previous example, how the resolution in frequency decreases as the resolution in time increases:\n\n<img src=\"images/spectro.precision.tradeoff2.gif\" alt=\"Spectrogram resolution 2\"/>\n\n```{r, eval = F, echo = FALSE}\n\n# animacion resolucion spectrograma\n\nlibrary(animation)\n\n# loop over different number of time windows\nsaveGIF(for(x in seq(10, 402, 4))\n{\n  # time windows \n  tw <- seq(1, 8000, length.out = x)\n\n  # fourier transform for each time window\n  fspc <- lapply(2:length(tw), function(i) {\n    \n    # transform and log\n    ft <- log(Mod(fft(s[tw[i - 1]:tw[i]])))\n\n    # standardize\n    ft <- ft / max(ft)\n\n    return(ft)\n    })\n\n  # put results together in a matrix\n  spc <- do.call(rbind, fspc)\n  \n  # remover valores sobre frec Nyquist\n  spc <- spc[, 1:(ncol(spc) / 2)]\n  \n  spc[spc > 1] <- 2.2\n  \n  # plot spectrogram\n  image(z = spc, col  = c(\"red\", \"white\"), main = paste0(x, \" time windows (~\", round(1/x * 1000, 1), \" ms each)\"), xlab = \"Time (s)\", axes = FALSE, ylab = \"Frequency (kHz)\", ylim = c(0, 0.75))\n  \n  # add axis\n  axis(side = 1)\n  axis(side = 2, at = seq(0, 0.75, length.out = 4), labels = seq(0, 3, length.out = 4))\n  \n  # wait\n  # Sys.sleep(0.1)\n},movie.name =  \"spectro.precision.tradeoff2.gif\", interval = 0.12, ani.width = 480 * 1.5)\n\n```\n\n \n\nThis is the relationship between frequency resolution and time resolution for the example signal:\n\n```{r, eval = TRUE, echo = FALSE}\n\nout <- lapply(seq(10, 402, 4), function(x)\n{\n\n tw <- seq(1, 8000, length.out = x)\n \n  # transform and log\n  ft <- log(Mod(fft(s[tw[1]:tw[2]])))\n\n\n  return(data.frame(wl = x, res.t = 1 / x, res.f = 4000 / length(ft)))\n  })\n\nres <- do.call(rbind, out)\n\n\npar( mar =c(4, 4, 1, 1))\n\nplot(res$res.t, res$res.f, type =  \"l\", col = \"blue\", lwd = 4, xlab = \"Time window size (s)\", ylab = \"Frequency bin size (Hz)\")\n\n```\n\n \n\n \n\n## Creating spectrograms in R\n\nThere are several R packages with functions that produce spectrograms in the graphical device. This chart (taken from Sueur 2018) summarizes the functions and their arguments: <img src=\"images/r-spectrogram-funs.png\" alt=\"Spectrogram functions\" width=\"700\"/>\n\n \n\nWe will focus on making spectrograms using the `spectro ()` function of **seewave**:\n\n```{r, eval = TRUE, echo = TRUE}\n\ntico2 <- cutw(tico, from = 0.55, to = 0.9, output = \"Wave\")\n\nspectro(tico2,  f = 22050, wl = 512, ovlp = 90,\n        collevels = seq(-40, 0, 0.5),\n        flim = c(2, 6), scale = FALSE)\n\n```\n\n \n\n::: {.alert .alert-info}\n<font size=\"5\">Exercise</font>\n\n-   How can I increase the overlap between time windows?\n\n-   How much longer it takes to create a 99%-overlap spectrogram compare to a 5%-overlap spectrogram?\n\n-   What does the argument 'collevels' do? Increase the range and look at the spectrogram.\n\n-   What do the 'flim' and 'tlim' arguments determine?\n\n-   Run the examples that come in the `spectro()` function documentation\n:::\n\n \n\nAlmost all components of a spectrogram in **seewave** can be modified. We can add scales:\n\n```{r, eval = TRUE, echo = TRUE}\n\nspectro(tico2,  f = 22050, wl = 512, ovlp = 90,\n        collevels = seq(-40, 0, 0.5),\n        flim = c(2, 6), scale = TRUE)\n\n```\n\nChange the color palette:\n\n```{r, eval = TRUE, echo = TRUE}\n\nspectro(tico2,  f = 22050, wl = 512, ovlp = 90,\n        collevels = seq(-40, 0, 0.5),\n        flim = c(2, 6), scale = TRUE,\n          palette = reverse.cm.colors)\n\n```\n\n```{r, eval = TRUE, echo = TRUE}\n\nspectro(tico2,  f = 22050, wl = 512, ovlp = 90,\n        collevels = seq(-40, 0, 0.5),\n        flim = c(2, 6), scale = TRUE,\n          palette = reverse.gray.colors.1)\n\n```\n\nRemove the vertical lines:\n\n```{r, eval = TRUE, echo = TRUE}\n\nspectro(tico2,  f = 22050, wl = 512, ovlp = 90,\n        collevels = seq(-40, 0, 0.5),\n        flim = c(2, 6), scale = TRUE,\n          palette = reverse.gray.colors.1,\n        grid = FALSE)\n\n```\n\nAdd oscillograms (waveforms):\n\n```{r, eval = TRUE, echo = TRUE}\n\nspectro(tico2,  f = 22050, wl = 512, ovlp = 90,\n        collevels = seq(-40, 0, 0.5),\n        flim = c(2, 6), scale = TRUE,\n          palette = reverse.gray.colors.1,\n        grid = FALSE, \n        osc = TRUE)\n\n```\n\n \n\n::: {.alert .alert-info}\n<font size=\"5\">Exercise</font>\n\n-   Change the color of the oscillogram to red\n\n-   These are some of the color palettes that fit well the gradients in spectrograms:  \n\n    <img src=\"images/palletes.png\" alt=\"Spectrogram palletes\" width=\"480\"/>\n\n<font size=\"1\"><b>From Sueur 2018</b></font>\n\n \n\nUse at least 3 palettes to generate the \"tico2\" spectrogram\n\n \n\n-   Change the relative height of the oscillogram so that it corresponds to 1/3 of the height of the spectrogram\n\n-   Change the relative width of the amplitude scale so that it corresponds to 1/8 of the spectrogram width\n\n-   What does the \"zp\" argument do? (hint: try `zp = 100` and notice the effect on the spectrogram)\n\n-   Which value of \"wl\" (window size) generates smoother spectrograms for the example \"orni\" object?\n\n-   The package `viridis` provides some color palettes that are better perceived by people with forms of color blindness and/or color vision deficiency. Install the package and try some of the color palettes available (try `?viridis`)\n:::\n\n \n\n## Dynamic spectrograms\n\nThe package [dynaSpec](https://marce10.github.io/dynaSpec) allows to create static and dynamic visualizations of sounds, ready for publication or presentation. These dynamic spectrograms are produced natively with base graphics, and are save as an .mp4 video in the working directory:\n\n```{r, eval = FALSE}\n\n\nngh_wren <- read_sound_file(\"https://www.xeno-canto.org/518334/download\")\n\ncustom_pal <- colorRampPalette( c(\"#2d2d86\", \"#2d2d86\", reverse.terrain.colors(10)[5:10]))\n\nlibrary(dynaSpec)\n\nscrolling_spectro(wave = ngh_wren, wl = 600, \n    t.display = 3, ovlp = 95, pal = custom_pal, \n    grid = FALSE, flim = c(2, 8), width = 700, \n    height = 250, res = 100, collevels = seq(-40, 0, 5),\n    file.name = \"../nightingale_wren.mp4\", colbg = \"#2d2d86\", lcol = \"#FFFFFFE6\")\n```\n\n<iframe width=\"100%\" height=\"297\" src=\"images/nightingale_wren.mp4\" allowtransparency=\"true\" style=\"background: #FFFFFF;\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen>\n\n</iframe>\n\n \n\n------------------------------------------------------------------------\n\n## References\n\n1.  Araya-Salas, Marcelo and Wilkins, Matthew R. (2020), dynaSpec: dynamic spectrogram visualizations in R. R package version 1.0.0.\n\n2.  Sueur J, Aubin T, Simonis C. 2008. Equipment review: seewave, a free modular tool for sound analysis and synthesis. Bioacoustics 18(2):213--226.\n\n3.  Sueur, J. (2018). Sound Analysis and Synthesis with R.\n\n------------------------------------------------------------------------\n\n \n\n<font size=\"4\">Session information</font>\n\n```{r session info, echo=F}\n\nsessionInfo()\n\n```\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"kable","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"show","code-overflow":"wrap","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":true,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"toc-depth":2,"number-sections":true,"highlight-style":"pygments","css":["styles.css"],"output-file":"spectrograms.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.4.549","toc-location":"left","toc-title":"Contents","code-copy":true,"date":"today","title":"Building spectrograms"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}