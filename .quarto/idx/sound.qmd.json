{"title":"<font size=\"7\"><b>Sound</b></font>","markdown":{"yaml":{"title":"<font size=\"7\"><b>Sound</b></font>","editor_options":{"chunk_output_type":"console"}},"headingText":"**Objetives**","headingAttr":{"id":"","classes":["unnumbered","unlisted"],"keyvalue":[]},"containsRefs":false,"markdown":"\n\n \n\n::: {.alert .alert-info}\n\n-   Learn the basic aspects of sound as a physical phenomenom\n\n-   Get familiar with how sound is represented as a digital object in R\n:::\n\n \n\n```{r, echo = FALSE}\n\nlibrary(seewave)\nlibrary(knitr)\nopts_chunk$set(tidy = TRUE, warning = FALSE, message = FALSE)\n\n```\n\n \n\nSound waves are characterized by compression and expansion of the medium as sound energy moves through it. There is also back and forth motion of the particles making up the medium:\n\n<img src=\"images/wave_white_bg.gif\" alt=\"wave animation\" width=\"700\"/>\n\n<font size=\"3\"> taken from https://dosits.org</font>\n\n \n\nThe variation in pressure that is perceived at a fixed point in space can be represented by a graph of pressure (amplitude) by time:\n\n![wave and oscillogram](images/amplitude.gif){width=\"600\" height=\"350\"}\n\n \n\nSounds waves are typically quantified by their frequency (number of cycles per second, Hz) and amplitude (relative intensity).\n\n```{r, echo = FALSE, out.width=\"85%\", warning=FALSE, message=FALSE}\n\nopar <- par()\nx <- c(0, 0.1, 0.55, 1)\ny <- c(0, 0.4, 0.8, 1)\n\nlwd <-4\ncol <- viridis::viridis(10)[3]\nmat <- matrix(c(\n  c(x[1], x[2], y[1], y[4]), # 1 left amptliude panel\n  c(x[1], x[4], y[3], y[4]), # 2 upper freq panel\n  c(x[2], x[3], y[2], y[3]), # 3 left upper oscillo\n  c(x[3], x[4], y[2], y[3]), # 4 right upper oscillo\n  c(x[2], x[3], y[1], y[2]), # 5 left lower oscillo\n  c(x[3], x[4], y[1], y[2]) # 6 left upper oscillo\n),  ncol = 4, byrow = TRUE\n)\n\na <- split.screen(figs = mat)\n\nscreen(1)\n\npar(mar = c(0, 0, 0, 0), bg = \"white\", new = T)\nplot(1, frame.plot = FALSE, type = \"n\", xaxt='n', yaxt='n')\ntext(x = 0.8, y = 0.98, \"Frequency\", srt = 90,  cex = 2)\ntext(x = 1.2, y = 1.2, \"High\", srt = 90,  cex = 1.2)\ntext(x = 1.2, y = 0.8, \"Low\", srt = 90,  cex = 1.2)\n\n\nscreen(2)\n\npar(mar = c(0, 0, 0, 0), bg = \"white\", new = T)\nplot(1, frame.plot = FALSE, type = \"n\", xaxt='n', yaxt='n')\ntext(x = 1.04, y = 1.1, \"Amplitude\",  cex = 2)\ntext(x = 0.8, y = 0.8, \"Low\", cex = 1.2)\ntext(x = 1.2, y = 0.8, \"High\", cex = 1.2)\n\n# generate sine wave\nhigh.freq <- tuneR::sine(freq = 440, duration = 500, xunit = \"samples\", samp.rate = 44100)\nlow.freq <- tuneR::sine(freq = 220, duration = 500, xunit = \"samples\", samp.rate = 44100)\n\nscreen(3)\npar(mar = rep(0, 4))\n\n# plot\nplot(high.freq@left / 2, type = \"l\", xaxt='n', yaxt='n', ylim = c(-1, 1), lwd = lwd, col = col) \nabline(h = 0, lty = 2)\n\nscreen(4)\npar(mar = rep(0, 4))\nplot(high.freq@left, type = \"l\", xaxt='n', yaxt='n', ylim = c(-1, 1), lwd = lwd, col = col)\nabline(h = 0, lty = 2)\n\n# \nscreen(5)\npar(mar = rep(0, 4))\nplot(low.freq@left / 2, type = \"l\", xaxt='n', yaxt='n', ylim = c(-1, 1), lwd = lwd, col = col)\nabline(h = 0, lty = 2)\n\nscreen(6)\npar(mar = rep(0, 4))\nplot(low.freq@left, type = \"l\", xaxt='n', ann=FALSE, yaxt='n', ylim = c(-1, 1), lwd = lwd, col = col)\nabline(h = 0, lty = 2)\n \nclose.screen(all.screens = TRUE)\n\npar(opar)\n# dev.off()\n\n\n```\n\n \n\n::: {.alert .alert-success}\n<font size=\"6\"><b>Digitizing sound</b></font>\n\n \n\n## Sampling frequency\n\nDigitizing implies discretizing, which requires some sort of regular sampling. Sampling frequency refers to how many samples of the pressure level of the environment are taken per second. A 440 Hz sine wave recorded at 44100 Hz would have around 100 samples per cycle. This plot shows 2 cycles of a 440 Hz sine wave sampled (vertical dotted lines) at 4410 Hz (a 1/10 of the recording sampling rate):\n\n```{r, echo = FALSE, out.width=\"100%\", fig.height= 3, warning=FALSE, message=FALSE}\n\nopar <- par()\n\npar(mar = c(4, 4, 1, 1), bg = \"#d1e7dd\")\n# generate sine wave\nsn.wv <- tuneR::sine(freq = 440, duration = 200, xunit = \"samples\", samp.rate = 44100)\n\nplot(x = seq(0, duration(sn.wv), length.out = length(sn.wv)), y = sn.wv@left, type = \"l\", yaxt='n', ylim = c(-1, 1), lwd = lwd, col = col, xlab = \"Time (s)\", ylab = \"Amplitude\", xaxs='i')\n\nrect(xleft=0, xright= duration(sn.wv)/ 2, ybottom=-2, ytop=2, col = adjustcolor(\"gray\", alpha.f = 0.3), border = NA)\n\nabline(h = 0, lty = 2)\n\nabline(v = seq(0, duration(sn.wv), length.out = length(sn.wv))[seq(0, length(sn.wv), 10)], lwd = 0.5, lty = 2)\n\n\npoints(y = sn.wv@left[seq(0, length(sn.wv), 10)], x = seq(0, duration(sn.wv), length.out = length(sn.wv))[seq(0, length(sn.wv), 10)], col = \"orange\", pch = 20, cex = 2)\n\n\n```\n\n## Nyquist frequency\n\nSampling should be good enough so the regularity of the sine wave can be reconstructed from the sampled data. Low sampling frequencies of a high frequency sine wave might not be able to provide enough information. For instance, the same 440 Hz sine wave sampled at 22050 Hz looks like this:\n\n```{r, echo = FALSE, out.width=\"100%\", fig.height= 3, warning=FALSE, message=FALSE}\n\n\npar(mar = c(4, 4, 1, 1), bg = \"#d1e7dd\")\n# generate sine wave\nsn.wv <- tuneR::sine(freq = 440, duration = 50, xunit = \"samples\", samp.rate = 11025)\n\nplot(x = seq(0, duration(sn.wv), length.out = length(sn.wv)), y = sn.wv@left, type = \"l\", yaxt='n', ylim = c(-1, 1), lwd = lwd, col = col, xlab = \"Time (s)\", ylab = \"Amplitude\", xaxs='i')\nabline(h = 0, lty = 2)\n\nabline(v = seq(0, duration(sn.wv), length.out = length(sn.wv))[seq(0, length(sn.wv), 10)], lwd = 0.5, lty = 2)\n\nrect(xleft=0, xright= duration(sn.wv)/ 2, ybottom=-2, ytop=2, col = adjustcolor(\"gray\", alpha.f = 0.3), border = NA)\n\n\npoints(y = sn.wv@left[seq(0, length(sn.wv), 10)], x = seq(0, duration(sn.wv), length.out = length(sn.wv))[seq(0, length(sn.wv), 10)], col = \"orange\", pch = 20, cex = 2)\n\n```\n\n \n\nAs you can see way less samples are taken per unit of time. The threshold at which samples cannot provide a reliable estimate of the regularity of a sine wave is called **Nyquist frequency** and corresponds to half of the frequency of the sine wave. This is how the 2 cycles of the 440 Hz would look like when sampled at its Nyquist frequency (sampling frequency of 880 Hz):\n\n```{r, echo = FALSE, out.width=\"100%\", fig.height= 3, warning=FALSE, message=FALSE}\n\nopar <- par()\n\npar(mar = c(4, 4, 1, 1), bg = \"#d1e7dd\")\n# generate sine wave\nsn.wv <- tuneR::sine(freq = 400, duration = 200, xunit = \"samples\", samp.rate = 40000)\nsn.wv2 <- tuneR::sine(freq = 400, duration = 4, xunit = \"samples\", samp.rate = 800)\n\nplot(x = seq(0, duration(sn.wv), length.out = length(sn.wv)), y = sn.wv@left, type = \"l\", yaxt='n', ylim = c(-1, 1), lwd = lwd, col = col, xlab = \"Time (s)\", ylab = \"Amplitude\", xaxs='i')\n\nrect(xleft=0, xright= duration(sn.wv)/ 2, ybottom=-2, ytop=2, col = adjustcolor(\"gray\", alpha.f = 0.3), border = NA)\n\nabline(h = 0, lty = 2)\n\nabline(v = seq(0, duration(sn.wv2), length.out = length(sn.wv2)), lwd = 0.5, lty = 2)\n\nsq <- seq(0, duration(sn.wv), length.out = length(sn.wv2))\nsq <- sq / max(sq)\n\npoints(y = sn.wv@left[round(sq * length(sn.wv@left))+ 1], x = seq(0, duration(sn.wv2), length.out = length(sn.wv2)), col = \"orange\", pch = 20, cex = 2)\n\n\n\n```\n\n \n\n## Quantization\n\nOnce we know at which point amplitude samples will be taken we just need to measure it. This process is called **quantization**. The range of amplitude values is discretized in a number of intervals equals to `2 ^ bits`. Hence, it involves some rounding of the actual amplitude values and some data loss. This is the same 440 Hz sine wave recorded at 44100 kHz quantized at 2 bits (2\\^2 = 4 intervals):\n\n```{r, echo = FALSE, out.width=\"100%\", fig.height= 3, warning=FALSE, message=FALSE}\n\nopar <- par()\n\nintervals <- 4\n\npar(mar = c(4, 4, 1, 1), bg = \"#d1e7dd\")\n# generate sine wave\nsn.wv <- tuneR::sine(freq = 440, duration = 200, xunit = \"samples\", samp.rate = 44100)\n\nsn.wv@left <- sn.wv@left * (intervals - 1) / 2\n\n\n\nplot(x = seq(0, duration(sn.wv), length.out = length(sn.wv)), y = sn.wv@left, type = \"l\", yaxt='n', ylim = c(-1 * (intervals ) / 2, (intervals - 1) / 2), lwd = lwd, col = col, xlab = \"Time (s)\", ylab = \"Amplitude\", xaxs='i')\n\nrect(xleft=0, xright= duration(sn.wv)/ 2, ybottom=-intervals, ytop= intervals, col = adjustcolor(\"gray\", alpha.f = 0.3), border = NA)\n\nabline(h = 0, lty = 2)\n\nabline(v = seq(0, duration(sn.wv), length.out = length(sn.wv))[seq(0, length(sn.wv), 10)], lwd = 0.5, lty = 2)\n\nquant <- as.numeric(cut(sn.wv@left, breaks = intervals)) - (1  + (intervals / 2))\n\nabline(h = unique(quant), lwd = 0.5, lty = 2)\n\npoints(y = quant[seq(0, length(sn.wv), 10)], x = seq(0, duration(sn.wv), length.out = length(sn.wv))[seq(0, length(sn.wv), 10)], col = \"orange\", pch = 20, cex = 2)\n\n```\n\n \n\nRounding and data loss is more obvious if we add lines to the sampled points:\n\n```{r, echo = FALSE, out.width=\"100%\", fig.height= 3, warning=FALSE, message=FALSE}\n\nopar <- par()\n\nintervals <- 4\n\npar(mar = c(4, 4, 1, 1), bg = \"#d1e7dd\")\n# generate sine wave\nsn.wv <- tuneR::sine(freq = 440, duration = 200, xunit = \"samples\", samp.rate = 44100)\n\nsn.wv@left <- sn.wv@left * (intervals - 1) / 2\n\nquant <- as.numeric(cut(sn.wv@left, breaks = intervals)) - (1  + (intervals / 2))\n\nplot(x = seq(0, duration(sn.wv), length.out = length(sn.wv)), y = sn.wv@left, type = \"l\", yaxt='n', ylim = c(-1 * (intervals ) / 2, (intervals - 1) / 2), lwd = 2, col = col, xlab = \"Time (s)\", ylab = \"Amplitude\", xaxs='i', lty = 2)\n\n# lines(x = seq(0, duration(sn.wv), length.out = length(sn.wv)), y = quant, type = \"l\", yaxt='n', ylim = c(-1 * (intervals - 1) / 2, (intervals - 1) / 2), lwd = lwd, col = col, xlab = \"Time (s)\", ylab = \"Amplitude\", xaxs='i')\n\nrect(xleft=0, xright= duration(sn.wv)/ 2, ybottom=-intervals, ytop= intervals, col = adjustcolor(\"gray\", alpha.f = 0.3), border = NA)\n\nabline(h = 0, lty = 2)\n\nabline(v = seq(0, duration(sn.wv), length.out = length(sn.wv))[seq(0, length(sn.wv), 10)], lwd = 0.5, lty = 2)\n\n\nabline(h = unique(quant), lwd = 0.5, lty = 2)\n\namps <- quant[seq(0, length(sn.wv), 10)]\ntimes <- seq(0, duration(sn.wv), length.out = length(sn.wv))[seq(0, length(sn.wv), 10)]\n\nfor (i in seq_along(amps)){\nlines(y = c(0, amps[i]), x = times[c(i, i)], type = \"l\", yaxt='n', ylim = c(-1 * (intervals - 1) / 2, (intervals - 1) / 2), lwd = lwd, col = adjustcolor(\"red\", alpha.f = 0.5), xlab = \"Time (s)\", ylab = \"Amplitude\", xaxs='i') \n}\n\npoints(y = quant[seq(0, length(sn.wv), 10)], x = seq(0, duration(sn.wv), length.out = length(sn.wv))[seq(0, length(sn.wv), 10)], col = \"orange\", pch = 20, cex = 2)\n\n```\n\n \n\nThis is the same signal quantized at 3 bits (2\\^3 = 8 intervals):\n\n```{r, echo = FALSE, out.width=\"100%\", fig.height= 3, warning=FALSE, message=FALSE}\n\nopar <- par()\n\nintervals <- 8\n\npar(mar = c(4, 4, 1, 1), bg = \"#d1e7dd\")\n# generate sine wave\nsn.wv <- tuneR::sine(freq = 440, duration = 200, xunit = \"samples\", samp.rate = 44100)\n\nsn.wv@left <- sn.wv@left * (intervals - 1) / 2\n\nquant <- as.numeric(cut(sn.wv@left, breaks = intervals)) - (1  + (intervals / 2))\n\nplot(x = seq(0, duration(sn.wv), length.out = length(sn.wv)), y = sn.wv@left, type = \"l\", yaxt='n', ylim = c(-1 * (intervals ) / 2, (intervals - 1) / 2), lwd = 2, col = col, xlab = \"Time (s)\", ylab = \"Amplitude\", xaxs='i', lty = 2)\n\n# lines(x = seq(0, duration(sn.wv), length.out = length(sn.wv)), y = quant, type = \"l\", yaxt='n', ylim = c(-1 * (intervals - 1) / 2, (intervals - 1) / 2), lwd = lwd, col = col, xlab = \"Time (s)\", ylab = \"Amplitude\", xaxs='i')\n\nrect(xleft=0, xright= duration(sn.wv)/ 2, ybottom=-intervals, ytop= intervals, col = adjustcolor(\"gray\", alpha.f = 0.3), border = NA)\n\nabline(h = 0, lty = 2)\n\nabline(v = seq(0, duration(sn.wv), length.out = length(sn.wv))[seq(0, length(sn.wv), 10)], lwd = 0.5, lty = 2)\n\nabline(h = unique(quant), lwd = 0.5, lty = 2)\n\namps <- quant[seq(0, length(sn.wv), 10)]\ntimes <- seq(0, duration(sn.wv), length.out = length(sn.wv))[seq(0, length(sn.wv), 10)]\n\nfor (i in seq_along(amps)){\nlines(y = c(0, amps[i]), x = times[c(i, i)], type = \"l\", yaxt='n', ylim = c(-1 * (intervals - 1) / 2, (intervals - 1) / 2), lwd = lwd, col = adjustcolor(\"red\", alpha.f = 0.5), xlab = \"Time (s)\", ylab = \"Amplitude\", xaxs='i') \n}\n\n\npoints(y = quant[seq(0, length(sn.wv), 10)], x = seq(0, duration(sn.wv), length.out = length(sn.wv))[seq(0, length(sn.wv), 10)], col = \"orange\", pch = 20, cex = 2)\n\n```\n\n \n\n4 bits (2\\^4 = 16 intervals):\n\n```{r, echo = FALSE, out.width=\"100%\", fig.height= 3, warning=FALSE, message=FALSE}\n\nopar <- par()\n\nintervals <- 2 ^ 4\n\npar(mar = c(4, 4, 1, 1), bg = \"#d1e7dd\")\n# generate sine wave\nsn.wv <- tuneR::sine(freq = 440, duration = 200, xunit = \"samples\", samp.rate = 44100)\n\nsn.wv@left <- sn.wv@left * (intervals - 1) / 2\n\nquant <- as.numeric(cut(sn.wv@left, breaks = intervals)) - (1  + (intervals / 2))\n\nplot(x = seq(0, duration(sn.wv), length.out = length(sn.wv)), y = sn.wv@left, type = \"l\", yaxt='n', ylim = c(-1 * (intervals ) / 2, (intervals - 1) / 2), lwd = 2, col = col, xlab = \"Time (s)\", ylab = \"Amplitude\", xaxs='i', lty = 2)\n\n# lines(x = seq(0, duration(sn.wv), length.out = length(sn.wv)), y = quant, type = \"l\", yaxt='n', ylim = c(-1 * (intervals - 1) / 2, (intervals - 1) / 2), lwd = lwd, col = col, xlab = \"Time (s)\", ylab = \"Amplitude\", xaxs='i')\n\namps <- quant[seq(0, length(sn.wv), 10)]\ntimes <- seq(0, duration(sn.wv), length.out = length(sn.wv))[seq(0, length(sn.wv), 10)]\n\nrect(xleft=0, xright= duration(sn.wv)/ 2, ybottom=-intervals, ytop= intervals, col = adjustcolor(\"gray\", alpha.f = 0.3), border = NA)\n\nabline(h = 0, lty = 2)\n\nabline(v = seq(0, duration(sn.wv), length.out = length(sn.wv))[seq(0, length(sn.wv), 10)], lwd = 0.5, lty = 2)\n\nabline(h = unique(quant), lwd = 0.5, lty = 2)\n\nfor (i in seq_along(amps)){\nlines(y = c(0, amps[i]), x = times[c(i, i)], type = \"l\", yaxt='n', ylim = c(-1 * (intervals - 1) / 2, (intervals - 1) / 2), lwd = lwd, col = adjustcolor(\"red\", alpha.f = 0.5), xlab = \"Time (s)\", ylab = \"Amplitude\", xaxs='i') \n}\n\n\n\npoints(y = quant[seq(0, length(sn.wv), 10)], x = seq(0, duration(sn.wv), length.out = length(sn.wv))[seq(0, length(sn.wv), 10)], col = \"orange\", pch = 20, cex = 2)\n\n\n\n```\n\n \n\n.. and 8 bits (2\\^8 = 256 intervals):\n\n```{r, echo = FALSE, out.width=\"100%\", fig.height= 3, warning=FALSE, message=FALSE}\n\nopar <- par()\n\nintervals <- 2 ^ 8\n\npar(mar = c(4, 4, 1, 1), bg = \"#d1e7dd\")\n# generate sine wave\nsn.wv <- tuneR::sine(freq = 440, duration = 200, xunit = \"samples\", samp.rate = 44100)\n\nsn.wv@left <- sn.wv@left * (intervals - 1) / 2\n\nquant <- as.numeric(cut(sn.wv@left, breaks = intervals)) - (1  + (intervals / 2))\n\nplot(x = seq(0, duration(sn.wv), length.out = length(sn.wv)), y = sn.wv@left, type = \"l\", yaxt='n', ylim = c(-1 * (intervals ) / 2, (intervals - 1) / 2), lwd = 2, col = col, xlab = \"Time (s)\", ylab = \"Amplitude\", xaxs='i', lty = 2)\n\n# lines(x = seq(0, duration(sn.wv), length.out = length(sn.wv)), y = quant, type = \"l\", yaxt='n', ylim = c(-1 * (intervals - 1) / 2, (intervals - 1) / 2), lwd = lwd, col = col, xlab = \"Time (s)\", ylab = \"Amplitude\", xaxs='i')\n\nrect(xleft=0, xright= duration(sn.wv)/ 2, ybottom=-intervals, ytop= intervals, col = adjustcolor(\"gray\", alpha.f = 0.3), border = NA)\n\nabline(h = 0, lty = 2)\n\nabline(v = seq(0, duration(sn.wv), length.out = length(sn.wv))[seq(0, length(sn.wv), 10)], lwd = 0.5, lty = 2)\n\nabline(h = unique(quant), lwd = 0.5, lty = 2)\n\namps <- quant[seq(0, length(sn.wv), 10)]\ntimes <- seq(0, duration(sn.wv), length.out = length(sn.wv))[seq(0, length(sn.wv), 10)]\n\nfor (i in seq_along(amps)){\nlines(y = c(0, amps[i]), x = times[c(i, i)], type = \"l\", yaxt='n', ylim = c(-1 * (intervals - 1) / 2, (intervals - 1) / 2), lwd = lwd, col = adjustcolor(\"red\", alpha.f = 0.5), xlab = \"Time (s)\", ylab = \"Amplitude\", xaxs='i') \n}\n\npoints(y = quant[seq(0, length(sn.wv), 10)], x = seq(0, duration(sn.wv), length.out = length(sn.wv))[seq(0, length(sn.wv), 10)], col = \"orange\", pch = 20, cex = 2)\n\n```\n\n \n\nAt this point quantization involves very little information loss. 16 bits is probably the most common dynamic range used nowadays. As you can imagine, the high number of intervals (2\\^16 = 65536) allows for great precision in the quantization of amplitude.\n:::\n\n \n\n# Sound in R\n\nSound waves can be represented by 3 kinds of R objects:\n\n-   Common classes (numerical vector, numerical matrix)\n-   Time series classes (ts, mts)\n-   Specific sound classes (Wave, sound and audioSample)\n\n \n\n## Non-specific classes\n\n### Vectors\n\nAny numerical vector can be treated as a sound if a sampling frequency is provided. For example, a 440 Hz sinusoidal sound sampled at 8000 Hz for one second can be generated like this:\n\n```{r, eval = TRUE}\n\n\nlibrary(seewave)\n\n# create sinewave at 440 Hz\ns1 <- sin(2 * pi * 440 * seq(0, 1, length.out = 8000))\n\nis.vector(s1)\n\nmode(s1)\n\n```\n\n \n\nThese sequences of values only make sense when specifying the sampling rate at which they were created:\n\n```{r, eval = TRUE}\n\noscillo(s1, f = 8000, from = 0, to = 0.01)\n\n```\n\n \n\n### Matrices\n\nYou can read any single column matrix:\n\n```{r, eval = TRUE}\n\ns2<-as.matrix(s1)\n\nis.matrix(s2)\n\ndim(s2)\n\noscillo(s2, f = 8000, from = 0, to = 0.01)\n\n```\n\n \n\nIf the matrix has more than one column, only the first column will be considered:\n\n```{r, eval = TRUE}\n\nx<-rnorm(8000)\n\ns3<-cbind(s2,x)\n\nis.matrix(s3)\n\ndim(s3)\n\noscillo(s3, f = 8000, from = 0, to = 0.01)\n\n```\n\n \n\n### Time series\n\nThe class `ts` and related functions `ts()`, `as.ts()`, `is.ts()` can also be used to generate sound objects in R. Here the command to similarly generate a series of time is shown corresponding to a 440 Hz sinusoidal sound sampled at 8000 Hz for one second:\n\n```{r, eval = TRUE}\n\ns4 <- ts(data = s1, start = 0, frequency = 8000)\n\nstr(s4)\n\n```\n\n \n\nTo generate a random noise of 0.5 seconds:\n\n```{r, eval = TRUE}\n\ns4 <- ts(data = runif(4000, min = -1, max = 1), start = 0, end = 0.5, frequency = 8000)\n\nstr(s4)\n\n```\n\n \n\nThe `frequency()` and `deltat()` functions return the sampling frequency ($f$) and the time resolution ($Delta t$) respectively:\n\n```{r, eval = TRUE}\n\nfrequency(s4)\n\ndeltat(s4)\n\n```\n\n \n\nAs the frequency is incorporated into the `ts` objects, it is not necessary to specify it when used within functions dedicated to audio:\n\n```{r, eval = TRUE}\n\noscillo(s4, from = 0, to = 0.01)\n\n```\n\n \n\nIn the case of multiple time series, **seewave** functions will consider only the first series:\n\n```{r, eval = TRUE}\n\ns5 <- ts(data = s3, f = 8000)\n\nclass(s5)\n\noscillo(s5, from = 0, to = 0.01)\n\n```\n\n## Dedicated R classes for sound\n\nThere are 3 kinds of objects corresponding to the `wav` binary format or the`mp3` compressed format:\n\n-   `Wave` class of the package **tuneR**\n-   `sound` class of the package **phonTools**\n-   `AudioSample` class of the package **audio**\n\n \n\n### `Wave` class (**tuneR**)\n\nThe `Wave` class comes with the **tuneR** package. This S4 class includes different \"slots\" with the amplitude data (left or right channel), the sampling frequency (or frequency), the number of bits (8/16/24/32) and the type of sound (mono/stereo). High sampling rates (\\> 44100 Hz) can be read on these types of objects.\n\nThe function to import `.wav` files from the hard drive is `readWave`:\n\n```{r, eval = TRUE}\n\n# load packages\nlibrary(tuneR)\n\ns6 <- readWave(\"./examples/Phae.long1.wav\")\n\n```\n\n \n\nWe can verify the class of the object like this:\n\n```{r, echo=TRUE}\n\n# object class\nclass(s6) \n\n```\n\n \n\nS4 objects have a structure similar to lists but use '\\@' to access each position (slot):\n\n```{r}\n\n# structure\nstr(s6)\n\n# extract 1 position\ns6@samp.rate \n\n```\n\n \n\n::: {.alert .alert-warning}\n\"Pulse-code modulation (PCM) is a method used to digitally represent sampled analog signals. It is the standard form of digital audio. In a PCM stream, the amplitude of the analog signal is sampled regularly at uniform intervals, and each sample is quantized to the nearest value within a range of digital steps\" ([Wikipedia](https://en.wikipedia.org/wiki/Pulse-code_modulation)).\n:::\n\n \n\nThe samples come in the slot '@left':\n\n```{r}\n\n# samples\ns6@left[1:40]\n\n```\n\n \n\nThe number of samples is given by the duration and the sampling rate.\n\n \n\n::: {.alert .alert-info}\n<font size=\"5\">Exercise</font>\n\n-   How can we calculate the duration of the `wave` object using the information in the object?\n\n \n\n-   Extract the first second of audio from the object `s6` using indexing (and squared brackets)\n:::\n\n \n\nAn advantage of using `readWave()` is the ability to read specific segments of sound files, especially useful with long files. This is done using the `from` and`to` arguments and specifying the units of time with the `units` arguments. The units can be converted into \"samples\", \"minutes\" or \"hours\". For example, to read only the section that begins in 1s and ends in 2s of the file \"Phae.long1.wav\":\n\n```{r, eval = TRUE}\n\ns7 <- readWave(\"./examples/Phae.long1.wav\", from = 1, to = 2, units = \"seconds\")\n\ns7\n\n```\n\n \n\nThe `.mp3` files can be imported to R although they are imported in`Wave` format. This is done using the `readMP3()` function:\n\n```{r, eval = TRUE}\n\ns7 <- readMP3(\"./examples/Phae.long1.mp3\")\n\ns7\n\n```\n\n \n\nTo obtain information about the object (sampling frequency, number of bits, mono/stereo), it is necessary to use the indexing of S4 class objects:\n\n```{r, eval = TRUE}\n\ns7@samp.rate\n\ns7@bit\n\ns7@stereo\n\n```\n\n \n\nA property that does not appear in these calls is that `readWave` does not normalize the sound. The values that describe the sound will be included between $\\pm2^{bit} - 1$:\n\n```{r, eval = TRUE}\n\nrange(s7@left)\n\n```\n\n \n\n::: {.alert .alert-info}\n<font size=\"5\">Exercise</font>\n\nThe function `Wave` can be used to create wave objects.\n\n \n\n-   Run the example code in the function documentation\n\n-   Plot the oscillogram for the first 0.01 s of 'Wobj'\n\n-   Note that the function `sine` provides a shortcut that can be used to create wave object with a sine wave. Check out other similar functions described in the `sine` function documentation. Try 4 of these alternative functions and plot the oscillogram of the first 0.01 s for each of them.\n:::\n\n \n\nThe function `read_sound_files` from warbleR is a wrapper over several sound file reading functions, that can read files in 'wav', 'mp3', 'flac' and 'wac' format:\n\n```{r, eval = TRUE}\n\nlibrary(warbleR)\n\n# wave\nrsf1 <- read_sound_file(\"Phaethornis-eurynome-15607.wav\", path = \"./examples\")\n\nclass(rsf1)\n\n# mp3\nrsf2 <- read_sound_file(\"Phaethornis-striigularis-154074.mp3\", path = \"./examples\")\n\nclass(rsf2)\n\n\n# flac\nrsf3 <- read_sound_file(\"Phae.long1.flac\", path = \"./examples\")\n\nclass(rsf3)\n\n# wac\nrsf4 <- read_sound_file(\"recording_20170716_230503.wac\", path = \"./examples\")\n\nclass(rsf4)\n\n```\n\n \n\nThe function can also read recordings hosted in an online repository:\n\n```{r}\n\nrsf5 <- read_sound_file(X = \"https://xeno-canto.org/35340/download\")\n\nclass(rsf5)\n\nrsf6 <- read_sound_file(X = \"https://github.com/maRce10/OTS_BIR_2024/raw/master/examples/Phae.long1.flac\")\n\nclass(rsf6)\n\n```\n\n \n\n## Class `sound` (**phonTools**)\n\nThe `loadsound()` function of *phonTools* also imports 'wave' sound files into R, in this case as objects of class `sound`:\n\n```{r, eval = TRUE}\n\nlibrary(phonTools)\n\ns8 <- loadsound(\"./examples/Phae.long1.wav\")\n\ns8\n\nstr(s8)\n\n```\n\n \n\nThis function only imports files with a dynamic range of 8 or 16 bits.\n\n \n\n## Class `audioSample` (**audio**)\n\nThe **audio** package is another option to handle `.wav` files. The sound can be imported using the `load.wave()` function. The class of the resulting object is `audioSample` which is essentially a numerical vector (for mono) or a numerical matrix with two rows (for stereo). The sampling frequency and resolution are saved as attributes:\n\n```{r, eval = TRUE}\n\nlibrary(audio)\n\ns10 <- load.wave(\"./examples/Phae.long1.wav\")\n\nhead(s10)\n\ns10$rate\n\ns10$bits\n\n```\n\n \n\nThe main advantage of the **audio** package is that the sound can be acquired directly within an R session. This is achieved first by preparing a `NAs` vector and then using the`record()` function. For example, to obtain a mono sound of 5 seconds sampled at 16 kHz:\n\n```{r, eval = FALSE}\n\ns11 <- rep(NA_real_, 16000*5)\n\nrecord(s11, 16000, 1)\n\n```\n\n \n\nA recording session can be controlled by three complementary functions: `pause()`, `rewind()`, and `resume()`.\n\n \n\n## Export sounds from R\n\nFor maximum compatibility with other sound programs, it may be useful to save a sound as a simple `.txt` file. The following commands will write a \"tico.txt\" file:\n\n```{r, eval = TRUE}\n\ndata(tico)\n\nexport(tico, f=22050)\n\n```\n\n \n\n## Format '.wav'\n\n**tuneR** and **audio** have a function to write `.wav` files: `writeWave()` and `save.wave()` respectively. Within **seewave**, the `savewav()` function, which is based on `writeWave()`, can be used to save data in `.wav` format. By default, the object name will be used for the name of the `.wav` file:\n\n```{r, eval = FALSE}\n\nsavewav(tico)\n\n```\n\n \n\n## Format '.flac'\n\nFree Lossless Audio Codec (FLAC) is a file format for lossless audio data compression. FLAC reduces bandwidth and storage requirements without sacrificing the integrity of the audio source. Audio sources encoded in FLAC are generally reduced in size from 40 to 50 percent. See the flac website for more details ([flac.sourceforge.net](http://flac.sourceforge.net)).\n\nThe `.flac` format cannot be used as such with R. However, the `wav2flac()`function allows you to call the FLAC software directly from the console. Therefore, FLAC must be installed on your operating system. If you have a `.wav` file that you want to compress in `.flac`, call:\n\n```{r, eval = FALSE}\n\nwav2flac(file = \"./examples/Phae.long1.wav\", overwrite = FALSE)\n\n```\n\n \n\nTo compress a `.wav` file to a `.flac` format, the argument `reverse = TRUE` must be used:\n\n```{r, eval = FALSE}\n\nwav2flac(\"Phae.long1.flac\", reverse = TRUE)\n\n```\n\n \n\nThis table, taken from Sueur (2018), summarizes the functions available to import and export sound files in R. The table is incomplete since it does not mention the functions of the `phonTools` package:\n\n<img src=\"images/tabla-waves.png\" alt=\"tabla imp exp waves\" width=\"700\"/>\n\n------------------------------------------------------------------------\n\n \n\n::: {.alert .alert-info}\n<font size=\"5\">Exercise</font>\n\n-   How does the sampling rate affect the size of an audio file? (hint: create 2 sounds files with the same data but different sampling rates; use `sine()`)\n\n-   How does the dynamic range affect the size of an audio file?\n\n-   Use the `system.time()` function to compare the performance of the different functions to import audio files in R. For this use the file \"LBH.374.SUR.wav\" (Long-billed hermit songs) which lasts about 2 min\n\nThe following code creates a plot similar to `oscillo` but using dots instead of lines:\n\n```{r, eval = FALSE}\n\n# generate sine wave\nwav <- sine(freq = 440, duration = 500, \n            xunit = \"samples\", samp.rate = 44100)\n\n# plot\nplot(wav@left) \n\n```\n\n```{r, echo = FALSE}\n\n# generate sine wave\nwav <- sine(freq = 440, duration = 500, \n            xunit = \"samples\", samp.rate = 44100)\n\npar(bg = \"#cff4fc\", mar = c(5, 4, 1, 0) + 0.1)\n\n# plot\nplot(wav@left) \n```\n\n \n\n-   Use the function `downsample()` to reduce the sampling rate of 'wav' (below 44100) and plot the output object. Decrease the sampling rate until you cannot recognize the wave pattern from the original wave object. Try several values so you get a sense at which sampling rate this happens.\n\n```{r, eval =  FALSE, echo = FALSE}\n\ndown_wav <- downsample(object = wav, samp.rate = 2756)\n\n# plot\nplot(down_wav@left) \n\n```\n:::\n\n \n\n------------------------------------------------------------------------\n\n## References\n\n1.  Sueur J, Aubin T, Simonis C. 2008. Equipment review: seewave, a free modular tool for sound analysis and synthesis. Bioacoustics 18(2):213--226.\n\n2.  Sueur, J. (2018). Sound Analysis and Synthesis with R.\n\n3.  Sueur J. (2018). I/O of sound with R. seewave package vignette. url: https://cran.r-project.org/web/packages/seewave/vignettes/seewave_IO.pdf\n\n------------------------------------------------------------------------\n\n<font size=\"4\">Session information</font>\n\n```{r session info, echo=F}\n\nsessionInfo()\n\n```\n","srcMarkdownNoYaml":"\n\n \n\n::: {.alert .alert-info}\n## **Objetives** {.unnumbered .unlisted}\n\n-   Learn the basic aspects of sound as a physical phenomenom\n\n-   Get familiar with how sound is represented as a digital object in R\n:::\n\n \n\n```{r, echo = FALSE}\n\nlibrary(seewave)\nlibrary(knitr)\nopts_chunk$set(tidy = TRUE, warning = FALSE, message = FALSE)\n\n```\n\n \n\nSound waves are characterized by compression and expansion of the medium as sound energy moves through it. There is also back and forth motion of the particles making up the medium:\n\n<img src=\"images/wave_white_bg.gif\" alt=\"wave animation\" width=\"700\"/>\n\n<font size=\"3\"> taken from https://dosits.org</font>\n\n \n\nThe variation in pressure that is perceived at a fixed point in space can be represented by a graph of pressure (amplitude) by time:\n\n![wave and oscillogram](images/amplitude.gif){width=\"600\" height=\"350\"}\n\n \n\nSounds waves are typically quantified by their frequency (number of cycles per second, Hz) and amplitude (relative intensity).\n\n```{r, echo = FALSE, out.width=\"85%\", warning=FALSE, message=FALSE}\n\nopar <- par()\nx <- c(0, 0.1, 0.55, 1)\ny <- c(0, 0.4, 0.8, 1)\n\nlwd <-4\ncol <- viridis::viridis(10)[3]\nmat <- matrix(c(\n  c(x[1], x[2], y[1], y[4]), # 1 left amptliude panel\n  c(x[1], x[4], y[3], y[4]), # 2 upper freq panel\n  c(x[2], x[3], y[2], y[3]), # 3 left upper oscillo\n  c(x[3], x[4], y[2], y[3]), # 4 right upper oscillo\n  c(x[2], x[3], y[1], y[2]), # 5 left lower oscillo\n  c(x[3], x[4], y[1], y[2]) # 6 left upper oscillo\n),  ncol = 4, byrow = TRUE\n)\n\na <- split.screen(figs = mat)\n\nscreen(1)\n\npar(mar = c(0, 0, 0, 0), bg = \"white\", new = T)\nplot(1, frame.plot = FALSE, type = \"n\", xaxt='n', yaxt='n')\ntext(x = 0.8, y = 0.98, \"Frequency\", srt = 90,  cex = 2)\ntext(x = 1.2, y = 1.2, \"High\", srt = 90,  cex = 1.2)\ntext(x = 1.2, y = 0.8, \"Low\", srt = 90,  cex = 1.2)\n\n\nscreen(2)\n\npar(mar = c(0, 0, 0, 0), bg = \"white\", new = T)\nplot(1, frame.plot = FALSE, type = \"n\", xaxt='n', yaxt='n')\ntext(x = 1.04, y = 1.1, \"Amplitude\",  cex = 2)\ntext(x = 0.8, y = 0.8, \"Low\", cex = 1.2)\ntext(x = 1.2, y = 0.8, \"High\", cex = 1.2)\n\n# generate sine wave\nhigh.freq <- tuneR::sine(freq = 440, duration = 500, xunit = \"samples\", samp.rate = 44100)\nlow.freq <- tuneR::sine(freq = 220, duration = 500, xunit = \"samples\", samp.rate = 44100)\n\nscreen(3)\npar(mar = rep(0, 4))\n\n# plot\nplot(high.freq@left / 2, type = \"l\", xaxt='n', yaxt='n', ylim = c(-1, 1), lwd = lwd, col = col) \nabline(h = 0, lty = 2)\n\nscreen(4)\npar(mar = rep(0, 4))\nplot(high.freq@left, type = \"l\", xaxt='n', yaxt='n', ylim = c(-1, 1), lwd = lwd, col = col)\nabline(h = 0, lty = 2)\n\n# \nscreen(5)\npar(mar = rep(0, 4))\nplot(low.freq@left / 2, type = \"l\", xaxt='n', yaxt='n', ylim = c(-1, 1), lwd = lwd, col = col)\nabline(h = 0, lty = 2)\n\nscreen(6)\npar(mar = rep(0, 4))\nplot(low.freq@left, type = \"l\", xaxt='n', ann=FALSE, yaxt='n', ylim = c(-1, 1), lwd = lwd, col = col)\nabline(h = 0, lty = 2)\n \nclose.screen(all.screens = TRUE)\n\npar(opar)\n# dev.off()\n\n\n```\n\n \n\n::: {.alert .alert-success}\n<font size=\"6\"><b>Digitizing sound</b></font>\n\n \n\n## Sampling frequency\n\nDigitizing implies discretizing, which requires some sort of regular sampling. Sampling frequency refers to how many samples of the pressure level of the environment are taken per second. A 440 Hz sine wave recorded at 44100 Hz would have around 100 samples per cycle. This plot shows 2 cycles of a 440 Hz sine wave sampled (vertical dotted lines) at 4410 Hz (a 1/10 of the recording sampling rate):\n\n```{r, echo = FALSE, out.width=\"100%\", fig.height= 3, warning=FALSE, message=FALSE}\n\nopar <- par()\n\npar(mar = c(4, 4, 1, 1), bg = \"#d1e7dd\")\n# generate sine wave\nsn.wv <- tuneR::sine(freq = 440, duration = 200, xunit = \"samples\", samp.rate = 44100)\n\nplot(x = seq(0, duration(sn.wv), length.out = length(sn.wv)), y = sn.wv@left, type = \"l\", yaxt='n', ylim = c(-1, 1), lwd = lwd, col = col, xlab = \"Time (s)\", ylab = \"Amplitude\", xaxs='i')\n\nrect(xleft=0, xright= duration(sn.wv)/ 2, ybottom=-2, ytop=2, col = adjustcolor(\"gray\", alpha.f = 0.3), border = NA)\n\nabline(h = 0, lty = 2)\n\nabline(v = seq(0, duration(sn.wv), length.out = length(sn.wv))[seq(0, length(sn.wv), 10)], lwd = 0.5, lty = 2)\n\n\npoints(y = sn.wv@left[seq(0, length(sn.wv), 10)], x = seq(0, duration(sn.wv), length.out = length(sn.wv))[seq(0, length(sn.wv), 10)], col = \"orange\", pch = 20, cex = 2)\n\n\n```\n\n## Nyquist frequency\n\nSampling should be good enough so the regularity of the sine wave can be reconstructed from the sampled data. Low sampling frequencies of a high frequency sine wave might not be able to provide enough information. For instance, the same 440 Hz sine wave sampled at 22050 Hz looks like this:\n\n```{r, echo = FALSE, out.width=\"100%\", fig.height= 3, warning=FALSE, message=FALSE}\n\n\npar(mar = c(4, 4, 1, 1), bg = \"#d1e7dd\")\n# generate sine wave\nsn.wv <- tuneR::sine(freq = 440, duration = 50, xunit = \"samples\", samp.rate = 11025)\n\nplot(x = seq(0, duration(sn.wv), length.out = length(sn.wv)), y = sn.wv@left, type = \"l\", yaxt='n', ylim = c(-1, 1), lwd = lwd, col = col, xlab = \"Time (s)\", ylab = \"Amplitude\", xaxs='i')\nabline(h = 0, lty = 2)\n\nabline(v = seq(0, duration(sn.wv), length.out = length(sn.wv))[seq(0, length(sn.wv), 10)], lwd = 0.5, lty = 2)\n\nrect(xleft=0, xright= duration(sn.wv)/ 2, ybottom=-2, ytop=2, col = adjustcolor(\"gray\", alpha.f = 0.3), border = NA)\n\n\npoints(y = sn.wv@left[seq(0, length(sn.wv), 10)], x = seq(0, duration(sn.wv), length.out = length(sn.wv))[seq(0, length(sn.wv), 10)], col = \"orange\", pch = 20, cex = 2)\n\n```\n\n \n\nAs you can see way less samples are taken per unit of time. The threshold at which samples cannot provide a reliable estimate of the regularity of a sine wave is called **Nyquist frequency** and corresponds to half of the frequency of the sine wave. This is how the 2 cycles of the 440 Hz would look like when sampled at its Nyquist frequency (sampling frequency of 880 Hz):\n\n```{r, echo = FALSE, out.width=\"100%\", fig.height= 3, warning=FALSE, message=FALSE}\n\nopar <- par()\n\npar(mar = c(4, 4, 1, 1), bg = \"#d1e7dd\")\n# generate sine wave\nsn.wv <- tuneR::sine(freq = 400, duration = 200, xunit = \"samples\", samp.rate = 40000)\nsn.wv2 <- tuneR::sine(freq = 400, duration = 4, xunit = \"samples\", samp.rate = 800)\n\nplot(x = seq(0, duration(sn.wv), length.out = length(sn.wv)), y = sn.wv@left, type = \"l\", yaxt='n', ylim = c(-1, 1), lwd = lwd, col = col, xlab = \"Time (s)\", ylab = \"Amplitude\", xaxs='i')\n\nrect(xleft=0, xright= duration(sn.wv)/ 2, ybottom=-2, ytop=2, col = adjustcolor(\"gray\", alpha.f = 0.3), border = NA)\n\nabline(h = 0, lty = 2)\n\nabline(v = seq(0, duration(sn.wv2), length.out = length(sn.wv2)), lwd = 0.5, lty = 2)\n\nsq <- seq(0, duration(sn.wv), length.out = length(sn.wv2))\nsq <- sq / max(sq)\n\npoints(y = sn.wv@left[round(sq * length(sn.wv@left))+ 1], x = seq(0, duration(sn.wv2), length.out = length(sn.wv2)), col = \"orange\", pch = 20, cex = 2)\n\n\n\n```\n\n \n\n## Quantization\n\nOnce we know at which point amplitude samples will be taken we just need to measure it. This process is called **quantization**. The range of amplitude values is discretized in a number of intervals equals to `2 ^ bits`. Hence, it involves some rounding of the actual amplitude values and some data loss. This is the same 440 Hz sine wave recorded at 44100 kHz quantized at 2 bits (2\\^2 = 4 intervals):\n\n```{r, echo = FALSE, out.width=\"100%\", fig.height= 3, warning=FALSE, message=FALSE}\n\nopar <- par()\n\nintervals <- 4\n\npar(mar = c(4, 4, 1, 1), bg = \"#d1e7dd\")\n# generate sine wave\nsn.wv <- tuneR::sine(freq = 440, duration = 200, xunit = \"samples\", samp.rate = 44100)\n\nsn.wv@left <- sn.wv@left * (intervals - 1) / 2\n\n\n\nplot(x = seq(0, duration(sn.wv), length.out = length(sn.wv)), y = sn.wv@left, type = \"l\", yaxt='n', ylim = c(-1 * (intervals ) / 2, (intervals - 1) / 2), lwd = lwd, col = col, xlab = \"Time (s)\", ylab = \"Amplitude\", xaxs='i')\n\nrect(xleft=0, xright= duration(sn.wv)/ 2, ybottom=-intervals, ytop= intervals, col = adjustcolor(\"gray\", alpha.f = 0.3), border = NA)\n\nabline(h = 0, lty = 2)\n\nabline(v = seq(0, duration(sn.wv), length.out = length(sn.wv))[seq(0, length(sn.wv), 10)], lwd = 0.5, lty = 2)\n\nquant <- as.numeric(cut(sn.wv@left, breaks = intervals)) - (1  + (intervals / 2))\n\nabline(h = unique(quant), lwd = 0.5, lty = 2)\n\npoints(y = quant[seq(0, length(sn.wv), 10)], x = seq(0, duration(sn.wv), length.out = length(sn.wv))[seq(0, length(sn.wv), 10)], col = \"orange\", pch = 20, cex = 2)\n\n```\n\n \n\nRounding and data loss is more obvious if we add lines to the sampled points:\n\n```{r, echo = FALSE, out.width=\"100%\", fig.height= 3, warning=FALSE, message=FALSE}\n\nopar <- par()\n\nintervals <- 4\n\npar(mar = c(4, 4, 1, 1), bg = \"#d1e7dd\")\n# generate sine wave\nsn.wv <- tuneR::sine(freq = 440, duration = 200, xunit = \"samples\", samp.rate = 44100)\n\nsn.wv@left <- sn.wv@left * (intervals - 1) / 2\n\nquant <- as.numeric(cut(sn.wv@left, breaks = intervals)) - (1  + (intervals / 2))\n\nplot(x = seq(0, duration(sn.wv), length.out = length(sn.wv)), y = sn.wv@left, type = \"l\", yaxt='n', ylim = c(-1 * (intervals ) / 2, (intervals - 1) / 2), lwd = 2, col = col, xlab = \"Time (s)\", ylab = \"Amplitude\", xaxs='i', lty = 2)\n\n# lines(x = seq(0, duration(sn.wv), length.out = length(sn.wv)), y = quant, type = \"l\", yaxt='n', ylim = c(-1 * (intervals - 1) / 2, (intervals - 1) / 2), lwd = lwd, col = col, xlab = \"Time (s)\", ylab = \"Amplitude\", xaxs='i')\n\nrect(xleft=0, xright= duration(sn.wv)/ 2, ybottom=-intervals, ytop= intervals, col = adjustcolor(\"gray\", alpha.f = 0.3), border = NA)\n\nabline(h = 0, lty = 2)\n\nabline(v = seq(0, duration(sn.wv), length.out = length(sn.wv))[seq(0, length(sn.wv), 10)], lwd = 0.5, lty = 2)\n\n\nabline(h = unique(quant), lwd = 0.5, lty = 2)\n\namps <- quant[seq(0, length(sn.wv), 10)]\ntimes <- seq(0, duration(sn.wv), length.out = length(sn.wv))[seq(0, length(sn.wv), 10)]\n\nfor (i in seq_along(amps)){\nlines(y = c(0, amps[i]), x = times[c(i, i)], type = \"l\", yaxt='n', ylim = c(-1 * (intervals - 1) / 2, (intervals - 1) / 2), lwd = lwd, col = adjustcolor(\"red\", alpha.f = 0.5), xlab = \"Time (s)\", ylab = \"Amplitude\", xaxs='i') \n}\n\npoints(y = quant[seq(0, length(sn.wv), 10)], x = seq(0, duration(sn.wv), length.out = length(sn.wv))[seq(0, length(sn.wv), 10)], col = \"orange\", pch = 20, cex = 2)\n\n```\n\n \n\nThis is the same signal quantized at 3 bits (2\\^3 = 8 intervals):\n\n```{r, echo = FALSE, out.width=\"100%\", fig.height= 3, warning=FALSE, message=FALSE}\n\nopar <- par()\n\nintervals <- 8\n\npar(mar = c(4, 4, 1, 1), bg = \"#d1e7dd\")\n# generate sine wave\nsn.wv <- tuneR::sine(freq = 440, duration = 200, xunit = \"samples\", samp.rate = 44100)\n\nsn.wv@left <- sn.wv@left * (intervals - 1) / 2\n\nquant <- as.numeric(cut(sn.wv@left, breaks = intervals)) - (1  + (intervals / 2))\n\nplot(x = seq(0, duration(sn.wv), length.out = length(sn.wv)), y = sn.wv@left, type = \"l\", yaxt='n', ylim = c(-1 * (intervals ) / 2, (intervals - 1) / 2), lwd = 2, col = col, xlab = \"Time (s)\", ylab = \"Amplitude\", xaxs='i', lty = 2)\n\n# lines(x = seq(0, duration(sn.wv), length.out = length(sn.wv)), y = quant, type = \"l\", yaxt='n', ylim = c(-1 * (intervals - 1) / 2, (intervals - 1) / 2), lwd = lwd, col = col, xlab = \"Time (s)\", ylab = \"Amplitude\", xaxs='i')\n\nrect(xleft=0, xright= duration(sn.wv)/ 2, ybottom=-intervals, ytop= intervals, col = adjustcolor(\"gray\", alpha.f = 0.3), border = NA)\n\nabline(h = 0, lty = 2)\n\nabline(v = seq(0, duration(sn.wv), length.out = length(sn.wv))[seq(0, length(sn.wv), 10)], lwd = 0.5, lty = 2)\n\nabline(h = unique(quant), lwd = 0.5, lty = 2)\n\namps <- quant[seq(0, length(sn.wv), 10)]\ntimes <- seq(0, duration(sn.wv), length.out = length(sn.wv))[seq(0, length(sn.wv), 10)]\n\nfor (i in seq_along(amps)){\nlines(y = c(0, amps[i]), x = times[c(i, i)], type = \"l\", yaxt='n', ylim = c(-1 * (intervals - 1) / 2, (intervals - 1) / 2), lwd = lwd, col = adjustcolor(\"red\", alpha.f = 0.5), xlab = \"Time (s)\", ylab = \"Amplitude\", xaxs='i') \n}\n\n\npoints(y = quant[seq(0, length(sn.wv), 10)], x = seq(0, duration(sn.wv), length.out = length(sn.wv))[seq(0, length(sn.wv), 10)], col = \"orange\", pch = 20, cex = 2)\n\n```\n\n \n\n4 bits (2\\^4 = 16 intervals):\n\n```{r, echo = FALSE, out.width=\"100%\", fig.height= 3, warning=FALSE, message=FALSE}\n\nopar <- par()\n\nintervals <- 2 ^ 4\n\npar(mar = c(4, 4, 1, 1), bg = \"#d1e7dd\")\n# generate sine wave\nsn.wv <- tuneR::sine(freq = 440, duration = 200, xunit = \"samples\", samp.rate = 44100)\n\nsn.wv@left <- sn.wv@left * (intervals - 1) / 2\n\nquant <- as.numeric(cut(sn.wv@left, breaks = intervals)) - (1  + (intervals / 2))\n\nplot(x = seq(0, duration(sn.wv), length.out = length(sn.wv)), y = sn.wv@left, type = \"l\", yaxt='n', ylim = c(-1 * (intervals ) / 2, (intervals - 1) / 2), lwd = 2, col = col, xlab = \"Time (s)\", ylab = \"Amplitude\", xaxs='i', lty = 2)\n\n# lines(x = seq(0, duration(sn.wv), length.out = length(sn.wv)), y = quant, type = \"l\", yaxt='n', ylim = c(-1 * (intervals - 1) / 2, (intervals - 1) / 2), lwd = lwd, col = col, xlab = \"Time (s)\", ylab = \"Amplitude\", xaxs='i')\n\namps <- quant[seq(0, length(sn.wv), 10)]\ntimes <- seq(0, duration(sn.wv), length.out = length(sn.wv))[seq(0, length(sn.wv), 10)]\n\nrect(xleft=0, xright= duration(sn.wv)/ 2, ybottom=-intervals, ytop= intervals, col = adjustcolor(\"gray\", alpha.f = 0.3), border = NA)\n\nabline(h = 0, lty = 2)\n\nabline(v = seq(0, duration(sn.wv), length.out = length(sn.wv))[seq(0, length(sn.wv), 10)], lwd = 0.5, lty = 2)\n\nabline(h = unique(quant), lwd = 0.5, lty = 2)\n\nfor (i in seq_along(amps)){\nlines(y = c(0, amps[i]), x = times[c(i, i)], type = \"l\", yaxt='n', ylim = c(-1 * (intervals - 1) / 2, (intervals - 1) / 2), lwd = lwd, col = adjustcolor(\"red\", alpha.f = 0.5), xlab = \"Time (s)\", ylab = \"Amplitude\", xaxs='i') \n}\n\n\n\npoints(y = quant[seq(0, length(sn.wv), 10)], x = seq(0, duration(sn.wv), length.out = length(sn.wv))[seq(0, length(sn.wv), 10)], col = \"orange\", pch = 20, cex = 2)\n\n\n\n```\n\n \n\n.. and 8 bits (2\\^8 = 256 intervals):\n\n```{r, echo = FALSE, out.width=\"100%\", fig.height= 3, warning=FALSE, message=FALSE}\n\nopar <- par()\n\nintervals <- 2 ^ 8\n\npar(mar = c(4, 4, 1, 1), bg = \"#d1e7dd\")\n# generate sine wave\nsn.wv <- tuneR::sine(freq = 440, duration = 200, xunit = \"samples\", samp.rate = 44100)\n\nsn.wv@left <- sn.wv@left * (intervals - 1) / 2\n\nquant <- as.numeric(cut(sn.wv@left, breaks = intervals)) - (1  + (intervals / 2))\n\nplot(x = seq(0, duration(sn.wv), length.out = length(sn.wv)), y = sn.wv@left, type = \"l\", yaxt='n', ylim = c(-1 * (intervals ) / 2, (intervals - 1) / 2), lwd = 2, col = col, xlab = \"Time (s)\", ylab = \"Amplitude\", xaxs='i', lty = 2)\n\n# lines(x = seq(0, duration(sn.wv), length.out = length(sn.wv)), y = quant, type = \"l\", yaxt='n', ylim = c(-1 * (intervals - 1) / 2, (intervals - 1) / 2), lwd = lwd, col = col, xlab = \"Time (s)\", ylab = \"Amplitude\", xaxs='i')\n\nrect(xleft=0, xright= duration(sn.wv)/ 2, ybottom=-intervals, ytop= intervals, col = adjustcolor(\"gray\", alpha.f = 0.3), border = NA)\n\nabline(h = 0, lty = 2)\n\nabline(v = seq(0, duration(sn.wv), length.out = length(sn.wv))[seq(0, length(sn.wv), 10)], lwd = 0.5, lty = 2)\n\nabline(h = unique(quant), lwd = 0.5, lty = 2)\n\namps <- quant[seq(0, length(sn.wv), 10)]\ntimes <- seq(0, duration(sn.wv), length.out = length(sn.wv))[seq(0, length(sn.wv), 10)]\n\nfor (i in seq_along(amps)){\nlines(y = c(0, amps[i]), x = times[c(i, i)], type = \"l\", yaxt='n', ylim = c(-1 * (intervals - 1) / 2, (intervals - 1) / 2), lwd = lwd, col = adjustcolor(\"red\", alpha.f = 0.5), xlab = \"Time (s)\", ylab = \"Amplitude\", xaxs='i') \n}\n\npoints(y = quant[seq(0, length(sn.wv), 10)], x = seq(0, duration(sn.wv), length.out = length(sn.wv))[seq(0, length(sn.wv), 10)], col = \"orange\", pch = 20, cex = 2)\n\n```\n\n \n\nAt this point quantization involves very little information loss. 16 bits is probably the most common dynamic range used nowadays. As you can imagine, the high number of intervals (2\\^16 = 65536) allows for great precision in the quantization of amplitude.\n:::\n\n \n\n# Sound in R\n\nSound waves can be represented by 3 kinds of R objects:\n\n-   Common classes (numerical vector, numerical matrix)\n-   Time series classes (ts, mts)\n-   Specific sound classes (Wave, sound and audioSample)\n\n \n\n## Non-specific classes\n\n### Vectors\n\nAny numerical vector can be treated as a sound if a sampling frequency is provided. For example, a 440 Hz sinusoidal sound sampled at 8000 Hz for one second can be generated like this:\n\n```{r, eval = TRUE}\n\n\nlibrary(seewave)\n\n# create sinewave at 440 Hz\ns1 <- sin(2 * pi * 440 * seq(0, 1, length.out = 8000))\n\nis.vector(s1)\n\nmode(s1)\n\n```\n\n \n\nThese sequences of values only make sense when specifying the sampling rate at which they were created:\n\n```{r, eval = TRUE}\n\noscillo(s1, f = 8000, from = 0, to = 0.01)\n\n```\n\n \n\n### Matrices\n\nYou can read any single column matrix:\n\n```{r, eval = TRUE}\n\ns2<-as.matrix(s1)\n\nis.matrix(s2)\n\ndim(s2)\n\noscillo(s2, f = 8000, from = 0, to = 0.01)\n\n```\n\n \n\nIf the matrix has more than one column, only the first column will be considered:\n\n```{r, eval = TRUE}\n\nx<-rnorm(8000)\n\ns3<-cbind(s2,x)\n\nis.matrix(s3)\n\ndim(s3)\n\noscillo(s3, f = 8000, from = 0, to = 0.01)\n\n```\n\n \n\n### Time series\n\nThe class `ts` and related functions `ts()`, `as.ts()`, `is.ts()` can also be used to generate sound objects in R. Here the command to similarly generate a series of time is shown corresponding to a 440 Hz sinusoidal sound sampled at 8000 Hz for one second:\n\n```{r, eval = TRUE}\n\ns4 <- ts(data = s1, start = 0, frequency = 8000)\n\nstr(s4)\n\n```\n\n \n\nTo generate a random noise of 0.5 seconds:\n\n```{r, eval = TRUE}\n\ns4 <- ts(data = runif(4000, min = -1, max = 1), start = 0, end = 0.5, frequency = 8000)\n\nstr(s4)\n\n```\n\n \n\nThe `frequency()` and `deltat()` functions return the sampling frequency ($f$) and the time resolution ($Delta t$) respectively:\n\n```{r, eval = TRUE}\n\nfrequency(s4)\n\ndeltat(s4)\n\n```\n\n \n\nAs the frequency is incorporated into the `ts` objects, it is not necessary to specify it when used within functions dedicated to audio:\n\n```{r, eval = TRUE}\n\noscillo(s4, from = 0, to = 0.01)\n\n```\n\n \n\nIn the case of multiple time series, **seewave** functions will consider only the first series:\n\n```{r, eval = TRUE}\n\ns5 <- ts(data = s3, f = 8000)\n\nclass(s5)\n\noscillo(s5, from = 0, to = 0.01)\n\n```\n\n## Dedicated R classes for sound\n\nThere are 3 kinds of objects corresponding to the `wav` binary format or the`mp3` compressed format:\n\n-   `Wave` class of the package **tuneR**\n-   `sound` class of the package **phonTools**\n-   `AudioSample` class of the package **audio**\n\n \n\n### `Wave` class (**tuneR**)\n\nThe `Wave` class comes with the **tuneR** package. This S4 class includes different \"slots\" with the amplitude data (left or right channel), the sampling frequency (or frequency), the number of bits (8/16/24/32) and the type of sound (mono/stereo). High sampling rates (\\> 44100 Hz) can be read on these types of objects.\n\nThe function to import `.wav` files from the hard drive is `readWave`:\n\n```{r, eval = TRUE}\n\n# load packages\nlibrary(tuneR)\n\ns6 <- readWave(\"./examples/Phae.long1.wav\")\n\n```\n\n \n\nWe can verify the class of the object like this:\n\n```{r, echo=TRUE}\n\n# object class\nclass(s6) \n\n```\n\n \n\nS4 objects have a structure similar to lists but use '\\@' to access each position (slot):\n\n```{r}\n\n# structure\nstr(s6)\n\n# extract 1 position\ns6@samp.rate \n\n```\n\n \n\n::: {.alert .alert-warning}\n\"Pulse-code modulation (PCM) is a method used to digitally represent sampled analog signals. It is the standard form of digital audio. In a PCM stream, the amplitude of the analog signal is sampled regularly at uniform intervals, and each sample is quantized to the nearest value within a range of digital steps\" ([Wikipedia](https://en.wikipedia.org/wiki/Pulse-code_modulation)).\n:::\n\n \n\nThe samples come in the slot '@left':\n\n```{r}\n\n# samples\ns6@left[1:40]\n\n```\n\n \n\nThe number of samples is given by the duration and the sampling rate.\n\n \n\n::: {.alert .alert-info}\n<font size=\"5\">Exercise</font>\n\n-   How can we calculate the duration of the `wave` object using the information in the object?\n\n \n\n-   Extract the first second of audio from the object `s6` using indexing (and squared brackets)\n:::\n\n \n\nAn advantage of using `readWave()` is the ability to read specific segments of sound files, especially useful with long files. This is done using the `from` and`to` arguments and specifying the units of time with the `units` arguments. The units can be converted into \"samples\", \"minutes\" or \"hours\". For example, to read only the section that begins in 1s and ends in 2s of the file \"Phae.long1.wav\":\n\n```{r, eval = TRUE}\n\ns7 <- readWave(\"./examples/Phae.long1.wav\", from = 1, to = 2, units = \"seconds\")\n\ns7\n\n```\n\n \n\nThe `.mp3` files can be imported to R although they are imported in`Wave` format. This is done using the `readMP3()` function:\n\n```{r, eval = TRUE}\n\ns7 <- readMP3(\"./examples/Phae.long1.mp3\")\n\ns7\n\n```\n\n \n\nTo obtain information about the object (sampling frequency, number of bits, mono/stereo), it is necessary to use the indexing of S4 class objects:\n\n```{r, eval = TRUE}\n\ns7@samp.rate\n\ns7@bit\n\ns7@stereo\n\n```\n\n \n\nA property that does not appear in these calls is that `readWave` does not normalize the sound. The values that describe the sound will be included between $\\pm2^{bit} - 1$:\n\n```{r, eval = TRUE}\n\nrange(s7@left)\n\n```\n\n \n\n::: {.alert .alert-info}\n<font size=\"5\">Exercise</font>\n\nThe function `Wave` can be used to create wave objects.\n\n \n\n-   Run the example code in the function documentation\n\n-   Plot the oscillogram for the first 0.01 s of 'Wobj'\n\n-   Note that the function `sine` provides a shortcut that can be used to create wave object with a sine wave. Check out other similar functions described in the `sine` function documentation. Try 4 of these alternative functions and plot the oscillogram of the first 0.01 s for each of them.\n:::\n\n \n\nThe function `read_sound_files` from warbleR is a wrapper over several sound file reading functions, that can read files in 'wav', 'mp3', 'flac' and 'wac' format:\n\n```{r, eval = TRUE}\n\nlibrary(warbleR)\n\n# wave\nrsf1 <- read_sound_file(\"Phaethornis-eurynome-15607.wav\", path = \"./examples\")\n\nclass(rsf1)\n\n# mp3\nrsf2 <- read_sound_file(\"Phaethornis-striigularis-154074.mp3\", path = \"./examples\")\n\nclass(rsf2)\n\n\n# flac\nrsf3 <- read_sound_file(\"Phae.long1.flac\", path = \"./examples\")\n\nclass(rsf3)\n\n# wac\nrsf4 <- read_sound_file(\"recording_20170716_230503.wac\", path = \"./examples\")\n\nclass(rsf4)\n\n```\n\n \n\nThe function can also read recordings hosted in an online repository:\n\n```{r}\n\nrsf5 <- read_sound_file(X = \"https://xeno-canto.org/35340/download\")\n\nclass(rsf5)\n\nrsf6 <- read_sound_file(X = \"https://github.com/maRce10/OTS_BIR_2024/raw/master/examples/Phae.long1.flac\")\n\nclass(rsf6)\n\n```\n\n \n\n## Class `sound` (**phonTools**)\n\nThe `loadsound()` function of *phonTools* also imports 'wave' sound files into R, in this case as objects of class `sound`:\n\n```{r, eval = TRUE}\n\nlibrary(phonTools)\n\ns8 <- loadsound(\"./examples/Phae.long1.wav\")\n\ns8\n\nstr(s8)\n\n```\n\n \n\nThis function only imports files with a dynamic range of 8 or 16 bits.\n\n \n\n## Class `audioSample` (**audio**)\n\nThe **audio** package is another option to handle `.wav` files. The sound can be imported using the `load.wave()` function. The class of the resulting object is `audioSample` which is essentially a numerical vector (for mono) or a numerical matrix with two rows (for stereo). The sampling frequency and resolution are saved as attributes:\n\n```{r, eval = TRUE}\n\nlibrary(audio)\n\ns10 <- load.wave(\"./examples/Phae.long1.wav\")\n\nhead(s10)\n\ns10$rate\n\ns10$bits\n\n```\n\n \n\nThe main advantage of the **audio** package is that the sound can be acquired directly within an R session. This is achieved first by preparing a `NAs` vector and then using the`record()` function. For example, to obtain a mono sound of 5 seconds sampled at 16 kHz:\n\n```{r, eval = FALSE}\n\ns11 <- rep(NA_real_, 16000*5)\n\nrecord(s11, 16000, 1)\n\n```\n\n \n\nA recording session can be controlled by three complementary functions: `pause()`, `rewind()`, and `resume()`.\n\n \n\n## Export sounds from R\n\nFor maximum compatibility with other sound programs, it may be useful to save a sound as a simple `.txt` file. The following commands will write a \"tico.txt\" file:\n\n```{r, eval = TRUE}\n\ndata(tico)\n\nexport(tico, f=22050)\n\n```\n\n \n\n## Format '.wav'\n\n**tuneR** and **audio** have a function to write `.wav` files: `writeWave()` and `save.wave()` respectively. Within **seewave**, the `savewav()` function, which is based on `writeWave()`, can be used to save data in `.wav` format. By default, the object name will be used for the name of the `.wav` file:\n\n```{r, eval = FALSE}\n\nsavewav(tico)\n\n```\n\n \n\n## Format '.flac'\n\nFree Lossless Audio Codec (FLAC) is a file format for lossless audio data compression. FLAC reduces bandwidth and storage requirements without sacrificing the integrity of the audio source. Audio sources encoded in FLAC are generally reduced in size from 40 to 50 percent. See the flac website for more details ([flac.sourceforge.net](http://flac.sourceforge.net)).\n\nThe `.flac` format cannot be used as such with R. However, the `wav2flac()`function allows you to call the FLAC software directly from the console. Therefore, FLAC must be installed on your operating system. If you have a `.wav` file that you want to compress in `.flac`, call:\n\n```{r, eval = FALSE}\n\nwav2flac(file = \"./examples/Phae.long1.wav\", overwrite = FALSE)\n\n```\n\n \n\nTo compress a `.wav` file to a `.flac` format, the argument `reverse = TRUE` must be used:\n\n```{r, eval = FALSE}\n\nwav2flac(\"Phae.long1.flac\", reverse = TRUE)\n\n```\n\n \n\nThis table, taken from Sueur (2018), summarizes the functions available to import and export sound files in R. The table is incomplete since it does not mention the functions of the `phonTools` package:\n\n<img src=\"images/tabla-waves.png\" alt=\"tabla imp exp waves\" width=\"700\"/>\n\n------------------------------------------------------------------------\n\n \n\n::: {.alert .alert-info}\n<font size=\"5\">Exercise</font>\n\n-   How does the sampling rate affect the size of an audio file? (hint: create 2 sounds files with the same data but different sampling rates; use `sine()`)\n\n-   How does the dynamic range affect the size of an audio file?\n\n-   Use the `system.time()` function to compare the performance of the different functions to import audio files in R. For this use the file \"LBH.374.SUR.wav\" (Long-billed hermit songs) which lasts about 2 min\n\nThe following code creates a plot similar to `oscillo` but using dots instead of lines:\n\n```{r, eval = FALSE}\n\n# generate sine wave\nwav <- sine(freq = 440, duration = 500, \n            xunit = \"samples\", samp.rate = 44100)\n\n# plot\nplot(wav@left) \n\n```\n\n```{r, echo = FALSE}\n\n# generate sine wave\nwav <- sine(freq = 440, duration = 500, \n            xunit = \"samples\", samp.rate = 44100)\n\npar(bg = \"#cff4fc\", mar = c(5, 4, 1, 0) + 0.1)\n\n# plot\nplot(wav@left) \n```\n\n \n\n-   Use the function `downsample()` to reduce the sampling rate of 'wav' (below 44100) and plot the output object. Decrease the sampling rate until you cannot recognize the wave pattern from the original wave object. Try several values so you get a sense at which sampling rate this happens.\n\n```{r, eval =  FALSE, echo = FALSE}\n\ndown_wav <- downsample(object = wav, samp.rate = 2756)\n\n# plot\nplot(down_wav@left) \n\n```\n:::\n\n \n\n------------------------------------------------------------------------\n\n## References\n\n1.  Sueur J, Aubin T, Simonis C. 2008. Equipment review: seewave, a free modular tool for sound analysis and synthesis. Bioacoustics 18(2):213--226.\n\n2.  Sueur, J. (2018). Sound Analysis and Synthesis with R.\n\n3.  Sueur J. (2018). I/O of sound with R. seewave package vignette. url: https://cran.r-project.org/web/packages/seewave/vignettes/seewave_IO.pdf\n\n------------------------------------------------------------------------\n\n<font size=\"4\">Session information</font>\n\n```{r session info, echo=F}\n\nsessionInfo()\n\n```\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"kable","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"show","code-overflow":"wrap","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":true,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"toc-depth":2,"number-sections":true,"highlight-style":"pygments","css":["styles.css"],"output-file":"sound.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.4.549","toc-location":"left","toc-title":"Contents","code-copy":true,"date":"today","title":"<font size=\"7\"><b>Sound</b></font>","editor_options":{"chunk_output_type":"console"}},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}