{"title":"Seewave","markdown":{"yaml":{"title":"Seewave"},"headingText":"**Objetives**","headingAttr":{"id":"","classes":["unnumbered","unlisted"],"keyvalue":[]},"containsRefs":false,"markdown":"\n\n \n\n::: {.alert .alert-info}\n\n-   Understand the most common metrics of acoustic structure\n\n-   Get familiar with manipulating and formatting sound in the R environment\n:::\n\n \n\n**seewave** provides a wide variety of tools to accurately assess sound properties in the R environment. It is an extensive package with lots of features. The package allows to visualize and measure characteristics of time, frequency and amplitude of sounds. The tools are arranged in a modular way (each analysis in its own function) which allows combining them to generate more elaborate analyzes.\n\nThe majority of the functions of **seewave** work on wave objects (but not on audio files in folders). Here we will see examples of some of these tools, focusing on those that are potentially more useful for the study of vocal behavior in animals.\n\nFirst we must load the package:\n\n```{r}\n\nlibrary(seewave)\n\n```\n\nWe can see the description of the package **seewave** in this way:\n\n```{r, eval = FALSE}\n\n?seewave\n\n```\n\n### Example data in seewave\n\n**seewave** brings several objects that we can use as an example to explore its functions. We can call them with the `data ()` function:\n\n```{r, echo=TRUE}\n\n# cargar ejemplos\ndata(tico)\n\ndata(orni)\n\ndata(sheep)\n```\n\n \n\n::: {.alert .alert-warning}\n⚠ `data()` only works to load examples that come with the packages by default, not to load your own audio files!!\n:::\n\n \n\nWe can see the information of each of them using `?`:\n\n```{r eval=FALSE}\n\n?tico\n\n```\n\n \n\n::: {.alert .alert-info}\n<font size=\"5\">Exercise</font>\n\nWhat kind of object is `tico`?\n\nWhat is the sampling rate and duration?\n:::\n\n \n\n## Oscillograms\n\nYou can create the oscillogram of the entire \"wave\" object like this:\n\n```{r}\n\noscillo(tico) \n\n```\n\nWe can also generate it for a segment:\n\n```{r}\n\noscillo(tico, from = 0, to = 1)\n\n```\n\nThe visualizations in **seewave** allow a high degree of customization. For example change the color:\n\n```{r}\n\noscillo(tico, from = 0, to = 1, colwave = \"#8fcc78\")\n\n```\n\nAs with most **seewave** functions many other components of the chart can be modified, for example:\n\n```{r}\n\n# grey background\nop <- par(bg = \"grey\")\n\noscillo(tico, f = 22050, k = 4 , j = 1,\n        title = TRUE,\n        colwave = \"black\", \n        coltitle = \"yellow\",\n        collab = \"red\",\n        colline = \"white\",\n        colaxis = \"blue\",\n        coly0 = \"grey50\")\n\n```\n\n \n\nWe can also generate other representations of \"amplitude vs. time\", such as \"amplitude envelopes\":\n\n```{r}\n\nenv(tico, f = 22050, colwave = \"#8fcc78\")\n\n```\n\nWe can superimpose it on the oscillogram to facilitate comparison:\n\n```{r}\n\noscillo(tico, f = 22050)\n\npar(new=TRUE)\n\nenv(tico, f = 22050, colwave = \"#8fcc78\")\n\n```\n\n```{r animation sliding window, eval = F, echo = FALSE}\n\n\nlibrary(\"animation\")\n\nsq <- round(seq(1, 1200, length.out = 15))\n\n# loop over different number of time windows\nsaveGIF(\n for(x in sq)\n  { \n  par(bg = \"#d1e7dd\") \n  envlp <-env(tico, ssmooth = x)\n  box()\n  title(paste(\"Window length =\", x))\n},\nmovie.name =  \"env_sliding_window_ENG_v2.gif\", interval = 0.5, ani.height = 480 / 1.5, res = 70)\n\n\n\nwl <- 512\n\n# run from here\nenvlp <-env(tico, ssmooth = wl, plot = FALSE)\nenvlp <- envlp/max(envlp)\n\nenvlp1 <- env(tico, plot = FALSE)\nenvlp1 <- envlp1/max(envlp1)\n\n\nsaveGIF(\n for(x in seq(1,(nrow(envlp1) - wl) ,by = 500))\n  { \n   par(bg = \"#d1e7dd\")\n   plot(0, 0, xlim = c(0, duration(tico)), ylim = c(-1, 1), col = \"white\", yaxt = \"n\", xlab = \"Time\", ylab = \"Amplitude\")\n   abline(h = 0, lty = 2, col = \"gray\")\n   envlp1[1:x,] <- envlp[1:x,]\n   lines(x = seq(0, duration(tico), length.out = nrow(envlp1)), y = envlp1[,1])\n   \n   lines(x = (x:(x + wl)) / tico@samp.rate, y = rep(0, wl + 1), lwd = 7, col = \"red\")\n   \n   title(paste(\"Window length =\", wl))\n},\nmovie.name =  paste0(\"env_sliding_window_scheme_ENG_v2_\", wl, \".gif\"), interval = 0.2, ani.height = 480 / 1.5, res = 70)\n\n\n```\n\n \n\n::: {.alert .alert-success}\n<font size=\"3\"><b>Sliding window for time series</b></font>\n\n \n\nSliding windows allow you to smooth out the contours of a time series by calculating an average value around the \"neighborhood\" of values for a given value. In the case of amplitude envelope the size of the \"neighborhood\" is given by the length of the window (\"wl\"). The larger the window length, the greater the smoothing of the curve:\n\n \n\n<img src=\"images/env_sliding_window_ENG_v2.gif\" alt=\"Sliding window\"/>\n\n \n\nThis animation shows how the amplitude envelope of the \"tico\" object is smoothed with a 512-point window:\n\n \n\n<img src=\"images/env_sliding_window_scheme_ENG_v2_512.gif\" alt=\"Sliding window\"/>\n\n \n\n... or a 1024 point window:\n\n \n\n<img src=\"images/env_sliding_window_scheme_ENG_v2_1024.gif\" alt=\"Sliding window\"/>\n\n \n:::\n\n \n\nWe can use these amplitude \"hills\" to define segments in the \"wave\" object using the `timer()` function. The \"ssmooth\" argument allows us to use a sliding window:\n\n```{r, eval = T, echo = T}\n\ntmr <- timer(orni, f = 22050, threshold = 5, ssmooth = 40, \n             bty = \"l\", colval = \"#51c724\")\n\ntmr\n```\n\n \n\nThe output is a list with the following elements:\n\n-   **s**: duration of detected signals (in s)\n-   **p**: duration of pauses (i.e. gaps) between signals\n-   **r**: ratio of **s** to **r**\n-   **s.start**: start of signals\n-   **end**: end of signals\n\n \n\n::: {.alert .alert-info}\n<font size=\"5\">Exercise</font>\n\n-   In the previous example using `timer()` the last pulse is divided into 2 detections, one very small at the beginning and another containing the rest of the pulse. Change the \"ssmooth\" argument until this section is detected as a single pulse.\n:::\n\n \n\n## Power Spectra\n\nWe can visualize the amplitude in the frequency domain using power spectra. The `meanspec()` function calculates the average distribution of energy in the frequency range (the average power spectrum):\n\n```{r, eval = TRUE, echo = TRUE}\n\nmspc <- meanspec(orni, f = 22050, wl = 512, col = \"#d1e7dd\")\n\npolygon(rbind(c(0, 0), mspc), col = \"#d1e7dd\")\n\nnrow(mspc)\n\n```\n\nThe `spec()` function, on the other hand, calculates the spectrum for the entire signal:\n\n```{r, eval = TRUE, echo = TRUE}\n\nspc <- spec(orni, f=22050, wl=512, col = \"#8fcc78\")\n\nnrow(spc)\n\n```\n\nThe result of `spec()` or `meanspec()` can be input into the `fpeaks()` function to calculate amplitude peaks:\n\n```{r, eval = TRUE, echo = TRUE, warning = FALSE}\n\npks <- fpeaks(spc, nmax = 1)\n\npks\n\n```\n\n \n\n## Wave manipulation\n\nWe can cut segments of a \"wave\" object:\n\n```{r, eval = TRUE, echo = TRUE, warning = FALSE}\n\ntico2 <- cutw(tico, to = 1, output = \"Wave\")\n\noscillo(tico2)\n\n```\n\nAdd segments:\n\n```{r, eval = TRUE, echo = TRUE, warning = FALSE}\n\ntico3 <- pastew(tico, tico2, output = \"Wave\")\n\noscillo(tico3)\n\n```\n\nRemove segments:\n\n```{r, eval = TRUE, echo = TRUE, warning = FALSE}\n\ntico4 <- deletew(tico, output = \"Wave\", from = 0.55, to = 0.93)\n\noscillo(tico4)\n\n```\n\nAdd segments of silence:\n\n```{r, eval = TRUE, echo = TRUE, warning = FALSE}\n\ntico5 <- addsilw(tico, at = \"end\", d = 1, output = \"Wave\")\n\noscillo(tico5)\n\nduration(tico)\nduration(tico5)\n\n```\n\n \n\n::: {.alert .alert-info}\n<font size=\"5\">Exercise</font>\n\n-   The function `rev()` can reverse the order of a vector:\n\n```{r}\n\nv1 <- c(1, 2, 3)\n\nrev(v1)\n\n```\n\n-   Reverse the amplitude vector of 'tico' and generate a spectrogram of the reversed wave object\n:::\n\n \n\nFilter out frequency bands:\n\n```{r, eval = TRUE, echo = TRUE, warning = FALSE}\n\n# original\nspectro(tico, scale = FALSE, grid = FALSE, flim = c(2, 6))\n\n# filtered\nspectro(ffilter(tico, from = 4000, to = 6500, output = \"Wave\"), scale = FALSE, grid = FALSE, flim = c(2, 6))\n\n```\n\nChange frequency (pitch):\n\n```{r, eval = TRUE, echo = TRUE, warning = FALSE}\n\n# cut the first\ntico6 <- cutw(tico, from = 0, to = 0.5, output = \"Wave\")\n\n# increase frec\ntico.lfs <- lfs(tico6, shift = 1000, output = \"Wave\")\n\n# decrease frec\ntico.lfs.neg <- lfs(tico6, shift = -1000, output = \"Wave\")\n\n# 3 column graph\nopar <- par()\npar(mfrow = c(1, 3))\n\n# original\nspectro(tico6, scale = FALSE, grid = FALSE, flim = c(1, 8), main = \"original\")\n\n# modified\nspectro(tico.lfs, scale = FALSE, grid = FALSE, flim = c(1, 8), main = \"1 kHz up\")\n\nspectro(tico.lfs.neg, scale = FALSE, grid = FALSE, flim = c(1, 8), main = \"1 kHz down\")\n\npar(opar)\n\n```\n\n## Measurements\n\n \n\nApart from the measurements of peak frequency (`fpeaks()`) and duration (`timer()`), we can measure many other aspects of the acoustic signals using **seewave**. For example, we can estimate the fundamental frequency (which refers to the lowest frequency harmonic in the harmonic stack), with the `fund()` function:\n\n```{r, eval = TRUE, echo = TRUE, warning = FALSE}\n\nspectro(sheep, scale = FALSE, grid = FALSE)\n\npar(new=TRUE)\n\nff <- fund(sheep, fmax = 300, ann = FALSE, threshold=6, col = \"green\")\n\nhead(ff)\n\n```\n\n \n\nThis function uses cepstral transformation to detect the dominant frequency. The `autoc()` function also measures the fundamental frequency, only using autocorrelation.\n\nSimilarly we can measure the dominant frequency (the harmonic with the highest energy):\n\n```{r, eval = FALSE, echo = TRUE, warning = FALSE}\n\npar(new=TRUE)\n\ndf <- dfreq(sheep, f = 8000, fmax = 300, type = \"p\", pch = 24, ann = FALSE, threshold = 6, col = \"red\")\n\nhead(df)\n\n```\n\n```{r, eval = TRUE, echo = FALSE, warning = FALSE}\n\nspectro(sheep, scale = FALSE)\n\npar(new=TRUE)\n\nff <- fund(sheep, fmax = 300, ann = FALSE, threshold=6, col = \"green\")\n\npar(new=TRUE)\n\ndf <- dfreq(sheep, fmax = 300, type = \"p\", pch = 24, ann = FALSE, threshold = 6, col = \"red\")\n\nhead(df)\n```\n\n \n\nMeasure statistical descriptors of the amplitude distribution in frequency and time:\n\n```{r, eval = TRUE, echo = TRUE, warning = FALSE}\n\n# cut\nnote2 <- cutw(tico, from=0.6, to=0.9, output=\"Wave\")\n\nn2.as <- acoustat(note2)\n\nas.data.frame(n2.as[3:8])\n\n```\n\n \n\nMeasure statistical descriptors of frequency spectra:\n\n```{r, eval = TRUE, echo = TRUE, warning = FALSE}\n\n# measure power spectrum\nn2.sp <- meanspec(note2, plot = FALSE)\n\nn2.spcp <- specprop(n2.sp, f = note2@samp.rate)\n\nas.data.frame(n2.spcp)\n\n```\n\n \n\n::: {.alert .alert-info}\n<font size=\"5\">Exercise</font>\n\n-   Measure the statistical descriptors of the frequency spectra (function `specprop()`) on the 3 notes (hint: you must cut each note first)\n:::\n\n \n\n------------------------------------------------------------------------\n\n<font size=\"4\">Session information</font>\n\n```{r session info, echo=F}\n\nsessionInfo()\n\n```\n","srcMarkdownNoYaml":"\n\n \n\n::: {.alert .alert-info}\n## **Objetives** {.unnumbered .unlisted}\n\n-   Understand the most common metrics of acoustic structure\n\n-   Get familiar with manipulating and formatting sound in the R environment\n:::\n\n \n\n**seewave** provides a wide variety of tools to accurately assess sound properties in the R environment. It is an extensive package with lots of features. The package allows to visualize and measure characteristics of time, frequency and amplitude of sounds. The tools are arranged in a modular way (each analysis in its own function) which allows combining them to generate more elaborate analyzes.\n\nThe majority of the functions of **seewave** work on wave objects (but not on audio files in folders). Here we will see examples of some of these tools, focusing on those that are potentially more useful for the study of vocal behavior in animals.\n\nFirst we must load the package:\n\n```{r}\n\nlibrary(seewave)\n\n```\n\nWe can see the description of the package **seewave** in this way:\n\n```{r, eval = FALSE}\n\n?seewave\n\n```\n\n### Example data in seewave\n\n**seewave** brings several objects that we can use as an example to explore its functions. We can call them with the `data ()` function:\n\n```{r, echo=TRUE}\n\n# cargar ejemplos\ndata(tico)\n\ndata(orni)\n\ndata(sheep)\n```\n\n \n\n::: {.alert .alert-warning}\n⚠ `data()` only works to load examples that come with the packages by default, not to load your own audio files!!\n:::\n\n \n\nWe can see the information of each of them using `?`:\n\n```{r eval=FALSE}\n\n?tico\n\n```\n\n \n\n::: {.alert .alert-info}\n<font size=\"5\">Exercise</font>\n\nWhat kind of object is `tico`?\n\nWhat is the sampling rate and duration?\n:::\n\n \n\n## Oscillograms\n\nYou can create the oscillogram of the entire \"wave\" object like this:\n\n```{r}\n\noscillo(tico) \n\n```\n\nWe can also generate it for a segment:\n\n```{r}\n\noscillo(tico, from = 0, to = 1)\n\n```\n\nThe visualizations in **seewave** allow a high degree of customization. For example change the color:\n\n```{r}\n\noscillo(tico, from = 0, to = 1, colwave = \"#8fcc78\")\n\n```\n\nAs with most **seewave** functions many other components of the chart can be modified, for example:\n\n```{r}\n\n# grey background\nop <- par(bg = \"grey\")\n\noscillo(tico, f = 22050, k = 4 , j = 1,\n        title = TRUE,\n        colwave = \"black\", \n        coltitle = \"yellow\",\n        collab = \"red\",\n        colline = \"white\",\n        colaxis = \"blue\",\n        coly0 = \"grey50\")\n\n```\n\n \n\nWe can also generate other representations of \"amplitude vs. time\", such as \"amplitude envelopes\":\n\n```{r}\n\nenv(tico, f = 22050, colwave = \"#8fcc78\")\n\n```\n\nWe can superimpose it on the oscillogram to facilitate comparison:\n\n```{r}\n\noscillo(tico, f = 22050)\n\npar(new=TRUE)\n\nenv(tico, f = 22050, colwave = \"#8fcc78\")\n\n```\n\n```{r animation sliding window, eval = F, echo = FALSE}\n\n\nlibrary(\"animation\")\n\nsq <- round(seq(1, 1200, length.out = 15))\n\n# loop over different number of time windows\nsaveGIF(\n for(x in sq)\n  { \n  par(bg = \"#d1e7dd\") \n  envlp <-env(tico, ssmooth = x)\n  box()\n  title(paste(\"Window length =\", x))\n},\nmovie.name =  \"env_sliding_window_ENG_v2.gif\", interval = 0.5, ani.height = 480 / 1.5, res = 70)\n\n\n\nwl <- 512\n\n# run from here\nenvlp <-env(tico, ssmooth = wl, plot = FALSE)\nenvlp <- envlp/max(envlp)\n\nenvlp1 <- env(tico, plot = FALSE)\nenvlp1 <- envlp1/max(envlp1)\n\n\nsaveGIF(\n for(x in seq(1,(nrow(envlp1) - wl) ,by = 500))\n  { \n   par(bg = \"#d1e7dd\")\n   plot(0, 0, xlim = c(0, duration(tico)), ylim = c(-1, 1), col = \"white\", yaxt = \"n\", xlab = \"Time\", ylab = \"Amplitude\")\n   abline(h = 0, lty = 2, col = \"gray\")\n   envlp1[1:x,] <- envlp[1:x,]\n   lines(x = seq(0, duration(tico), length.out = nrow(envlp1)), y = envlp1[,1])\n   \n   lines(x = (x:(x + wl)) / tico@samp.rate, y = rep(0, wl + 1), lwd = 7, col = \"red\")\n   \n   title(paste(\"Window length =\", wl))\n},\nmovie.name =  paste0(\"env_sliding_window_scheme_ENG_v2_\", wl, \".gif\"), interval = 0.2, ani.height = 480 / 1.5, res = 70)\n\n\n```\n\n \n\n::: {.alert .alert-success}\n<font size=\"3\"><b>Sliding window for time series</b></font>\n\n \n\nSliding windows allow you to smooth out the contours of a time series by calculating an average value around the \"neighborhood\" of values for a given value. In the case of amplitude envelope the size of the \"neighborhood\" is given by the length of the window (\"wl\"). The larger the window length, the greater the smoothing of the curve:\n\n \n\n<img src=\"images/env_sliding_window_ENG_v2.gif\" alt=\"Sliding window\"/>\n\n \n\nThis animation shows how the amplitude envelope of the \"tico\" object is smoothed with a 512-point window:\n\n \n\n<img src=\"images/env_sliding_window_scheme_ENG_v2_512.gif\" alt=\"Sliding window\"/>\n\n \n\n... or a 1024 point window:\n\n \n\n<img src=\"images/env_sliding_window_scheme_ENG_v2_1024.gif\" alt=\"Sliding window\"/>\n\n \n:::\n\n \n\nWe can use these amplitude \"hills\" to define segments in the \"wave\" object using the `timer()` function. The \"ssmooth\" argument allows us to use a sliding window:\n\n```{r, eval = T, echo = T}\n\ntmr <- timer(orni, f = 22050, threshold = 5, ssmooth = 40, \n             bty = \"l\", colval = \"#51c724\")\n\ntmr\n```\n\n \n\nThe output is a list with the following elements:\n\n-   **s**: duration of detected signals (in s)\n-   **p**: duration of pauses (i.e. gaps) between signals\n-   **r**: ratio of **s** to **r**\n-   **s.start**: start of signals\n-   **end**: end of signals\n\n \n\n::: {.alert .alert-info}\n<font size=\"5\">Exercise</font>\n\n-   In the previous example using `timer()` the last pulse is divided into 2 detections, one very small at the beginning and another containing the rest of the pulse. Change the \"ssmooth\" argument until this section is detected as a single pulse.\n:::\n\n \n\n## Power Spectra\n\nWe can visualize the amplitude in the frequency domain using power spectra. The `meanspec()` function calculates the average distribution of energy in the frequency range (the average power spectrum):\n\n```{r, eval = TRUE, echo = TRUE}\n\nmspc <- meanspec(orni, f = 22050, wl = 512, col = \"#d1e7dd\")\n\npolygon(rbind(c(0, 0), mspc), col = \"#d1e7dd\")\n\nnrow(mspc)\n\n```\n\nThe `spec()` function, on the other hand, calculates the spectrum for the entire signal:\n\n```{r, eval = TRUE, echo = TRUE}\n\nspc <- spec(orni, f=22050, wl=512, col = \"#8fcc78\")\n\nnrow(spc)\n\n```\n\nThe result of `spec()` or `meanspec()` can be input into the `fpeaks()` function to calculate amplitude peaks:\n\n```{r, eval = TRUE, echo = TRUE, warning = FALSE}\n\npks <- fpeaks(spc, nmax = 1)\n\npks\n\n```\n\n \n\n## Wave manipulation\n\nWe can cut segments of a \"wave\" object:\n\n```{r, eval = TRUE, echo = TRUE, warning = FALSE}\n\ntico2 <- cutw(tico, to = 1, output = \"Wave\")\n\noscillo(tico2)\n\n```\n\nAdd segments:\n\n```{r, eval = TRUE, echo = TRUE, warning = FALSE}\n\ntico3 <- pastew(tico, tico2, output = \"Wave\")\n\noscillo(tico3)\n\n```\n\nRemove segments:\n\n```{r, eval = TRUE, echo = TRUE, warning = FALSE}\n\ntico4 <- deletew(tico, output = \"Wave\", from = 0.55, to = 0.93)\n\noscillo(tico4)\n\n```\n\nAdd segments of silence:\n\n```{r, eval = TRUE, echo = TRUE, warning = FALSE}\n\ntico5 <- addsilw(tico, at = \"end\", d = 1, output = \"Wave\")\n\noscillo(tico5)\n\nduration(tico)\nduration(tico5)\n\n```\n\n \n\n::: {.alert .alert-info}\n<font size=\"5\">Exercise</font>\n\n-   The function `rev()` can reverse the order of a vector:\n\n```{r}\n\nv1 <- c(1, 2, 3)\n\nrev(v1)\n\n```\n\n-   Reverse the amplitude vector of 'tico' and generate a spectrogram of the reversed wave object\n:::\n\n \n\nFilter out frequency bands:\n\n```{r, eval = TRUE, echo = TRUE, warning = FALSE}\n\n# original\nspectro(tico, scale = FALSE, grid = FALSE, flim = c(2, 6))\n\n# filtered\nspectro(ffilter(tico, from = 4000, to = 6500, output = \"Wave\"), scale = FALSE, grid = FALSE, flim = c(2, 6))\n\n```\n\nChange frequency (pitch):\n\n```{r, eval = TRUE, echo = TRUE, warning = FALSE}\n\n# cut the first\ntico6 <- cutw(tico, from = 0, to = 0.5, output = \"Wave\")\n\n# increase frec\ntico.lfs <- lfs(tico6, shift = 1000, output = \"Wave\")\n\n# decrease frec\ntico.lfs.neg <- lfs(tico6, shift = -1000, output = \"Wave\")\n\n# 3 column graph\nopar <- par()\npar(mfrow = c(1, 3))\n\n# original\nspectro(tico6, scale = FALSE, grid = FALSE, flim = c(1, 8), main = \"original\")\n\n# modified\nspectro(tico.lfs, scale = FALSE, grid = FALSE, flim = c(1, 8), main = \"1 kHz up\")\n\nspectro(tico.lfs.neg, scale = FALSE, grid = FALSE, flim = c(1, 8), main = \"1 kHz down\")\n\npar(opar)\n\n```\n\n## Measurements\n\n \n\nApart from the measurements of peak frequency (`fpeaks()`) and duration (`timer()`), we can measure many other aspects of the acoustic signals using **seewave**. For example, we can estimate the fundamental frequency (which refers to the lowest frequency harmonic in the harmonic stack), with the `fund()` function:\n\n```{r, eval = TRUE, echo = TRUE, warning = FALSE}\n\nspectro(sheep, scale = FALSE, grid = FALSE)\n\npar(new=TRUE)\n\nff <- fund(sheep, fmax = 300, ann = FALSE, threshold=6, col = \"green\")\n\nhead(ff)\n\n```\n\n \n\nThis function uses cepstral transformation to detect the dominant frequency. The `autoc()` function also measures the fundamental frequency, only using autocorrelation.\n\nSimilarly we can measure the dominant frequency (the harmonic with the highest energy):\n\n```{r, eval = FALSE, echo = TRUE, warning = FALSE}\n\npar(new=TRUE)\n\ndf <- dfreq(sheep, f = 8000, fmax = 300, type = \"p\", pch = 24, ann = FALSE, threshold = 6, col = \"red\")\n\nhead(df)\n\n```\n\n```{r, eval = TRUE, echo = FALSE, warning = FALSE}\n\nspectro(sheep, scale = FALSE)\n\npar(new=TRUE)\n\nff <- fund(sheep, fmax = 300, ann = FALSE, threshold=6, col = \"green\")\n\npar(new=TRUE)\n\ndf <- dfreq(sheep, fmax = 300, type = \"p\", pch = 24, ann = FALSE, threshold = 6, col = \"red\")\n\nhead(df)\n```\n\n \n\nMeasure statistical descriptors of the amplitude distribution in frequency and time:\n\n```{r, eval = TRUE, echo = TRUE, warning = FALSE}\n\n# cut\nnote2 <- cutw(tico, from=0.6, to=0.9, output=\"Wave\")\n\nn2.as <- acoustat(note2)\n\nas.data.frame(n2.as[3:8])\n\n```\n\n \n\nMeasure statistical descriptors of frequency spectra:\n\n```{r, eval = TRUE, echo = TRUE, warning = FALSE}\n\n# measure power spectrum\nn2.sp <- meanspec(note2, plot = FALSE)\n\nn2.spcp <- specprop(n2.sp, f = note2@samp.rate)\n\nas.data.frame(n2.spcp)\n\n```\n\n \n\n::: {.alert .alert-info}\n<font size=\"5\">Exercise</font>\n\n-   Measure the statistical descriptors of the frequency spectra (function `specprop()`) on the 3 notes (hint: you must cut each note first)\n:::\n\n \n\n------------------------------------------------------------------------\n\n<font size=\"4\">Session information</font>\n\n```{r session info, echo=F}\n\nsessionInfo()\n\n```\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"kable","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"show","code-overflow":"wrap","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":true,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"toc-depth":2,"number-sections":true,"highlight-style":"pygments","css":["styles.css"],"output-file":"seewave.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.4.549","toc-location":"left","toc-title":"Contents","code-copy":true,"date":"today","title":"Seewave"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}