{"title":"<font size=\"7\"><b>Measures of acoustic structure</b></font>","markdown":{"yaml":{"title":"<font size=\"7\"><b>Measures of acoustic structure</b></font>","editor_options":{"chunk_output_type":"console"}},"headingText":"**Objetives**","headingAttr":{"id":"","classes":["unnumbered","unlisted"],"keyvalue":[]},"containsRefs":false,"markdown":"\n\n \n\n\n```{r clean session, echo=F, warning=FALSE, message=FALSE}\n\nknitr::opts_chunk$set(dpi = 200)\n\nlibrary(warbleR)\nlibrary(kableExtra)\nlibrary(viridis)\nlibrary(ggplot2)\nlibrary(ggalign)\nlibrary(PhenotypeSpace)\n```\n\n\n::: {.alert .alert-info}\n\n-   Learn the different methods available to quantify acoustic structure\n\n-   Understand their pros and cons\n\n-   Learn how to apply them in R\n:::\n\n \n\nAcoustic signals are multidimensional traits; they vary complexly in time, frequency, amplitude and combinations of these dimensions. Generally, in biology we want to measure aspects of acoustic signals that vary in response to the factors predicted by our hypotheses. In some cases we even lack predictions for specific acoustic parameters and we need to evaluate the relative similarity between the variants of a signal in a population. These analyses require a diversity of tools for quantifying the multiple dimensions in which we can decompose the signals.\n\nThe **warbleR** package is designed to quantify the acoustic structure of a population of signals using 4 main methods of analysis. 2 of them are absolute measures of the structure:\n\n-   Spectrographic parameters\n-   Statistical descriptors of cepstral coefficients\n\nThe other 2 provide a relative similarity value between signals:\n\n-   Spectrographic cross-correlation\n-   Dynamic time warping\n\n\n::: {.alert .alert-warning}\n## Example data\n\nWe will use the example data `lbh_selec_table` that comes with the package. This data frame contains the selection table of 11 long-billed hermit (*Phaethornis longirostris*) songs. The selection table is a data frame with the following columns:\n\n```{r}\n#| eval=FALSE\n\nlibrary(warbleR)\nlibrary(viridis)\nlibrary(ggplot2)\nlibrary(ggalign)\nlibrary(PhenotypeSpace)\n\nwarbleR_options(wav.path = \"./examples/\", flim = c(1, 10), wl = 200, ovlp = 90, pb = FALSE)\n\ndata(lbh_selec_table)\n\nlbh_selec_table\n```\n\n\n```{r, echo=FALSE}\n\nwarbleR_options(wav.path = \"./examples/\", flim = c(1, 10), wl = 200, ovlp = 90, pb = FALSE)\n\ndata(lbh_selec_table)\n\nkbl <- kable(lbh_selec_table, align = \"c\", row.names = F,  format = \"html\")\n\nkbl <- kable_styling(kbl, bootstrap_options = c(\"striped\", \"hover\", \"condensed\", \"responsive\"), full_width = FALSE, font_size = 11)\n\nscroll_box(kbl, width = \"808px\",\nbox_css = \"border: 1px solid #ddd; padding: 5px; \", extra_css = NULL)\n\n```\n\nThis is a catalog (made with the `catalog()` function) with the spectrograms of all sounds referenced in the selection table (*the function saves the image file(s) in the folder in which the sound files are found*):\n\n```{r}\n#| eval=FALSE\n\n# make a color pallete for tagging spectrograms\ntag_pal <- function(x)\n  mako(x,\n       alpha = 0.6,\n       begin = 0.1,\n       end = 0.9)\n\n# plot all annotation spectrograms in a catalog\ncatalog(\n  lbh_selec_table,\n  flim = c(1.5, 10),\n  wl = 200,\n  ovlp = 90,\n  nrow = 4,\n  ncol = 3,\n  width = 12,\n  height = 8,\n  pb = FALSE,\n  same.time.scale = TRUE,\n  mar = 0.02,\n  pal = mako,\n  collevels = seq(-120, 0, 1),\n  group.tag = \"sound.files\",\n  tag.pal = list(tag_pal),\n  spec.mar = 0.6,\n  box = FALSE,\n  res = 200\n)\n\n\n```\n\n\n```{r}\n#| echo: false\n#| out.width: \"100%\"\n\nknitr::include_graphics(\"./images/Catalog_p1.jpeg\")\n\n```\n\n  It is clear that each sound file contains a different variant of the song. We will use these data to illustrate the different methods of acoustic structure analysis available in **warbleR**.\n\n:::\n\n## Spectrographic parameters\n\nThe `spectro_analysis()` function measures the following spectrographic parameters related to amplitude distributions in time and frequency, descriptors of the fundamental and dominant frequency contours and descriptors of harmonic content:\n\n \n\n::: {.alert .alert-success}\n#### Time and frequency (measured on the spectrogram)\n\n-   duration: signal length (in s)\n\n-   meanfreq: medium frequency. Weighted average frequency by amplitude (in kHz)\n\n-   sd: standard deviation of the amplitude weighted frequency\n\n \n\n#### Energy distribution across frequencies (measured on the power spetrum)\n\n-   freq.median: medium frequency. The frequency at which the signal is divided into two frequency intervals of equal energy (in kHz)\n\n-   freq.Q25: first frequency quartile. The frequency at which the signal is divided into two frequency ranges of 25% and 75% energy respectively (in kHz)\n\n-   freq.Q75: third frequency quartile. The frequency at which the signal is divided into two frequency ranges of 75% and 25% energy respectively (in kHz)\n\n-   freq.IQR: interquartile frequency range. Frequency range between 'freq.Q25' and 'freq.Q75' (in kHz)\n\n-   sp.ent: spectral entropy. Frequency spectrum energy distribution. Pure tone \\~ 0; loud \\~ 1\n\n-   peakf: peak frequency. Frequency with the highest energy. This parameter can take a considerable amount of time to measure. Only generated if `fast = FALSE`. It provides a more accurate measurement of the peak frequency than `meanpeakf()`, but can be more easily affected by background noise\n\n-   meanpeakf: mean peak frequency. Frequency with the highest energy of the medium frequency spectrum (see `meanspec()`). Typically more consistent than `peakf()`\n\n \n\n#### Energy distribution across time (measured on the amplitude envelope)\n\n-   time.median: average time. The time at which the signal is divided into two time intervals of equal energy (in s)\n\n-   time.Q25: first quartile. The time in which the signal is divided into two time intervals of 25% and 75% energy respectively (in s)\n\n-   time Q75: third quartile. The time in which the signal is divided into two time intervals of 75% and 25% energy respectively (in s)\n\n-   time.IQR: interquartile time range. Time range between 'time.Q25' and 'time.Q75' (in s)\n\n-   skew (skewness): Asymmetry of the amplitude distribution\n\n-   kurt (kurtosis): measure of \"peakedness\" of the spectrum\n\n-   time.ent: temporary entropy. Energy distribution in the time envelope. Pure tone \\~ 0; loud \\~ 1\n\n-   entropy: Product of the spectral and temporal entropy: `sp.ent * time.ent`\n\n-   sfm: spectral flatness. Similar to sp.ent (pure tone \\~ 0; loud \\~ 1)\n\n \n\n#### Fundamental frequency contour descriptors (measured on the spectrogram)\n\n-   meanfun: average of the fundamental frequency measured through the signal\n\n-   minfun: minimum fundamental frequency measured through the signal\n\n-   maxfun: maximum fundamental frequency measured through the signal\n\n \n\n#### Dominant frequency contour descriptors (measured on the spectrogram)\n\n-   meandom: average of the dominant frequency measured through the signal\n\n-   mindom: minimum dominant frequency measured through the signal\n\n-   maxdom: maximum of the dominant frequency measured through the signal\n\n-   dfrange: dominant frequency range measured through the signal\n\n-   modindx: modulation index. Calculated as the cumulative absolute difference between adjacent measurements of dominant frequencies divided by the dominant frequency range. 1 means that the signals are not modulated\n\n-   startdom: measurement of dominant frequency at the beginning of the signal\n\n-   enddom: dominant frequency measurement at the end of the signal\n\n-   dfslope: pending change in the dominant frequency over time (`(enddom-startdom)/duration`). The units are kHz/s\n\n \n\n#### Harmonic content descriptors (measured on the spectrogram)\n\n-   hn_freq: average frequency of the upper 'n' harmonics (kHz) The number of harmonics is defined with the argument 'nharmonics'\n\n-   hn_width: average bandwidth of the upper 'n' harmonics (kHz) (see analysis). The number of harmonics is defined with the argument 'nharmonics'\n\n-   harmonics: the amount of energy in higher harmonics. The number of harmonics is defined with the argument 'nharmonics'\n\n-   HNR: relationship between harmonics and noise (dB). A measure of harmonic content\n:::\n\n \n\nWe can easily measure them as follows:\n\n```{r, eval= FALSE, echo=TRUE, warning=FALSE, message=FALSE}\n\n# load examples\ndata(\"lbh_selec_table\")\n\nsp <- spectro_analysis(lbh_selec_table)\n\nsp\n\n```\n\n```{r, echo=FALSE}\n\nsp <- spectro_analysis(lbh_selec_table)\n\nkbl <- kable(sp, align = \"c\", row.names = F,  format = \"html\")\n\nkbl <- kable_styling(kbl, bootstrap_options = c(\"striped\", \"hover\", \"condensed\", \"responsive\"), full_width = FALSE, font_size = 11)\n\nscroll_box(kbl, width = \"808px\",\nbox_css = \"border: 1px solid #ddd; padding: 5px; \", extra_css = NULL)\n\n```\n\nWe can reduce the dimensionality using Principal component analysis (PCA):\n```{r}\n#| eval: false\n\n# run principal components\npca <- prcomp(sp[, -c(1, 2)], scale = TRUE)\n\n# extract first 2 PCs\nsp_pcs <- data.frame(sp[, 1:2], pca$x[, 1:2])\n\nsp_pcs\n```\n```{r}\n#| echo: false\n\n# run principal components\npca <- prcomp(sp[, -c(1, 2)], scale = TRUE)\n\n# extract first 2 PCs\nsp_pcs <- data.frame(sp[, 1:2], pca$x[, 1:2])\n\nkbl <- kable(sp_pcs, align = \"c\", row.names = F,  format = \"html\")\n\nkbl <- kable_styling(kbl, bootstrap_options = c(\"striped\", \"hover\", \"condensed\", \"responsive\"), full_width = FALSE, font_size = 11)\n\nscroll_box(kbl, width = \"808px\",\nbox_css = \"border: 1px solid #ddd; padding: 5px; \", extra_css = NULL)\n\n```\n\nThe acoustic space described by this data can be easily visualized with a scatterplot: \n\n\n```{r}\nggplot(sp_pcs,\n       aes(\n         x = PC1,\n         y = PC2,\n         color = sound.files,\n         shape =  sound.files\n       )) +\n  geom_point(size = 5) +\n  scale_color_viridis_d(option = \"G\",\n                        end = 0.9,\n                        direction = -1) +\n  theme_classic() +\n  labs(x = \"PC1\", y = \"PC2\") +\n  theme(legend.position = \"right\")\n\n```\n\n\n\n::: {.alert .alert-info}\n<font size=\"5\">Exercise</font>\n\n\n-   The parameters related to harmonic content were not calculated. How can we do that?\n\n-   How does measuring harmonic content affect performance?\n\n-   What does the argument 'threshold' do?\n:::\n\n \n\n## Statistical descriptors of cepstral coefficients\n\nThese coefficients were designed to decompose the sounds in a similar way than the human auditory system in order to facilitate speech recognition. The central idea is to compress the acoustic data maintaining only relevant information for the detection of phonetic differences. The principle refers to human hearing using the Mel logarithmic scale whose definition is based on how the human ear perceives frequency and loudness (Sueur 2018). Cepstral coefficients are literally defined as \"the result of a cosine transformation of the real logarithm of short-term energy spectra expressed on a Mel frequency scale\".\n\nThe descriptive statistics that are extracted from the cepstral coefficients are: minimum, maximum, average, median, asymmetry, kurtosis and variance. It also returns the mean and variance for the first and second derivatives of the coefficients. These parameters are commonly used in the processing and detection of acoustic signals (e.g. Salamon et al 2014). They have been widely used for human voice analysis and its use has extended to mammalian bioacoustics, although they also appear to be useful for quantifying the structure of acoustic signals in other groups.\n\nIn **warbleR** we can calculate statistical descriptors of cepstral coefficients with the `mfcc_stats()` function:\n\n```{r, eval = FALSE}\n\ncc <- mfcc_stats(X = lbh_selec_table)\n\ncc\n\n```\n\n```{r, eval= TRUE, echo=FALSE, warning=FALSE, message=FALSE}\n\ncc <- mfcc_stats(X = lbh_selec_table)\n\nkbl <- kable(cc, align = \"c\", row.names = F,  format = \"html\")\n\nkbl <- kable_styling(kbl, bootstrap_options = c(\"striped\", \"hover\", \"condensed\", \"responsive\"), full_width = FALSE, font_size = 11)\n\nscroll_box(kbl, width = \"808px\",\nbox_css = \"border: 1px solid #ddd; padding: 5px; \", extra_css = NULL)\n\n```\n\nSimilarly to the spectrographic parameters, we can reduce the dimensionality of the cepstral coefficients using PCA:\n\n```{r}\n#| eval: false\n\n# run principal components\npca <- prcomp(cc[, -c(1, 2)], scale = TRUE)\n\n# extract first 2 PCs\ncc_pcs <- data.frame(cc[, 1:2], pca$x[, 1:2])\n\ncc_pcs\n```\n\n```{r}\n#| echo: false\n\n# run principal components\npca <- prcomp(cc[, -c(1, 2)], scale = TRUE)\n\n# extract first 2 PCs\ncc_pcs <- data.frame(cc[, 1:2], pca$x[, 1:2])\n\nkbl <- kable(cc_pcs, align = \"c\", row.names = F,  format = \"html\")\n\nkbl <- kable_styling(kbl, bootstrap_options = c(\"striped\", \"hover\", \"condensed\", \"responsive\"), full_width = FALSE, font_size = 11)\n\nscroll_box(kbl, width = \"808px\",\nbox_css = \"border: 1px solid #ddd; padding: 5px; \", extra_css = NULL)\n\n```\n\nAgain, this simplified acoustic space can be easily visualized with a scatterplot: \n\n```{r}\nggplot(cc_pcs,\n       aes(\n         x = PC1,\n         y = PC2,\n         color = sound.files,\n         shape =  sound.files\n       )) +\n  geom_point(size = 5) +\n  scale_color_viridis_d(option = \"G\",\n                        end = 0.9,\n                        direction = -1) +\n  theme_classic() +\n  labs(x = \"PC1\", y = \"PC2\") +\n  theme(legend.position = \"right\")\n\n```\n\n## (Spectrographic) cross correlation\n\nThis analysis correlates the amplitude values in the frequency and time space pairwise for all signals in a selection table. The correlation represents a measure of spectrographic similarity of the signals:\n\n```{r, eval = FALSE}\n\nxcor <- cross_correlation(X = lbh_selec_table)\n\nxcor\n```\n\n```{r, echo=FALSE}\n\nxcor <- cross_correlation(X = lbh_selec_table)\n\nkbl <- kable(xcor, align = \"c\", row.names = TRUE,  format = \"html\")\n\nkbl <- kable_styling(kbl, bootstrap_options = c(\"striped\", \"hover\", \"condensed\", \"responsive\"), full_width = FALSE, font_size = 11)\n\nscroll_box(kbl, width = \"808px\",\nbox_css = \"border: 1px solid #ddd; padding: 5px; \", extra_css = NULL)\n\n```\n\n\nThe similarity matrix returned by the function can be visualized as a heatmap:\n\n```{r}\n\n# present xcor as a heatmap using ggplot2\nggheatmap(xcor) +\n  scale_fill_viridis_c(\n    option = \"G\",\n    direction = 1,\n    begin = 0.1,\n    end = 0.8\n  ) +\n  theme(axis.text.x = element_text(angle = 90))\n```\nThe acoustic space defined by the pairwise similarities can be projected into two axis using multidimensional scaling:\n\n```{r}\n#| eval: false\n\n# convert into distances\nxcor_dist <- 1 - xcor\n\n# multidimensional scaling\nmds <- cmdscale(xcor_dist, k = 2)\n\n# extract first 2 vectors\nxcor_mds <- data.frame(lbh_selec_table[, 1:2], mds = mds[, 1:2])\n\n# print\nxcor_mds\n```\n\n```{r}\n#| echo: false\n\n# convert into distances\nxcor_dist <- 1 - xcor\n\n# multidimensional scaling\nmds <- cmdscale(xcor_dist, k = 2)\n\n# extract first 2 vectors\nxcor_mds <- data.frame(lbh_selec_table[, 1:2], mds = mds[, 1:2])\nkbl <- kable(xcor_mds, align = \"c\", row.names = F,  format = \"html\")\n\nkbl <- kable_styling(kbl, bootstrap_options = c(\"striped\", \"hover\", \"condensed\", \"responsive\"), full_width = FALSE, font_size = 11)\n\nscroll_box(kbl, width = \"808px\",\nbox_css = \"border: 1px solid #ddd; padding: 5px; \", extra_css = NULL)\n\n```\n\nNote that the correlations are converted into distance by subtracting them from 1. This simplified acoustic space can also be easily visualized with a scatterplot: \n\n```{r}\nggplot(xcor_mds,\n       aes(\n         x = mds.1,\n         y = mds.2,\n         color = sound.files,\n         shape =  sound.files\n       )) +\n  geom_point(size = 5) +\n  scale_color_viridis_d(option = \"G\",\n                        end = 0.9,\n                        direction = -1) +\n  theme_classic() +\n  labs(x = \"MDS1\", y = \"MDS2\") +\n  theme(legend.position = \"right\")\n\n```\n\n::: {.alert .alert-info}\n<font size=\"5\">Exercise</font>\n\n- What does the argument `type` do and how does it affect the performance of the function?\n\n- What does the `pb` argument do?\n:::\n\n\n## Dynamic time warping\n\nIn time series analysis, time dynamics distortion (DTW) is one of the algorithms to measure the similarity between two time sequences, which may vary in their 'speed'. The sequences are nonlinearly 'warped' in the temporal dimension to determine a measure of their similarity independent of certain nonlinear variations in the temporal dimension.\n\n<img src=\"images/dtw.jpg\" alt=\"viewSpec\" width=\"640\"/>\n\n\nThe `freq_DTW()` function extracts the dominant frequency values as a time series and then calculates the acoustic dissimilarity using dynamic time warping. The function uses the `approx()` function to interpolate values between the dominant frequency measurements:\n\n```{r measure, eval = FALSE}\n\ndtw_dist <- freq_DTW(lbh_selec_table)\n\n```\n\n```{r measure 2, echo=FALSE}\n\ndtw_dist <- freq_DTW(lbh_selec_table)\n\nkbl <- kable(dtw_dist, align = \"c\", row.names = TRUE,  format = \"html\")\n\nkbl <- kable_styling(kbl, bootstrap_options = c(\"striped\", \"hover\", \"condensed\", \"responsive\"), full_width = FALSE, font_size = 11)\n\nscroll_box(kbl, width = \"808px\",\nbox_css = \"border: 1px solid #ddd; padding: 5px; \", extra_css = NULL)\n\n```\n\n\nThe function returns a matrix with paired dissimilarity values.\n\nIf `img = TRUE`, the function also produces image files with the spectrograms of the signals listed in the input data frame that shows the location of the dominant frequencies.\n\n```{r measure 3, eval = FALSE}\n\nfreq_DTW(lbh_selec_table, img = TRUE, col = \"red\", pch = 21, line = FALSE)\n\n```\n\n \n\n<img src=\"images/Phae.long1.wav-1-dfDTW.jpeg\" alt=\"dfdtw\" width=\"480\"/>\n\nFrequency contours can be calculated independently using the `freq_ts()` function. These contours can be adjusted manually with the `tailor_sels()` function.\n\nThe DTW distance matrix returned by the function can also be visualized as a heatmap:\n\n```{r}\n\n# present xcor as a heatmap using ggplot2\nggheatmap(dtw_dist) +\n  scale_fill_viridis_c(\n    option = \"G\",\n    direction = -1,\n    begin = 0.1,\n    end = 0.8\n  ) +\n  theme(axis.text.x = element_text(angle = 90))\n\n```\n\nSimilar to cross-correlation, the acoustic space defined by the pairwise DTW distances can be projected into two axis using multidimensional scaling:\n\n```{r}\n#| eval: false\n\n# multidimensional scaling\nmds <- cmdscale(dtw_dist, k = 2)\n\n# extract first 2 vectors\ndtw_mds <- data.frame(lbh_selec_table[, 1:2], mds = mds[, 1:2])\n\n# print\ndtw_mds\n```\n\n```{r}\n#| echo: false\n\n# multidimensional scaling\nmds <- cmdscale(dtw_dist, k = 2)\n\n# extract first 2 vectors\ndtw_mds <- data.frame(cc[, 1:2], mds = mds[, 1:2])\n\nkbl <- kable(dtw_mds, align = \"c\", row.names = F,  format = \"html\")\n\nkbl <- kable_styling(kbl, bootstrap_options = c(\"striped\", \"hover\", \"condensed\", \"responsive\"), full_width = FALSE, font_size = 11)\n\nscroll_box(kbl, width = \"808px\",\nbox_css = \"border: 1px solid #ddd; padding: 5px; \", extra_css = NULL)\n\n```\n\nAnd again, this simplified acoustic space can be easily visualized with a scatterplot: \n\n```{r}\nggplot(dtw_mds,\n       aes(\n         x = mds.1,\n         y = mds.2,\n         color = sound.files,\n         shape =  sound.files\n       )) +\n  geom_point(size = 5) +\n  scale_color_viridis_d(option = \"G\",\n                        end = 0.9,\n                        direction = -1) +\n  theme_classic() +\n  labs(x = \"MDS1\", y = \"MDS2\") +\n  theme(legend.position = \"right\")\n\n```\n\n\n::: {.alert .alert-info}\n<font size=\"5\">Exercise</font>\n\n \n\n-   What do the `length.out` argument in`freq_DTW()`?\n\n-   Calculate spectrographic cross-correlation for the inquiry calls from these individuals: `c(\"206433\", \"279470\", \"279533\", \"279820\")`. The extended selection table can be downloaded and read as follows:\n\n```{r, eval = FALSE}\n\ndownload.file(url = \"https://ndownloader.figshare.com/files/21167052\", \n destfile = \"./examples/iniquiry_calls.RDS\")\n\niniquiry_calls <- readRDS(\"./examples/iniquiry_calls.RDS\")\n```\n\n-   We can use a binary matrix to represent call membership. It has to be a pairwise matrix in which 0 denotes pairs of calls that belong to the same individual and 1 pairs that belong to different individuals. The function `binary_triangular_matrix` from the package *PhenotypeSpace* creates this type of matrix for representing call membership at the individual level:\n\n```{r, eval = FALSE}\n\nbi_mat <- binary_triangular_matrix(iniquiry_calls$indiv)\n\n```\n\nCompare dissimilarity from cross-correlation (1 - correlation matrix) with individual call membership matrix using Mantel test (you can use `vegan::mantel()`)\n\n \n\n-   Do the same test but this time using cepstral coefficient cross-correlation (hint: see argument \"type\")\n\n-   Do the same test using dynamic time warping distances\n:::\n\n \n\n## Additional measures\n\n### Signal-to-noise ratio\n\n`sig2noise()` measures this parameter. The duration of the margin in which to measure the background noise must be provided (`mar` argument):\n\n```{r, eval = FALSE}\n\nsnr <- sig2noise(X = lbh_selec_table, mar = 0.06)\n\nsnr\n\n```\n\n```{r, eval= TRUE, echo=FALSE, warning=FALSE, message=FALSE}\n\nsnr <- sig2noise(X = lbh_selec_table, mar = 0.06)\n\nkbl <- kable(snr, align = \"c\", row.names = F,  format = \"html\")\n\nkable_styling(kbl, bootstrap_options = c(\"striped\", \"hover\", \"condensed\", \"responsive\"), full_width = FALSE, font_size = 11)\n\n\n```\n\n \n\n### Inflections\n\nInflections in this case are defined as changes in the slope of a frequency contour. They can be used as a measure of frequency modulation. They can be calculated using the `inflections()` function on previously measured frequency contours:\n\n```{r, eval = FALSE}\n\ncntrs <- freq_ts(X = lbh_selec_table)\n\ninflcts <- inflections(cntrs)\n\n```\n\n```{r, eval= TRUE, echo=FALSE, warning=FALSE, message=FALSE}\n\ncntrs <- freq_ts(X = lbh_selec_table)\n\ninflcts <- inflections(cntrs)\n\n\nkbl <- kable(inflcts, align = \"c\", row.names = F,  format = \"html\")\n\nkable_styling(kbl, bootstrap_options = c(\"striped\", \"hover\", \"condensed\", \"responsive\"), full_width = FALSE, font_size = 11)\n\n\n```\n\n \n\n### Calculates parameters at higher levels of organization\n\nVocalizations can be organized above the basic signal units like in long repertoire songs or multi-syllable calls. We can calculate average or extreme values of acoustic parameters of the sub-units for these higher levels of organization using the function `song_analysis()`:\n\n```{r, eval = FALSE}\n\n# add a 'song' column\nlbh_selec_table$song <- rep(1:4, each = 3)[1:11]\n\n# measure default parameters\nsong_analysis(X = lbh_selec_table, song_colm = \"song\", parallel = 1, pb = TRUE)\n```\n\n```{r, eval= TRUE, echo=FALSE, warning=FALSE, message=FALSE}\n\n\n# add a 'song' column\nlbh_selec_table$song <- rep(1:4, each = 3)[1:11]\n\n# measure default parameters\nW <- song_analysis(X = lbh_selec_table, song_colm = \"song\", parallel = 1, pb = TRUE)\n\nkbl <- kable(W, align = \"c\", row.names = F,  format = \"html\")\n\nkable_styling(kbl, bootstrap_options = c(\"striped\", \"hover\", \"condensed\", \"responsive\"), full_width = FALSE, font_size = 11)\n\n```\n\nThis can also be done on parameters extracted from other functions:\n\n```{r eval = FALSE}\n\n# measure acoustic parameters\nsp <- spectro_analysis(lbh_selec_table[1:8, ], bp = c(1, 11), 300, fast = TRUE)\n\nsp <- merge(sp, lbh_selec_table[1:8, ], by = c(\"sound.files\", \"selec\"))\n\n# caculate song-level parameters for all numeric parameters\nsong_analysis(X = sp, song_colm = \"song\", parallel = 1, pb = TRUE)\n\n\n```\n\n```{r, eval= TRUE, echo=FALSE, warning=FALSE, message=FALSE}\n\nwarbleR_options(wav.path = \"./examples\")\n\n# add a 'song' column\nlbh_selec_table$song <- rep(1:4, each = 3)[1:11]\n\n# measure acoustic parameters\nsp <- spectro_analysis(lbh_selec_table[1:8, ], bp = c(1, 11), 300, fast = TRUE)\n\nsp <- merge(sp, lbh_selec_table[1:8, ], by = c(\"sound.files\", \"selec\"))\n\n# caculate song-level parameters for all numeric parameters\nW <- song_analysis(X = sp, song_colm = \"song\", parallel = 1, pb = TRUE)\n\nkbl <- kable(W, align = \"c\", row.names = F,  format = \"html\")\n\nkbl <- kable_styling(kbl, bootstrap_options = c(\"striped\", \"hover\", \"condensed\", \"responsive\"), full_width = FALSE, font_size = 11)\n\nscroll_box(kbl, width = \"808px\",\nbox_css = \"border: 1px solid #ddd; padding: 5px; \", extra_css = NULL)\n\n\n```\n\n \n\nCalculate song-level parameters selecting parameters with 'mean_colm':\n\n```{r, eval = FALSE}\n\n# caculate song-level parameters selecting parameters with mean_colm\nsong_analysis(X = sp, song_colm = \"song\",mean_colm = c(\"dfrange\", \"duration\"), parallel = 1, pb = TRUE)\n\n```\n\n```{r, eval= TRUE, echo=FALSE, warning=FALSE, message=FALSE}\n\nW <- song_analysis(X = sp, song_colm = \"song\",mean_colm = c(\"dfrange\", \"duration\"), parallel = 1, pb = TRUE)\n\nkbl <- kable(W, align = \"c\", row.names = F,  format = \"html\")\n\nkbl <- kable_styling(kbl, bootstrap_options = c(\"striped\", \"hover\", \"condensed\", \"responsive\"), full_width = FALSE, font_size = 11)\n\nscroll_box(kbl, width = \"808px\",\nbox_css = \"border: 1px solid #ddd; padding: 5px; \", extra_css = NULL)\n\n\n\n```\n\n \n\nCalculate song-level parameters for selecting parameters with 'mean_colm', 'max_colm' and 'min_colm' and weighted by duration:\n\n```{r, eval = FALSE}\n\nsong_analysis(X = sp, weight = \"duration\", song_colm = \"song\",\nmean_colm =  c(\"dfrange\", \"duration\"), min_colm =  \"mindom\", max_colm = \"maxdom\", \n  parallel = 1, pb = TRUE)\n\n\n```\n\n```{r, eval= TRUE, echo=FALSE, warning=FALSE, message=FALSE}\n\nW <- song_analysis(X = sp, weight = \"duration\", song_colm = \"song\",\nmean_colm =  c(\"dfrange\", \"duration\"), min_colm =  \"mindom\", max_colm = \"maxdom\", \n  parallel = 1, pb = TRUE)\n\nkbl <- kable(W, align = \"c\", row.names = F,  format = \"html\")\n\nkbl <- kable_styling(kbl, bootstrap_options = c(\"striped\", \"hover\", \"condensed\", \"responsive\"), full_width = FALSE, font_size = 11)\n\nscroll_box(kbl, width = \"808px\",\nbox_css = \"border: 1px solid #ddd; padding: 5px; \", extra_css = NULL)\n\n\n```\n\n \n\n \n\n::: {.alert .alert-info}\n<font size=\"5\">Exercise</font>\n\n \n\n-   Spix's disc-winged bats (*Thyroptera tricolor*) its a Neotropical species that uses a specific call type to reply to social mates looking for their roosts. Those 'response' calls look like this:\n\n \n\n<img src=\"images/response_thyroptera2.png\" alt=\"viewSpec\" width=\"640\"/>\n\n \n\nAn extended selection table with response calls can be read from github as follows:\n\n```{r, eval = FALSE, echo = FALSE}\n\ndownload.file(url = \"https://github.com/maRce10/PR_BIR_2024/raw/master/examples/response_calls.RDS\", \n destfile = \"./examples/response_calls.RDS\")\n\nresponse_calls <- readRDS(\"./examples/response_calls.RDS\")\n\nsp_resp <- spectro_analysis(response_calls)\n\nresponse_calls <- cbind(response_calls, sp_resp[, -c(1, 2)])\n\n\nsp_resp_by_call <- song_analysis(response_calls, song_colm = \"call\")\n\n```\n\n```{r, eval = FALSE}\n\ndownload.file(url = \"https://github.com/maRce10/PR_BIR_2024/raw/master/examples/response_calls.RDS\", \n destfile = \"./examples/response_calls.RDS\")\n\nresponse_calls <- readRDS(\"./examples/response_calls.RDS\")\n\n\n```\n\n \n\n-   Calculate spectrographic parameters (`spectro_analysis()`) for the Spix's disc-winged bat response calls.\n\n-   Summarize parameters by call (`song_analysis()`). To do that you should add the column 'start', 'end' and 'call' to the output of `spectro_analysis()`\n:::\n\n \n\n------------------------------------------------------------------------\n\n## References\n\n1.  Araya-Salas M, A Hernández-Pinsón N Rojas, G Chaverri. (2020). [Ontogeny of an interactive call-and-response system in Spix's disc-winged bats. Animal Behaviour.](https://marce10.github.io/uploads/m-araya-salas-2020.pdf)\n\n2.  Araya-Salas M, Smith-Vidaurre G (2017) [warbleR: An R package to streamline analysis of animal acoustic signals. Methods Ecol Evol 8:184--191.](https://marce10.github.io/uploads/araya-salas-2017-f.pdf)\n\n3.  Lyon, R. H., & Ordubadi, A. (1982). Use of cepstra in acoustical signal analysis. Journal of Mechanical Design, 104(2), 303-306.\n\n4.  Salamon, J., Jacoby, C., & Bello, J. P. (2014). A dataset and taxonomy for urban sound research. In Proceedings of the 22nd ACM international conference on Multimedi. 1041-1044.\n\n<font size=\"4\">Session information</font>\n\n```{r session info, echo=F}\n\nsessionInfo()\n\n```\n","srcMarkdownNoYaml":"\n\n \n\n\n```{r clean session, echo=F, warning=FALSE, message=FALSE}\n\nknitr::opts_chunk$set(dpi = 200)\n\nlibrary(warbleR)\nlibrary(kableExtra)\nlibrary(viridis)\nlibrary(ggplot2)\nlibrary(ggalign)\nlibrary(PhenotypeSpace)\n```\n\n\n::: {.alert .alert-info}\n## **Objetives** {.unnumbered .unlisted}\n\n-   Learn the different methods available to quantify acoustic structure\n\n-   Understand their pros and cons\n\n-   Learn how to apply them in R\n:::\n\n \n\nAcoustic signals are multidimensional traits; they vary complexly in time, frequency, amplitude and combinations of these dimensions. Generally, in biology we want to measure aspects of acoustic signals that vary in response to the factors predicted by our hypotheses. In some cases we even lack predictions for specific acoustic parameters and we need to evaluate the relative similarity between the variants of a signal in a population. These analyses require a diversity of tools for quantifying the multiple dimensions in which we can decompose the signals.\n\nThe **warbleR** package is designed to quantify the acoustic structure of a population of signals using 4 main methods of analysis. 2 of them are absolute measures of the structure:\n\n-   Spectrographic parameters\n-   Statistical descriptors of cepstral coefficients\n\nThe other 2 provide a relative similarity value between signals:\n\n-   Spectrographic cross-correlation\n-   Dynamic time warping\n\n\n::: {.alert .alert-warning}\n## Example data\n\nWe will use the example data `lbh_selec_table` that comes with the package. This data frame contains the selection table of 11 long-billed hermit (*Phaethornis longirostris*) songs. The selection table is a data frame with the following columns:\n\n```{r}\n#| eval=FALSE\n\nlibrary(warbleR)\nlibrary(viridis)\nlibrary(ggplot2)\nlibrary(ggalign)\nlibrary(PhenotypeSpace)\n\nwarbleR_options(wav.path = \"./examples/\", flim = c(1, 10), wl = 200, ovlp = 90, pb = FALSE)\n\ndata(lbh_selec_table)\n\nlbh_selec_table\n```\n\n\n```{r, echo=FALSE}\n\nwarbleR_options(wav.path = \"./examples/\", flim = c(1, 10), wl = 200, ovlp = 90, pb = FALSE)\n\ndata(lbh_selec_table)\n\nkbl <- kable(lbh_selec_table, align = \"c\", row.names = F,  format = \"html\")\n\nkbl <- kable_styling(kbl, bootstrap_options = c(\"striped\", \"hover\", \"condensed\", \"responsive\"), full_width = FALSE, font_size = 11)\n\nscroll_box(kbl, width = \"808px\",\nbox_css = \"border: 1px solid #ddd; padding: 5px; \", extra_css = NULL)\n\n```\n\nThis is a catalog (made with the `catalog()` function) with the spectrograms of all sounds referenced in the selection table (*the function saves the image file(s) in the folder in which the sound files are found*):\n\n```{r}\n#| eval=FALSE\n\n# make a color pallete for tagging spectrograms\ntag_pal <- function(x)\n  mako(x,\n       alpha = 0.6,\n       begin = 0.1,\n       end = 0.9)\n\n# plot all annotation spectrograms in a catalog\ncatalog(\n  lbh_selec_table,\n  flim = c(1.5, 10),\n  wl = 200,\n  ovlp = 90,\n  nrow = 4,\n  ncol = 3,\n  width = 12,\n  height = 8,\n  pb = FALSE,\n  same.time.scale = TRUE,\n  mar = 0.02,\n  pal = mako,\n  collevels = seq(-120, 0, 1),\n  group.tag = \"sound.files\",\n  tag.pal = list(tag_pal),\n  spec.mar = 0.6,\n  box = FALSE,\n  res = 200\n)\n\n\n```\n\n\n```{r}\n#| echo: false\n#| out.width: \"100%\"\n\nknitr::include_graphics(\"./images/Catalog_p1.jpeg\")\n\n```\n\n  It is clear that each sound file contains a different variant of the song. We will use these data to illustrate the different methods of acoustic structure analysis available in **warbleR**.\n\n:::\n\n## Spectrographic parameters\n\nThe `spectro_analysis()` function measures the following spectrographic parameters related to amplitude distributions in time and frequency, descriptors of the fundamental and dominant frequency contours and descriptors of harmonic content:\n\n \n\n::: {.alert .alert-success}\n#### Time and frequency (measured on the spectrogram)\n\n-   duration: signal length (in s)\n\n-   meanfreq: medium frequency. Weighted average frequency by amplitude (in kHz)\n\n-   sd: standard deviation of the amplitude weighted frequency\n\n \n\n#### Energy distribution across frequencies (measured on the power spetrum)\n\n-   freq.median: medium frequency. The frequency at which the signal is divided into two frequency intervals of equal energy (in kHz)\n\n-   freq.Q25: first frequency quartile. The frequency at which the signal is divided into two frequency ranges of 25% and 75% energy respectively (in kHz)\n\n-   freq.Q75: third frequency quartile. The frequency at which the signal is divided into two frequency ranges of 75% and 25% energy respectively (in kHz)\n\n-   freq.IQR: interquartile frequency range. Frequency range between 'freq.Q25' and 'freq.Q75' (in kHz)\n\n-   sp.ent: spectral entropy. Frequency spectrum energy distribution. Pure tone \\~ 0; loud \\~ 1\n\n-   peakf: peak frequency. Frequency with the highest energy. This parameter can take a considerable amount of time to measure. Only generated if `fast = FALSE`. It provides a more accurate measurement of the peak frequency than `meanpeakf()`, but can be more easily affected by background noise\n\n-   meanpeakf: mean peak frequency. Frequency with the highest energy of the medium frequency spectrum (see `meanspec()`). Typically more consistent than `peakf()`\n\n \n\n#### Energy distribution across time (measured on the amplitude envelope)\n\n-   time.median: average time. The time at which the signal is divided into two time intervals of equal energy (in s)\n\n-   time.Q25: first quartile. The time in which the signal is divided into two time intervals of 25% and 75% energy respectively (in s)\n\n-   time Q75: third quartile. The time in which the signal is divided into two time intervals of 75% and 25% energy respectively (in s)\n\n-   time.IQR: interquartile time range. Time range between 'time.Q25' and 'time.Q75' (in s)\n\n-   skew (skewness): Asymmetry of the amplitude distribution\n\n-   kurt (kurtosis): measure of \"peakedness\" of the spectrum\n\n-   time.ent: temporary entropy. Energy distribution in the time envelope. Pure tone \\~ 0; loud \\~ 1\n\n-   entropy: Product of the spectral and temporal entropy: `sp.ent * time.ent`\n\n-   sfm: spectral flatness. Similar to sp.ent (pure tone \\~ 0; loud \\~ 1)\n\n \n\n#### Fundamental frequency contour descriptors (measured on the spectrogram)\n\n-   meanfun: average of the fundamental frequency measured through the signal\n\n-   minfun: minimum fundamental frequency measured through the signal\n\n-   maxfun: maximum fundamental frequency measured through the signal\n\n \n\n#### Dominant frequency contour descriptors (measured on the spectrogram)\n\n-   meandom: average of the dominant frequency measured through the signal\n\n-   mindom: minimum dominant frequency measured through the signal\n\n-   maxdom: maximum of the dominant frequency measured through the signal\n\n-   dfrange: dominant frequency range measured through the signal\n\n-   modindx: modulation index. Calculated as the cumulative absolute difference between adjacent measurements of dominant frequencies divided by the dominant frequency range. 1 means that the signals are not modulated\n\n-   startdom: measurement of dominant frequency at the beginning of the signal\n\n-   enddom: dominant frequency measurement at the end of the signal\n\n-   dfslope: pending change in the dominant frequency over time (`(enddom-startdom)/duration`). The units are kHz/s\n\n \n\n#### Harmonic content descriptors (measured on the spectrogram)\n\n-   hn_freq: average frequency of the upper 'n' harmonics (kHz) The number of harmonics is defined with the argument 'nharmonics'\n\n-   hn_width: average bandwidth of the upper 'n' harmonics (kHz) (see analysis). The number of harmonics is defined with the argument 'nharmonics'\n\n-   harmonics: the amount of energy in higher harmonics. The number of harmonics is defined with the argument 'nharmonics'\n\n-   HNR: relationship between harmonics and noise (dB). A measure of harmonic content\n:::\n\n \n\nWe can easily measure them as follows:\n\n```{r, eval= FALSE, echo=TRUE, warning=FALSE, message=FALSE}\n\n# load examples\ndata(\"lbh_selec_table\")\n\nsp <- spectro_analysis(lbh_selec_table)\n\nsp\n\n```\n\n```{r, echo=FALSE}\n\nsp <- spectro_analysis(lbh_selec_table)\n\nkbl <- kable(sp, align = \"c\", row.names = F,  format = \"html\")\n\nkbl <- kable_styling(kbl, bootstrap_options = c(\"striped\", \"hover\", \"condensed\", \"responsive\"), full_width = FALSE, font_size = 11)\n\nscroll_box(kbl, width = \"808px\",\nbox_css = \"border: 1px solid #ddd; padding: 5px; \", extra_css = NULL)\n\n```\n\nWe can reduce the dimensionality using Principal component analysis (PCA):\n```{r}\n#| eval: false\n\n# run principal components\npca <- prcomp(sp[, -c(1, 2)], scale = TRUE)\n\n# extract first 2 PCs\nsp_pcs <- data.frame(sp[, 1:2], pca$x[, 1:2])\n\nsp_pcs\n```\n```{r}\n#| echo: false\n\n# run principal components\npca <- prcomp(sp[, -c(1, 2)], scale = TRUE)\n\n# extract first 2 PCs\nsp_pcs <- data.frame(sp[, 1:2], pca$x[, 1:2])\n\nkbl <- kable(sp_pcs, align = \"c\", row.names = F,  format = \"html\")\n\nkbl <- kable_styling(kbl, bootstrap_options = c(\"striped\", \"hover\", \"condensed\", \"responsive\"), full_width = FALSE, font_size = 11)\n\nscroll_box(kbl, width = \"808px\",\nbox_css = \"border: 1px solid #ddd; padding: 5px; \", extra_css = NULL)\n\n```\n\nThe acoustic space described by this data can be easily visualized with a scatterplot: \n\n\n```{r}\nggplot(sp_pcs,\n       aes(\n         x = PC1,\n         y = PC2,\n         color = sound.files,\n         shape =  sound.files\n       )) +\n  geom_point(size = 5) +\n  scale_color_viridis_d(option = \"G\",\n                        end = 0.9,\n                        direction = -1) +\n  theme_classic() +\n  labs(x = \"PC1\", y = \"PC2\") +\n  theme(legend.position = \"right\")\n\n```\n\n\n\n::: {.alert .alert-info}\n<font size=\"5\">Exercise</font>\n\n\n-   The parameters related to harmonic content were not calculated. How can we do that?\n\n-   How does measuring harmonic content affect performance?\n\n-   What does the argument 'threshold' do?\n:::\n\n \n\n## Statistical descriptors of cepstral coefficients\n\nThese coefficients were designed to decompose the sounds in a similar way than the human auditory system in order to facilitate speech recognition. The central idea is to compress the acoustic data maintaining only relevant information for the detection of phonetic differences. The principle refers to human hearing using the Mel logarithmic scale whose definition is based on how the human ear perceives frequency and loudness (Sueur 2018). Cepstral coefficients are literally defined as \"the result of a cosine transformation of the real logarithm of short-term energy spectra expressed on a Mel frequency scale\".\n\nThe descriptive statistics that are extracted from the cepstral coefficients are: minimum, maximum, average, median, asymmetry, kurtosis and variance. It also returns the mean and variance for the first and second derivatives of the coefficients. These parameters are commonly used in the processing and detection of acoustic signals (e.g. Salamon et al 2014). They have been widely used for human voice analysis and its use has extended to mammalian bioacoustics, although they also appear to be useful for quantifying the structure of acoustic signals in other groups.\n\nIn **warbleR** we can calculate statistical descriptors of cepstral coefficients with the `mfcc_stats()` function:\n\n```{r, eval = FALSE}\n\ncc <- mfcc_stats(X = lbh_selec_table)\n\ncc\n\n```\n\n```{r, eval= TRUE, echo=FALSE, warning=FALSE, message=FALSE}\n\ncc <- mfcc_stats(X = lbh_selec_table)\n\nkbl <- kable(cc, align = \"c\", row.names = F,  format = \"html\")\n\nkbl <- kable_styling(kbl, bootstrap_options = c(\"striped\", \"hover\", \"condensed\", \"responsive\"), full_width = FALSE, font_size = 11)\n\nscroll_box(kbl, width = \"808px\",\nbox_css = \"border: 1px solid #ddd; padding: 5px; \", extra_css = NULL)\n\n```\n\nSimilarly to the spectrographic parameters, we can reduce the dimensionality of the cepstral coefficients using PCA:\n\n```{r}\n#| eval: false\n\n# run principal components\npca <- prcomp(cc[, -c(1, 2)], scale = TRUE)\n\n# extract first 2 PCs\ncc_pcs <- data.frame(cc[, 1:2], pca$x[, 1:2])\n\ncc_pcs\n```\n\n```{r}\n#| echo: false\n\n# run principal components\npca <- prcomp(cc[, -c(1, 2)], scale = TRUE)\n\n# extract first 2 PCs\ncc_pcs <- data.frame(cc[, 1:2], pca$x[, 1:2])\n\nkbl <- kable(cc_pcs, align = \"c\", row.names = F,  format = \"html\")\n\nkbl <- kable_styling(kbl, bootstrap_options = c(\"striped\", \"hover\", \"condensed\", \"responsive\"), full_width = FALSE, font_size = 11)\n\nscroll_box(kbl, width = \"808px\",\nbox_css = \"border: 1px solid #ddd; padding: 5px; \", extra_css = NULL)\n\n```\n\nAgain, this simplified acoustic space can be easily visualized with a scatterplot: \n\n```{r}\nggplot(cc_pcs,\n       aes(\n         x = PC1,\n         y = PC2,\n         color = sound.files,\n         shape =  sound.files\n       )) +\n  geom_point(size = 5) +\n  scale_color_viridis_d(option = \"G\",\n                        end = 0.9,\n                        direction = -1) +\n  theme_classic() +\n  labs(x = \"PC1\", y = \"PC2\") +\n  theme(legend.position = \"right\")\n\n```\n\n## (Spectrographic) cross correlation\n\nThis analysis correlates the amplitude values in the frequency and time space pairwise for all signals in a selection table. The correlation represents a measure of spectrographic similarity of the signals:\n\n```{r, eval = FALSE}\n\nxcor <- cross_correlation(X = lbh_selec_table)\n\nxcor\n```\n\n```{r, echo=FALSE}\n\nxcor <- cross_correlation(X = lbh_selec_table)\n\nkbl <- kable(xcor, align = \"c\", row.names = TRUE,  format = \"html\")\n\nkbl <- kable_styling(kbl, bootstrap_options = c(\"striped\", \"hover\", \"condensed\", \"responsive\"), full_width = FALSE, font_size = 11)\n\nscroll_box(kbl, width = \"808px\",\nbox_css = \"border: 1px solid #ddd; padding: 5px; \", extra_css = NULL)\n\n```\n\n\nThe similarity matrix returned by the function can be visualized as a heatmap:\n\n```{r}\n\n# present xcor as a heatmap using ggplot2\nggheatmap(xcor) +\n  scale_fill_viridis_c(\n    option = \"G\",\n    direction = 1,\n    begin = 0.1,\n    end = 0.8\n  ) +\n  theme(axis.text.x = element_text(angle = 90))\n```\nThe acoustic space defined by the pairwise similarities can be projected into two axis using multidimensional scaling:\n\n```{r}\n#| eval: false\n\n# convert into distances\nxcor_dist <- 1 - xcor\n\n# multidimensional scaling\nmds <- cmdscale(xcor_dist, k = 2)\n\n# extract first 2 vectors\nxcor_mds <- data.frame(lbh_selec_table[, 1:2], mds = mds[, 1:2])\n\n# print\nxcor_mds\n```\n\n```{r}\n#| echo: false\n\n# convert into distances\nxcor_dist <- 1 - xcor\n\n# multidimensional scaling\nmds <- cmdscale(xcor_dist, k = 2)\n\n# extract first 2 vectors\nxcor_mds <- data.frame(lbh_selec_table[, 1:2], mds = mds[, 1:2])\nkbl <- kable(xcor_mds, align = \"c\", row.names = F,  format = \"html\")\n\nkbl <- kable_styling(kbl, bootstrap_options = c(\"striped\", \"hover\", \"condensed\", \"responsive\"), full_width = FALSE, font_size = 11)\n\nscroll_box(kbl, width = \"808px\",\nbox_css = \"border: 1px solid #ddd; padding: 5px; \", extra_css = NULL)\n\n```\n\nNote that the correlations are converted into distance by subtracting them from 1. This simplified acoustic space can also be easily visualized with a scatterplot: \n\n```{r}\nggplot(xcor_mds,\n       aes(\n         x = mds.1,\n         y = mds.2,\n         color = sound.files,\n         shape =  sound.files\n       )) +\n  geom_point(size = 5) +\n  scale_color_viridis_d(option = \"G\",\n                        end = 0.9,\n                        direction = -1) +\n  theme_classic() +\n  labs(x = \"MDS1\", y = \"MDS2\") +\n  theme(legend.position = \"right\")\n\n```\n\n::: {.alert .alert-info}\n<font size=\"5\">Exercise</font>\n\n- What does the argument `type` do and how does it affect the performance of the function?\n\n- What does the `pb` argument do?\n:::\n\n\n## Dynamic time warping\n\nIn time series analysis, time dynamics distortion (DTW) is one of the algorithms to measure the similarity between two time sequences, which may vary in their 'speed'. The sequences are nonlinearly 'warped' in the temporal dimension to determine a measure of their similarity independent of certain nonlinear variations in the temporal dimension.\n\n<img src=\"images/dtw.jpg\" alt=\"viewSpec\" width=\"640\"/>\n\n\nThe `freq_DTW()` function extracts the dominant frequency values as a time series and then calculates the acoustic dissimilarity using dynamic time warping. The function uses the `approx()` function to interpolate values between the dominant frequency measurements:\n\n```{r measure, eval = FALSE}\n\ndtw_dist <- freq_DTW(lbh_selec_table)\n\n```\n\n```{r measure 2, echo=FALSE}\n\ndtw_dist <- freq_DTW(lbh_selec_table)\n\nkbl <- kable(dtw_dist, align = \"c\", row.names = TRUE,  format = \"html\")\n\nkbl <- kable_styling(kbl, bootstrap_options = c(\"striped\", \"hover\", \"condensed\", \"responsive\"), full_width = FALSE, font_size = 11)\n\nscroll_box(kbl, width = \"808px\",\nbox_css = \"border: 1px solid #ddd; padding: 5px; \", extra_css = NULL)\n\n```\n\n\nThe function returns a matrix with paired dissimilarity values.\n\nIf `img = TRUE`, the function also produces image files with the spectrograms of the signals listed in the input data frame that shows the location of the dominant frequencies.\n\n```{r measure 3, eval = FALSE}\n\nfreq_DTW(lbh_selec_table, img = TRUE, col = \"red\", pch = 21, line = FALSE)\n\n```\n\n \n\n<img src=\"images/Phae.long1.wav-1-dfDTW.jpeg\" alt=\"dfdtw\" width=\"480\"/>\n\nFrequency contours can be calculated independently using the `freq_ts()` function. These contours can be adjusted manually with the `tailor_sels()` function.\n\nThe DTW distance matrix returned by the function can also be visualized as a heatmap:\n\n```{r}\n\n# present xcor as a heatmap using ggplot2\nggheatmap(dtw_dist) +\n  scale_fill_viridis_c(\n    option = \"G\",\n    direction = -1,\n    begin = 0.1,\n    end = 0.8\n  ) +\n  theme(axis.text.x = element_text(angle = 90))\n\n```\n\nSimilar to cross-correlation, the acoustic space defined by the pairwise DTW distances can be projected into two axis using multidimensional scaling:\n\n```{r}\n#| eval: false\n\n# multidimensional scaling\nmds <- cmdscale(dtw_dist, k = 2)\n\n# extract first 2 vectors\ndtw_mds <- data.frame(lbh_selec_table[, 1:2], mds = mds[, 1:2])\n\n# print\ndtw_mds\n```\n\n```{r}\n#| echo: false\n\n# multidimensional scaling\nmds <- cmdscale(dtw_dist, k = 2)\n\n# extract first 2 vectors\ndtw_mds <- data.frame(cc[, 1:2], mds = mds[, 1:2])\n\nkbl <- kable(dtw_mds, align = \"c\", row.names = F,  format = \"html\")\n\nkbl <- kable_styling(kbl, bootstrap_options = c(\"striped\", \"hover\", \"condensed\", \"responsive\"), full_width = FALSE, font_size = 11)\n\nscroll_box(kbl, width = \"808px\",\nbox_css = \"border: 1px solid #ddd; padding: 5px; \", extra_css = NULL)\n\n```\n\nAnd again, this simplified acoustic space can be easily visualized with a scatterplot: \n\n```{r}\nggplot(dtw_mds,\n       aes(\n         x = mds.1,\n         y = mds.2,\n         color = sound.files,\n         shape =  sound.files\n       )) +\n  geom_point(size = 5) +\n  scale_color_viridis_d(option = \"G\",\n                        end = 0.9,\n                        direction = -1) +\n  theme_classic() +\n  labs(x = \"MDS1\", y = \"MDS2\") +\n  theme(legend.position = \"right\")\n\n```\n\n\n::: {.alert .alert-info}\n<font size=\"5\">Exercise</font>\n\n \n\n-   What do the `length.out` argument in`freq_DTW()`?\n\n-   Calculate spectrographic cross-correlation for the inquiry calls from these individuals: `c(\"206433\", \"279470\", \"279533\", \"279820\")`. The extended selection table can be downloaded and read as follows:\n\n```{r, eval = FALSE}\n\ndownload.file(url = \"https://ndownloader.figshare.com/files/21167052\", \n destfile = \"./examples/iniquiry_calls.RDS\")\n\niniquiry_calls <- readRDS(\"./examples/iniquiry_calls.RDS\")\n```\n\n-   We can use a binary matrix to represent call membership. It has to be a pairwise matrix in which 0 denotes pairs of calls that belong to the same individual and 1 pairs that belong to different individuals. The function `binary_triangular_matrix` from the package *PhenotypeSpace* creates this type of matrix for representing call membership at the individual level:\n\n```{r, eval = FALSE}\n\nbi_mat <- binary_triangular_matrix(iniquiry_calls$indiv)\n\n```\n\nCompare dissimilarity from cross-correlation (1 - correlation matrix) with individual call membership matrix using Mantel test (you can use `vegan::mantel()`)\n\n \n\n-   Do the same test but this time using cepstral coefficient cross-correlation (hint: see argument \"type\")\n\n-   Do the same test using dynamic time warping distances\n:::\n\n \n\n## Additional measures\n\n### Signal-to-noise ratio\n\n`sig2noise()` measures this parameter. The duration of the margin in which to measure the background noise must be provided (`mar` argument):\n\n```{r, eval = FALSE}\n\nsnr <- sig2noise(X = lbh_selec_table, mar = 0.06)\n\nsnr\n\n```\n\n```{r, eval= TRUE, echo=FALSE, warning=FALSE, message=FALSE}\n\nsnr <- sig2noise(X = lbh_selec_table, mar = 0.06)\n\nkbl <- kable(snr, align = \"c\", row.names = F,  format = \"html\")\n\nkable_styling(kbl, bootstrap_options = c(\"striped\", \"hover\", \"condensed\", \"responsive\"), full_width = FALSE, font_size = 11)\n\n\n```\n\n \n\n### Inflections\n\nInflections in this case are defined as changes in the slope of a frequency contour. They can be used as a measure of frequency modulation. They can be calculated using the `inflections()` function on previously measured frequency contours:\n\n```{r, eval = FALSE}\n\ncntrs <- freq_ts(X = lbh_selec_table)\n\ninflcts <- inflections(cntrs)\n\n```\n\n```{r, eval= TRUE, echo=FALSE, warning=FALSE, message=FALSE}\n\ncntrs <- freq_ts(X = lbh_selec_table)\n\ninflcts <- inflections(cntrs)\n\n\nkbl <- kable(inflcts, align = \"c\", row.names = F,  format = \"html\")\n\nkable_styling(kbl, bootstrap_options = c(\"striped\", \"hover\", \"condensed\", \"responsive\"), full_width = FALSE, font_size = 11)\n\n\n```\n\n \n\n### Calculates parameters at higher levels of organization\n\nVocalizations can be organized above the basic signal units like in long repertoire songs or multi-syllable calls. We can calculate average or extreme values of acoustic parameters of the sub-units for these higher levels of organization using the function `song_analysis()`:\n\n```{r, eval = FALSE}\n\n# add a 'song' column\nlbh_selec_table$song <- rep(1:4, each = 3)[1:11]\n\n# measure default parameters\nsong_analysis(X = lbh_selec_table, song_colm = \"song\", parallel = 1, pb = TRUE)\n```\n\n```{r, eval= TRUE, echo=FALSE, warning=FALSE, message=FALSE}\n\n\n# add a 'song' column\nlbh_selec_table$song <- rep(1:4, each = 3)[1:11]\n\n# measure default parameters\nW <- song_analysis(X = lbh_selec_table, song_colm = \"song\", parallel = 1, pb = TRUE)\n\nkbl <- kable(W, align = \"c\", row.names = F,  format = \"html\")\n\nkable_styling(kbl, bootstrap_options = c(\"striped\", \"hover\", \"condensed\", \"responsive\"), full_width = FALSE, font_size = 11)\n\n```\n\nThis can also be done on parameters extracted from other functions:\n\n```{r eval = FALSE}\n\n# measure acoustic parameters\nsp <- spectro_analysis(lbh_selec_table[1:8, ], bp = c(1, 11), 300, fast = TRUE)\n\nsp <- merge(sp, lbh_selec_table[1:8, ], by = c(\"sound.files\", \"selec\"))\n\n# caculate song-level parameters for all numeric parameters\nsong_analysis(X = sp, song_colm = \"song\", parallel = 1, pb = TRUE)\n\n\n```\n\n```{r, eval= TRUE, echo=FALSE, warning=FALSE, message=FALSE}\n\nwarbleR_options(wav.path = \"./examples\")\n\n# add a 'song' column\nlbh_selec_table$song <- rep(1:4, each = 3)[1:11]\n\n# measure acoustic parameters\nsp <- spectro_analysis(lbh_selec_table[1:8, ], bp = c(1, 11), 300, fast = TRUE)\n\nsp <- merge(sp, lbh_selec_table[1:8, ], by = c(\"sound.files\", \"selec\"))\n\n# caculate song-level parameters for all numeric parameters\nW <- song_analysis(X = sp, song_colm = \"song\", parallel = 1, pb = TRUE)\n\nkbl <- kable(W, align = \"c\", row.names = F,  format = \"html\")\n\nkbl <- kable_styling(kbl, bootstrap_options = c(\"striped\", \"hover\", \"condensed\", \"responsive\"), full_width = FALSE, font_size = 11)\n\nscroll_box(kbl, width = \"808px\",\nbox_css = \"border: 1px solid #ddd; padding: 5px; \", extra_css = NULL)\n\n\n```\n\n \n\nCalculate song-level parameters selecting parameters with 'mean_colm':\n\n```{r, eval = FALSE}\n\n# caculate song-level parameters selecting parameters with mean_colm\nsong_analysis(X = sp, song_colm = \"song\",mean_colm = c(\"dfrange\", \"duration\"), parallel = 1, pb = TRUE)\n\n```\n\n```{r, eval= TRUE, echo=FALSE, warning=FALSE, message=FALSE}\n\nW <- song_analysis(X = sp, song_colm = \"song\",mean_colm = c(\"dfrange\", \"duration\"), parallel = 1, pb = TRUE)\n\nkbl <- kable(W, align = \"c\", row.names = F,  format = \"html\")\n\nkbl <- kable_styling(kbl, bootstrap_options = c(\"striped\", \"hover\", \"condensed\", \"responsive\"), full_width = FALSE, font_size = 11)\n\nscroll_box(kbl, width = \"808px\",\nbox_css = \"border: 1px solid #ddd; padding: 5px; \", extra_css = NULL)\n\n\n\n```\n\n \n\nCalculate song-level parameters for selecting parameters with 'mean_colm', 'max_colm' and 'min_colm' and weighted by duration:\n\n```{r, eval = FALSE}\n\nsong_analysis(X = sp, weight = \"duration\", song_colm = \"song\",\nmean_colm =  c(\"dfrange\", \"duration\"), min_colm =  \"mindom\", max_colm = \"maxdom\", \n  parallel = 1, pb = TRUE)\n\n\n```\n\n```{r, eval= TRUE, echo=FALSE, warning=FALSE, message=FALSE}\n\nW <- song_analysis(X = sp, weight = \"duration\", song_colm = \"song\",\nmean_colm =  c(\"dfrange\", \"duration\"), min_colm =  \"mindom\", max_colm = \"maxdom\", \n  parallel = 1, pb = TRUE)\n\nkbl <- kable(W, align = \"c\", row.names = F,  format = \"html\")\n\nkbl <- kable_styling(kbl, bootstrap_options = c(\"striped\", \"hover\", \"condensed\", \"responsive\"), full_width = FALSE, font_size = 11)\n\nscroll_box(kbl, width = \"808px\",\nbox_css = \"border: 1px solid #ddd; padding: 5px; \", extra_css = NULL)\n\n\n```\n\n \n\n \n\n::: {.alert .alert-info}\n<font size=\"5\">Exercise</font>\n\n \n\n-   Spix's disc-winged bats (*Thyroptera tricolor*) its a Neotropical species that uses a specific call type to reply to social mates looking for their roosts. Those 'response' calls look like this:\n\n \n\n<img src=\"images/response_thyroptera2.png\" alt=\"viewSpec\" width=\"640\"/>\n\n \n\nAn extended selection table with response calls can be read from github as follows:\n\n```{r, eval = FALSE, echo = FALSE}\n\ndownload.file(url = \"https://github.com/maRce10/PR_BIR_2024/raw/master/examples/response_calls.RDS\", \n destfile = \"./examples/response_calls.RDS\")\n\nresponse_calls <- readRDS(\"./examples/response_calls.RDS\")\n\nsp_resp <- spectro_analysis(response_calls)\n\nresponse_calls <- cbind(response_calls, sp_resp[, -c(1, 2)])\n\n\nsp_resp_by_call <- song_analysis(response_calls, song_colm = \"call\")\n\n```\n\n```{r, eval = FALSE}\n\ndownload.file(url = \"https://github.com/maRce10/PR_BIR_2024/raw/master/examples/response_calls.RDS\", \n destfile = \"./examples/response_calls.RDS\")\n\nresponse_calls <- readRDS(\"./examples/response_calls.RDS\")\n\n\n```\n\n \n\n-   Calculate spectrographic parameters (`spectro_analysis()`) for the Spix's disc-winged bat response calls.\n\n-   Summarize parameters by call (`song_analysis()`). To do that you should add the column 'start', 'end' and 'call' to the output of `spectro_analysis()`\n:::\n\n \n\n------------------------------------------------------------------------\n\n## References\n\n1.  Araya-Salas M, A Hernández-Pinsón N Rojas, G Chaverri. (2020). [Ontogeny of an interactive call-and-response system in Spix's disc-winged bats. Animal Behaviour.](https://marce10.github.io/uploads/m-araya-salas-2020.pdf)\n\n2.  Araya-Salas M, Smith-Vidaurre G (2017) [warbleR: An R package to streamline analysis of animal acoustic signals. Methods Ecol Evol 8:184--191.](https://marce10.github.io/uploads/araya-salas-2017-f.pdf)\n\n3.  Lyon, R. H., & Ordubadi, A. (1982). Use of cepstra in acoustical signal analysis. Journal of Mechanical Design, 104(2), 303-306.\n\n4.  Salamon, J., Jacoby, C., & Bello, J. P. (2014). A dataset and taxonomy for urban sound research. In Proceedings of the 22nd ACM international conference on Multimedi. 1041-1044.\n\n<font size=\"4\">Session information</font>\n\n```{r session info, echo=F}\n\nsessionInfo()\n\n```\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"kable","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"show","code-overflow":"wrap","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":true,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"toc-depth":2,"number-sections":true,"highlight-style":"pygments","css":["styles.css"],"output-file":"measure_acoustic_structure.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.4.549","toc-location":"left","toc-title":"Contents","code-copy":true,"date":"today","title":"<font size=\"7\"><b>Measures of acoustic structure</b></font>","editor_options":{"chunk_output_type":"console"}},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}