{"title":"<font size=\"7\"><b>Introduction to warbleR</b></font>","markdown":{"yaml":{"title":"<font size=\"7\"><b>Introduction to warbleR</b></font>"},"headingText":"**Objetive**","headingAttr":{"id":"","classes":["unnumbered","unlisted"],"keyvalue":[]},"containsRefs":false,"markdown":"\n\n \n\n::: {.alert .alert-info}\n\n-   Provide and overview of the must relevant tools in the package warbleR\n:::\n\n \n\nThe [warbleR](https://cran.r-project.org/package=warbleR) package is intended to facilitate the analysis of the structure of animal acoustic signals in R. Users can enter their own data into a workflow that facilitates spectrographic visualization and measurement of acoustic parameters **warbleR** makes use of the fundamental sound analysis tools of the **seewave** package, and offers new tools for acoustic structure analysis. These tools are available for batch analysis of acoustic signals.\n\n \n\n<font size = \"4\">The main features of the package are:</font>\n\n<font size = \"3\">\n\n-   The use of loops to apply tasks through acoustic signals referenced in a selection table:\n\n \n\n<img src=\"images/loop_warbleR_optim.gif\" alt=\"warbleR measuring loop\" width=\"500\"/>\n\n \n\n-   The production of images files with spectrograms that let users organize data and verify acoustic analyzes: </font>\n\n \n\n<img src=\"images/loop_warbleR_images_optim.gif\" alt=\"warbleR image loop\" width=\"500\"/>\n\n \n\nThe package offers functions for:\n\n-   Browse and download recordings of [Xeno ‐ Canto](https://xeno-canto.org/)\n-   Explore, organize and manipulate multiple sound files\n-   Detect signals automatically (in frequency and time)\n-   Create spectrograms of complete recordings or individual signals\n-   Run different measures of acoustic signal structure\n-   Evaluate the performance of measurement methods\n-   Catalog signals\n-   Characterize different structural levels in acoustic signals\n-   Statistical analysis of duet coordination\n-   Consolidate databases and annotation tables\n\nMost functions allow the parallelization of tasks, which distributes the tasks among several cores to improve computational efficiency. Tools to evaluate the performance of the analysis at each step are also available. All these tools are provided in a standardized workflow for the analysis of the signal structure, making them accessible to a wide range of users, including those without much knowledge of R.\n\n**warbleR** is a young package (officially published in 2017) currently in a maturation stage:\n\n<img src=\"images/lifecycle.jpeg\" alt=\"life cycle\" width=\"80%\"/>\n\n \n\n## Selection tables\n\nThese objects are created with the `selection_table()` function. The function takes data frames containing selection data (name of the sound file, selection, start, end ...), verifies if the information is consistent (see the function `check_sels()` for details) and saves the 'diagnostic' metadata as an attribute. The selection tables are basically data frames in which the information contained has been corroborated so it can be read by other **warbleR** functions. The selection tables must contain (at least) the following columns:\n\n1.  sound files (sound.files)\n2.  selection (select)\n3.  start\n4.  end\n\nThe sample data \"lbh_selec_table\" contains these columns:\n\n```{r extn_sel_2, echo = FALSE, message = FALSE}\n\nrm(list = ls())\n\n# unload all non-based packages\nout <- sapply(paste('package:', names(sessionInfo()$otherPkgs), sep = \"\"), function(x) try(detach(x, unload = FALSE, character.only = TRUE), silent = T))\n\n#load packages\nlibrary(warbleR)\n# library(knitr)\n# library(kableExtra)\n\n\ncf <- read.csv(\"./data/cuadro de funciones warbleR.csv\", stringsAsFactors = FALSE)\n\nwarbleR_options(wav.path = \"./examples\") \n\n# options(knitr.table.format = \"html\") \n# opts_chunk$set(comment = \"\")\n# opts_knit$set(root.dir = tempdir())\n# options(width = 100, max.print = 100)\n\n```\n\n```{r}\ndata(\"lbh_selec_table\")\n\nlbh_selec_table\n```\n\n \n\n... and can be converted to the *selection_table* format like this:\n\n```{r extn_sel_4.32, eval = FALSE}\n\n# global parameters\nwarbleR_options(wav.path = \"./examples\")\n\nst <- selection_table(X = lbh_selec_table, pb = FALSE)\n\nst\n```\n\n```{r, eval = TRUE, echo = FALSE}\n\nst <- selection_table(X = lbh_selec_table, pb = FALSE)\n\nst\n```\n\nNote that the path to the sound files has been provided. This is necessary in order to verify that the data provided conforms to the characteristics of the audio files.\n\nSelection tables have their own class in R:\n\n```{r}\n\nclass(st)\n\n```\n\n \n\n### Extended selection tables\n\nWhen the `extended = TRUE` argument the function generates an object of the *extended_selection_table* class that also contains a list of 'wave' objects corresponding to each of the selections in the data. Therefore, the function **transforms the selection table into self-contained objects** since the original sound files are no longer needed to perform most of the acoustic analysis in **warbleR**. This can greatly facilitate the storage and exchange of (bio)acoustic data. In addition, it also speeds up analysis, since it is not necessary to read the sound files every time the data is analyzed.\n\nNow, as mentioned earlier, you need the `selection_table()` function to create an extended selection table. You must also set the argument `extended = TRUE` (otherwise, the class would be a selection table). The following code converts the sample data into an extended selection table:\n\n```{r extn_sel_4.3, eval = FALSE}\n\n\n#  global parameters\nwarbleR_options(wav.path = \"./examples\")\n\next_st <- selection_table(X = lbh_selec_table, pb = FALSE, \n          extended = TRUE)\n\n```\n\n```{r extn_sel_4.33, eval = TRUE, echo = FALSE}\n\next_st <- selection_table(X = lbh_selec_table, pb = FALSE, \n          extended = TRUE)\n\n\n```\n\n \n\nAnd that is. Now the acoustic data and the selection data (as well as the additional metadata) are all together in a single R object.\n\n \n\n::: {.alert .alert-info}\n<font size=\"5\">Exercise</font>\n\n \n\n-   Run the example code in the `selection_table()` function documentation\n\n-   What do the arguments \"mar\", \"by.song\" and \"whole.recs\" do?\n:::\n\n \n\n### Handling extended selection tables\n\nSeveral functions can be used to deal with objects of this class. You can test if the object belongs to the *extended_selection_table*:\n\n```{r extn_sel_5}\n\nis_extended_selection_table(ext_st)\n\n```\n\n \n\nYou can subset the selection in the same way that any other data frame and it will still keep its attributes:\n\n```{r extn_sel_6}\n\next_st2 <- ext_st[1:2, ]\n\nis_extended_selection_table(ext_st2)\n\n```\n\nThere is also a generic version of `print()` for this class of objects:\n\n```{r extn_sel_7}\n\n## print\nprint(ext_st)\n\n```\n\n... which is equivalent to:\n\n```{r extn_sel_7.1, eval=FALSE}\n\next_st\n\n```\n\n```{r extn_sel_7/2, echo=FALSE}\n\nprint(ext_st)\n\n```\n\n \n\nYou can also join them in rows. Here the original *extended_selection_table* is divided into 2 and bound again using `rbind()`:\n\n```{r extn_sel_8, eval = FALSE}\n\next_st3 <- ext_st[1:5, ]\n\next_st4 <- ext_st[6:11, ]\n\next_st5 <- rbind(ext_st3, ext_st4)\n\n#print\next_st5\n\n```\n\n```{r extn_sel_8.1, echo=FALSE}\n\next_st3 <- ext_st[1:5, ]\n\next_st4 <- ext_st[6:11, ]\n\next_st5 <- rbind(ext_st3, ext_st4)\n\n#print\nprint(ext_st5)\n\n```\n\n```{r extn_sel_8.2}\n\n# are they equal?\nall.equal(ext_st, ext_st5)\n\n```\n\n \n\nThe 'wave' objects can be read individually using `read_sound_file()`, a wrapper for the `readWave()` function of **tuneR**, which can handle extended selection tables:\n\n```{r extn_sel_8.21}\n\nwv1 <- read_sound_file(X = ext_st, index = 3, from = 0, to = 0.37)\n\n```\n\n \n\nThese are regular 'wave' objects:\n\n```{r extn_sel_8.22, out.width= 750}\n\nclass(wv1)\n\nwv1\n\nspectro(wv1, wl = 150, grid = FALSE, scale = FALSE, ovlp = 90)\n```\n\n \n\n```{r extn_sel_8.23, out.width= 750}\npar(mfrow = c(3, 2), mar = rep(0, 4))\n\nfor(i in 1:6){\n  \n  wv <- read_sound_file(X = ext_st, index = i, from = 0.05, to = 0.32)\n\n  spectro(wv, wl = 150, grid = FALSE, scale = FALSE, axisX = FALSE,\n          axisY = FALSE, ovlp = 90)\n\n}\n\n```\n\n \n\nThe `read_sound_file()` function requires the selection table, as well as the row index (i.e. the row number) to be able to read the 'wave' objects. It can also read a regular 'wave' file if the path is provided.\n\nNote that other functions that modify data frames are likely to delete the attributes in which the 'wave' objects and metadata are stored. For example, the merge and the extended selection box will remove its attributes:\n\n```{r extn_sel_8.24}\n\n# create new data base\nY <- data.frame(sound.files = ext_st$sound.files, site = \"La Selva\", lek = c(rep(\"SUR\", 5), rep(\"CCL\", 6)))\n\n# combine\nmrg_ext_st <- merge(ext_st, Y, by = \"sound.files\")\n\n# check class\nis_extended_selection_table(mrg_ext_st)\n\n```\n\n \n\nIn this case, we can use the `fix_extended_selection_table()` function to transfer the attributes of the original extended selection table:\n\n```{r extn_sel_8.25}\n\n# fix\nmrg_ext_st <- fix_extended_selection_table(X = mrg_ext_st, Y = ext_st)\n\n# check class\nis_extended_selection_table(mrg_ext_st)\n\n```\n\n \n\nThis works as long as some of the original sound files are retained and no other selections are added.\n\n& nbsp;\n\n### Selection table size\n\nThe size of the extended selection box will depend on the number of selections, the sampling rate, the duration of the selection and the length of margins (i.e. additional time you want to keep on each side of the selection). In this example, a selection table with 1000 selections is created simply by repeating the sample data frame several times and then is converted to an extended selection table:\n\n```{r extn_sel_9, eval=FALSE}\n\nlng.selec.table <- do.call(rbind, replicate(100, lbh_selec_table, \n                        simplify = FALSE))[1:1000,]\n\nlng.selec.table$selec <- 1:nrow(lng.selec.table)\n\nnrow(lng.selec.table)\n\nlng_ext_st <- selection_table(X = lng.selec.table, pb = FALSE, \n                        extended = TRUE)\n\nlng_ext_st\n\n```\n\n```{r extn_sel_9.2, echo=FALSE}\n\nlng.selec.table <- do.call(rbind, replicate(100, lbh_selec_table, \n                        simplify = FALSE))[1:1000,]\n\nlng.selec.table$selec <- 1:nrow(lng.selec.table)\n\nlng_ext_st <- selection_table(X = lng.selec.table, pb = FALSE, \n                        extended = TRUE)\n\nprint(lng_ext_st)\n\n\n```\n\n```{r extn_sel_9.3}\n\nformat(object.size(lng_ext_st), units = \"auto\")\n\n```\n\n \n\nAs you can see, the object size is only \\~ 31 MB. Then, as a guide, a selection box with 1000 selections similar to those of 'lbh_selec_table' (average duration of \\~ 0.15 seconds) at a sampling rate of 22.5 kHz and the default margin (mar = 0.1) will generate an extended selection box \\~ 31 MB or \\~ 310 MB for a selection table of 10,000 rows.\n\n \n\n### Analysis using extended selection tables\n\nThese objects can be used as input for most **warbleR** functions. Here are some examples of **warbleR** functions using *extended_selection_table*:\n\n#### Spectral parameters\n\n```{r extn_sel_12.1, eval=TRUE}\n\n#  spectrographic parameters\nsp <- spectro_analysis(ext_st)\n\nsp\n```\n\n \n\n#### Signal-to-noise ratio\n\n```{r extn_sel_12.5, eval=TRUE}\n\nsnr <- sig2noise(ext_st, mar = 0.05)\n\nsnr\n```\n\n \n\n#### Dynamic time warping (DTW)\n\n```{r extn_sel_12.7, eval=FALSE}\n\ndtw.dist <- freq_DTW(ext_st, img = FALSE)\n\ndtw.dist\n\n```\n\n```{r extn_sel_12.8, echo=TRUE}\n\ndtw.dist <- freq_DTW(ext_st, img = FALSE)\n\nas.data.frame(dtw.dist)\n\n```\n\n \n\n### Performance\n\nThe use of *extended_selection_table* objects can improve performance (in our case, measured as time). Here we use **microbenchmark** to compare the performance of `sig2noise()` and **ggplot2** to plot the results:\n\n```{r extn_sel_13, out.width= 750, dpi = 100}\n\n# load packages\nlibrary(microbenchmark)\nlibrary(ggplot2)\n\n# take first 100 selections\nmbmrk.snr <- microbenchmark(extended = sig2noise(lng_ext_st[1:100, ], \n      mar = 0.05), regular = sig2noise(lng.selec.table[1:100, ], \n                    mar = 0.05), times = 50)\n\nautoplot(mbmrk.snr) + ggtitle(\"sig2noise\")\n\n```\n\n \n\nThe function runs much faster in the extended selection tables. Performance gain is likely to improve when longer recordings and data sets are used (that is, to compensate for computer overload).\n\n \n\n### Create selections 'by song'\n\nThe extended selection above were made by element. That is, each sound file within the object contains a single selection (that is, a 1: 1 correspondence between the selections and the 'wave' objects). However, extended selection tables can also be created using a higher hierarchical level with the argument `by.song`. In this case, \"song\" represents a higher level that contains one or more selections and that the user may want to keep together for a particular analysis (for example, the duration of the intervals). The `by.song` argument takes the name of the column of characters or factors with the IDs of the different\" songs \"within a sound file (note that the function assumes that a given song can only be found in only one sound file, so the selections with the same song ID, but from different sound files are taken as different 'songs').\n\nTo create a selection table by song, let's add an artificial song column to our example data in which each of the sound files has 2 songs:\n\n```{r extn_sel_14}\n\n# add column\nlbh_selec_table$song <- c(1, 1, 2, 1, 2, 1, 1, 2, 1, 2, 2)\n\n```\n\n \n\nThe data looks like this:\n\n```{r, extn_sel_15, echo= FALSE}\n\nlbh_selec_table\n\n```\n\n \n\nNow we can create an extended selection table 'by song' using the column name 'song' as input for the argument `by.song`:\n\n```{r extn_sel_16}\n\nbs_ext_st <- selection_table(X = lbh_selec_table, extended = TRUE,\n                             by.song = \"song\")\n\n```\n\nIn this case, we should only have 8 'wave' objects instead of 11 as when the object was created 'by selection':\n\n```{r extn_sel_17}\n\n# by element\nlength(attr(ext_st, \"wave.objects\"))\n\n# by song\nlength(attr(bs_ext_st, \"wave.objects\"))\n\n```\n\nAgain, these objects can also be used in any analyzes:\n\n```{r extn_sel_18}\n\n# signal to noise ratio\nbs_snr <- sig2noise(bs_ext_st, mar = 0.05)\n\nbs_snr\n```\n\n \n\n::: {.alert .alert-info}\n<font size=\"5\">Exercise</font>\n\n \n\n-   Compare the size of an extended selection table created by element to that of one created by song using the sample data\n:::\n\n \n\n### Sharing acoustic data\n\nThis new object class allows to share complete data sets, including acoustic data. For example, the following code downloads a subset of the data used in [Araya-Salas *et al* (2019)](https://marce10.github.io/uploads/araya-salas-2019-a.pdf) (can also be downloaded from  [Araya-Salas *et al* (2017)](https://github.com/maRce10/PR_BIR_2024/raw/master/data/extended.selection.table.araya-salas.et.al.2017.bioacoustics.100.sels.rds):\n\n```{r extn.sel_19, eval = FALSE}\n\nURL <- \"https://github.com/maRce10/PR_BIR_2024/raw/master/data/extended.selection.table.araya-salas.et.al.2017.bioacoustics.100.sels.rds\"\n\ndat <- readRDS(gzcon(url(URL)))\n\nnrow(dat)\n\nformat(object.size(dat), units = \"auto\")\n\n```\n\n```{r extn.sel_19-2, echo = FALSE}\n\ndat <- readRDS(\"./data/extended.selection.table.araya-salas.et.al.2017.bioacoustics.100.sels.rds\")\n\nnrow(dat)\n\nformat(object.size(dat), units = \"auto\")\n\n```\n\nThe total size of the 100 sound files from which these selections were taken adds up to 1.1 GB. The size of the extended selection table is only 10.1 MB.\n\nThis data is ready to be used:\n\n```{r, eval = TRUE}\nsp <- spectro_analysis(dat, bp = c(2, 10))\n\nhead(sp)\n```\n\n... and the spectrograms can be visualized as follows:\n\n```{r extn.sel_21, out.width= 750}\n\npar(mfrow = c(3, 2), mar = rep(0, 4))\n\nfor(i in 1:6){\n  \n  wv <- read_sound_file(X = dat, index = i, from = 0.17, to = 0.4)\n\n  spectro(wv, wl = 250, grid = FALSE, scale = FALSE, axisX = FALSE,\n          axisY = FALSE, ovlp = 90, flim = c(0, 12), \n          palette = reverse.gray.colors.1)\n}\n\n```\n\nThe **NatureSounds** package contains an extended selection table with long-billed hermit hummingbirds vocalizations from 10 different song types:\n\n```{r}\n\ndata(\"Phae.long.est\")\n\nPhae.long.est\n\ntable(Phae.long.est$lek.song.type)\n\n```\n\nThe ability to compress large data sets and the ease of performing analyzes that require a single R object can simplify the exchange of data and the reproducibility of bioacoustic analyzes.\n\n \n\n::: {.alert .alert-info}\n<font size=\"5\">Exercise</font>\n\n \n\n-   Download the extended selection tables of bat social calls from the [this figshare repository](https://figshare.com/articles/dataset/Supplementary_materials_Ontogeny_of_an_interactive_call-and-response_system_in_Spix_s_disc-winged_bats_PART_1/11651772) (scroll till the end of the file list) and create spectrograms for the first 5 selections of each table (either `spectrograms()` or `spectro()` would work)\n:::\n\n \n\n## **warbleR** functions and the workflow of analysis in bioacoustics\n\nBioacoustic analyzes generally follow a specific processing sequence and analysis. This sequence can be represented schematically like this:\n\n```{r, eval = FALSE, echo = FALSE}\n\nlibrary(warbleR)\n\nwf <- ls(\"package:warbleR\")\n\nwf <- wf[-c(2, 7, 8, 10, 12, 16, 17, 19, 20, 23, 24, 28, 31, 32, 33, 38, 42, 43, 44, 47, 50, 53, 59, 64, 66, 68, 68, 72, 74, 80, 81, 85, 90, 93, 94, 96)]\n\ndf <- data.frame(funciones = wf, `Obtener-preparar grabaciones` = \"\", `Anotar` = \"\", `Medir` = \"\",  `Revision` = \"\", `Inspección visual` = \"\", `Análisis estadístico` = \"\", `Otros` = \"\")\n\ndf2 <- edit(df)\n\n\ndf2$`organizar.anotaciones` <- \"\" \n\nnames(df2) <- names(df2)[c(1:3, 9, 4:8)]\n\ndf3 <- edit(df2)\n\ndf4 <- df3\n\ndf4[is.na(df4)] <- \"\"\n\ndf4 <- df4[df4$Obtener.preparar.grabaciones != \"borrar\", ]\n\nnames(df4) <- c(\"Función\", \"Obtener-preparar grabaciones\", \"Anotar\", \"Organizar anotaciones\", \"Medir estructura\", \"Verificar\", \"Inspección visual\", \"Análisis estadístico\", \"Otros\")\n\nrownames(df4) <- 1:nrow(df4)\n\ndf5 <- df4[order(df4$`Obtener-preparar grabaciones`, df4$Anotar, df4$`Organizar anotaciones`, df4$`Medir estructura`, df4$Verificar, df4$`Inspección visual`, df4$`Análisis estadístico`, df4$Otros, decreasing = TRUE),]\n\ndf4 <- df4[c(5, 8, 18, 29, 34, 35, 37, 38, 39, 55, 56, 26, 1, 19, 40, 46, 4, 11, 16, 17, 24, 25, 32, 41, 45, 7, 12, 13, 14, 15, 23, 27, 30, 42, 47, 48, 57, 2,  3, 28, 44, 50, 51, 52, 58, 9, 10, 21, 22, 59, 6, 20, 31, 33, 36, 43, 49, 53, 54), ]\n\n# write.csv(df4, \"cuadro de funciones warbleR.csv\", row.names = FALSE)\n\n```\n\n<img src=\"images/analysis-workflow.png\" alt=\"analysis workflow\"/>\n\n \n\nWe can group **warbleR** functions according to the bioacoustic analysis stages.\n\n \n\n### Get and prepare recordings\n\nThe `query_xc()` function allows you to search and download sounds from the free access database [Xeno-Canto](https://xeno-canto.org/). You can also convert .mp3 files to .wav, change the sampling rate of the files and correct corrupt files, among other functions.\n\n```{r, echo = FALSE}\n\ncf2 <- cf[cf$Obtener.preparar.grabaciones == \"x\", c(\"Function\", \"Description\", \"Works.on\", \"Output\")]\n\ncf2$Function <- kableExtra::cell_spec(x = cf2$Function, link = paste0(\"https://marce10.github.io/warbleR/reference/\", cf2$Function, \".html\"))\n\nkbl <- knitr::kable(cf2, align = \"c\", row.names = F,  format = \"html\", escape = F)\n\nkbl <- kableExtra::column_spec(kbl, 1, bold = TRUE)\n\nkbl <- kableExtra::column_spec(kbl, 2:4, italic = TRUE)\n\nkbl <-  kableExtra::kable_styling(kbl, bootstrap_options = \"striped\", font_size = 14)\n\nkbl\n\n```\n\n \n\n### Annotating sound\n\nIt is recommended to make annotations in other programs and then import them into R (for example in Raven and import them with the **Rraven** package). However, **warbleR** offers some functions to facilitate manual or automatic annotation of sound files, as well as the subsequent manipulation:\n\n```{r, echo = FALSE}\n\ncf2 <- cf[cf$Anotar == \"x\",  c(\"Function\", \"Description\", \"Works.on\", \"Output\")]\n\ncf2$Function <- kableExtra::cell_spec(x = cf2$Function, link = paste0(\"https://marce10.github.io/warbleR/reference/\", cf2$Function, \".html\"))\n\nkbl <- knitr::kable(cf2, align = \"c\", row.names = F,  format = \"html\", escape = F)\n\nkbl <- kableExtra::column_spec(kbl, 1, bold = TRUE)\n\nkbl <- kableExtra::column_spec(kbl, 2:4, italic = TRUE)\n\nkbl <-  kableExtra::kable_styling(kbl, bootstrap_options = \"striped\", font_size = 14)\n\nkbl\n\n```\n\n \n\n### Organize annotations\n\nThe annotations (or selection tables) can be manipulated and refined with a variety of functions. Selection tables can also be converted into the compact format *extended selection tables*:\n\n```{r, echo = FALSE}\n\ncf2 <- cf[cf$`Anotar` == \"x\",  c(\"Function\", \"Description\", \"Works.on\", \"Output\")]\n\ncf2$Function <- kableExtra::cell_spec(x = cf2$Function, link = paste0(\"https://marce10.github.io/warbleR/reference/\", cf2$Function, \".html\"))\n\nkbl <- knitr::kable(cf2, align = \"c\", row.names = F,  format = \"html\", escape = F)\n\nkbl <- kableExtra::column_spec(kbl, 1, bold = TRUE)\n\nkbl <- kableExtra::column_spec(kbl, 2:4, italic = TRUE)\n\nkbl <- kableExtra::kable_styling(kbl, bootstrap_options = \"striped\", font_size = 14)\n\nkbl\n\n```\n\n \n\n### Measure acoustic signal structure\n\nMost **warbleR** functions are dedicated to quantifying the structure of acoustic signals listed in selection tables using batch processing. For this, 4 main measurement methods are offered:\n\n1.  Spectrographic parameters\n2.  Cross correlation\n3.  Dynamic time warping (DTW)\n4.  Statistical descriptors of cepstral coefficients\n\nMost functions gravitate around these methods, or variations of these methods:\n\n```{r, echo = FALSE}\n\ncf2 <- cf[cf$`Medir.estructura` == \"x\",  c(\"Function\", \"Description\", \"Works.on\", \"Output\")]\n\ncf2$Function <- kableExtra::cell_spec(x = cf2$Function, link = paste0(\"https://marce10.github.io/warbleR/reference/\", cf2$Function, \".html\"))\n\nkbl <- knitr::kable(cf2, align = \"c\", row.names = F,  format = \"html\", escape = F)\n\nkbl <- kableExtra::column_spec(kbl, 1, bold = TRUE)\n\nkbl <- kableExtra::column_spec(kbl, 2:4, italic = TRUE)\n\nkbl <-  kableExtra::kable_styling(kbl, bootstrap_options = \"striped\", font_size = 14)\n\nkbl\n\n```\n\n \n\n::: {.alert .alert-info}\n<font size=\"5\">Exercise</font>\n\n \n\n-   Compare the performance of `spectro_analysis()` on the example 'lbh_selec_table' with \"the argument 'fast = TRUE' vs 'fast = FALSE'. What does this argument do and which `seewave` function might be involved?\n:::\n\n \n\n### Verify annotations\n\nFunctions are provided to detect inconsistencies in the selection tables or modify selection tables. The package also offers several functions to generate spectrograms showing the annotations, which can be organized by annotation categories. This allows you to verify if the annotations match the previously defined categories, which is particularly useful if the annotations were automatically generated.\n\n```{r, echo = FALSE}\n\ncf2 <- cf[cf$Verificar == \"x\",  c(\"Function\", \"Description\", \"Works.on\", \"Output\")]\n\ncf2$Function <- kableExtra::cell_spec(x = cf2$Function, link = paste0(\"https://marce10.github.io/warbleR/reference/\", cf2$Function, \".html\"))\n\nkbl <- knitr::kable(cf2, align = \"c\", row.names = F,  format = \"html\", escape = F)\n\nkbl <- kableExtra::column_spec(kbl, 1, bold = TRUE)\n\nkbl <- kableExtra::column_spec(kbl, 2:4, italic = TRUE)\n\nkbl <-  kableExtra::kable_styling(kbl, bootstrap_options = \"striped\", font_size = 14)\n\nkbl\n\n```\n\n \n\n### Visually inspection of annotations and measurements\n\n```{r, echo = FALSE}\n\ncf2 <- cf[cf$`Inspeccion.visual` == \"x\",  c(\"Function\", \"Description\", \"Works.on\", \"Output\")]\n\ncf2$Function <- kableExtra::cell_spec(x = cf2$Function, link = paste0(\"https://marce10.github.io/warbleR/reference/\", cf2$Function, \".html\"))\n\nkbl <- knitr::kable(cf2, align = \"c\", row.names = F,  format = \"html\", escape = F)\n\nkbl <- kableExtra::column_spec(kbl, 1, bold = TRUE)\n\nkbl <- kableExtra::column_spec(kbl, 2:4, italic = TRUE)\n\nkbl <-  kableExtra::kable_styling(kbl, bootstrap_options = \"striped\", font_size = 14)\n\nkbl\n\n\n```\n\n \n\n### Additional functions\n\nFinally, **warbleR** offers functions to simplify the use of extended selection tables, organize large numbers of images with spectrograms and generate elaborated signal visualizations:\n\n```{r, echo = FALSE}\n\ncf2 <- cf[cf$Analisis.estadistico == \"x\" | cf$Otros == \"x\",  c(\"Function\", \"Description\", \"Works.on\", \"Output\")]\n\ncf2$Function <- kableExtra::cell_spec(x = cf2$Function, link = paste0(\"https://marce10.github.io/warbleR/reference/\", cf2$Function, \".html\"))\n\nkbl <- knitr::kable(cf2, align = \"c\", row.names = F,  format = \"html\", escape = F)\n\nkbl <- kableExtra::column_spec(kbl, 1, bold = TRUE)\n\nkbl <- kableExtra::column_spec(kbl, 2:4, italic = TRUE)\n\nkbl <- kableExtra::kable_styling(kbl, bootstrap_options = \"striped\", font_size = 14)\n\nkbl\n\n```\n\n \n\n::: {.alert .alert-info}\n<font size=\"5\">Exercise</font>\n\n \n\n-   Run the examples of the functions `phylo_spectro()` and `color_spectro()`\n\n-   Use the `query_xc()` and `map_xc()` functions to explore the geographical distribution of the Xeno-Canto recordings of a species (of bird) of your interest (if any!)\n:::\n\n \n\n------------------------------------------------------------------------\n\n## References\n\n1.  Araya-Salas M, G Smith-Vidaurre & M Webster. (2019). Assessing the effect of sound file compression and background noise on measures of acoustic signal structure. Bioacoustics 4622, 1--17\n2.  Araya-Salas M, Smith-Vidaurre G (2017) warbleR: An R package to streamline analysis of animal acoustic signals. Methods Ecol Evol 8:184--191.\n\n \n\n------------------------------------------------------------------------\n\n<font size=\"4\">Session information</font>\n\n```{r session info, echo=F}\n\nsessionInfo()\n\n```\n","srcMarkdownNoYaml":"\n\n \n\n::: {.alert .alert-info}\n## **Objetive** {.unnumbered .unlisted}\n\n-   Provide and overview of the must relevant tools in the package warbleR\n:::\n\n \n\nThe [warbleR](https://cran.r-project.org/package=warbleR) package is intended to facilitate the analysis of the structure of animal acoustic signals in R. Users can enter their own data into a workflow that facilitates spectrographic visualization and measurement of acoustic parameters **warbleR** makes use of the fundamental sound analysis tools of the **seewave** package, and offers new tools for acoustic structure analysis. These tools are available for batch analysis of acoustic signals.\n\n \n\n<font size = \"4\">The main features of the package are:</font>\n\n<font size = \"3\">\n\n-   The use of loops to apply tasks through acoustic signals referenced in a selection table:\n\n \n\n<img src=\"images/loop_warbleR_optim.gif\" alt=\"warbleR measuring loop\" width=\"500\"/>\n\n \n\n-   The production of images files with spectrograms that let users organize data and verify acoustic analyzes: </font>\n\n \n\n<img src=\"images/loop_warbleR_images_optim.gif\" alt=\"warbleR image loop\" width=\"500\"/>\n\n \n\nThe package offers functions for:\n\n-   Browse and download recordings of [Xeno ‐ Canto](https://xeno-canto.org/)\n-   Explore, organize and manipulate multiple sound files\n-   Detect signals automatically (in frequency and time)\n-   Create spectrograms of complete recordings or individual signals\n-   Run different measures of acoustic signal structure\n-   Evaluate the performance of measurement methods\n-   Catalog signals\n-   Characterize different structural levels in acoustic signals\n-   Statistical analysis of duet coordination\n-   Consolidate databases and annotation tables\n\nMost functions allow the parallelization of tasks, which distributes the tasks among several cores to improve computational efficiency. Tools to evaluate the performance of the analysis at each step are also available. All these tools are provided in a standardized workflow for the analysis of the signal structure, making them accessible to a wide range of users, including those without much knowledge of R.\n\n**warbleR** is a young package (officially published in 2017) currently in a maturation stage:\n\n<img src=\"images/lifecycle.jpeg\" alt=\"life cycle\" width=\"80%\"/>\n\n \n\n## Selection tables\n\nThese objects are created with the `selection_table()` function. The function takes data frames containing selection data (name of the sound file, selection, start, end ...), verifies if the information is consistent (see the function `check_sels()` for details) and saves the 'diagnostic' metadata as an attribute. The selection tables are basically data frames in which the information contained has been corroborated so it can be read by other **warbleR** functions. The selection tables must contain (at least) the following columns:\n\n1.  sound files (sound.files)\n2.  selection (select)\n3.  start\n4.  end\n\nThe sample data \"lbh_selec_table\" contains these columns:\n\n```{r extn_sel_2, echo = FALSE, message = FALSE}\n\nrm(list = ls())\n\n# unload all non-based packages\nout <- sapply(paste('package:', names(sessionInfo()$otherPkgs), sep = \"\"), function(x) try(detach(x, unload = FALSE, character.only = TRUE), silent = T))\n\n#load packages\nlibrary(warbleR)\n# library(knitr)\n# library(kableExtra)\n\n\ncf <- read.csv(\"./data/cuadro de funciones warbleR.csv\", stringsAsFactors = FALSE)\n\nwarbleR_options(wav.path = \"./examples\") \n\n# options(knitr.table.format = \"html\") \n# opts_chunk$set(comment = \"\")\n# opts_knit$set(root.dir = tempdir())\n# options(width = 100, max.print = 100)\n\n```\n\n```{r}\ndata(\"lbh_selec_table\")\n\nlbh_selec_table\n```\n\n \n\n... and can be converted to the *selection_table* format like this:\n\n```{r extn_sel_4.32, eval = FALSE}\n\n# global parameters\nwarbleR_options(wav.path = \"./examples\")\n\nst <- selection_table(X = lbh_selec_table, pb = FALSE)\n\nst\n```\n\n```{r, eval = TRUE, echo = FALSE}\n\nst <- selection_table(X = lbh_selec_table, pb = FALSE)\n\nst\n```\n\nNote that the path to the sound files has been provided. This is necessary in order to verify that the data provided conforms to the characteristics of the audio files.\n\nSelection tables have their own class in R:\n\n```{r}\n\nclass(st)\n\n```\n\n \n\n### Extended selection tables\n\nWhen the `extended = TRUE` argument the function generates an object of the *extended_selection_table* class that also contains a list of 'wave' objects corresponding to each of the selections in the data. Therefore, the function **transforms the selection table into self-contained objects** since the original sound files are no longer needed to perform most of the acoustic analysis in **warbleR**. This can greatly facilitate the storage and exchange of (bio)acoustic data. In addition, it also speeds up analysis, since it is not necessary to read the sound files every time the data is analyzed.\n\nNow, as mentioned earlier, you need the `selection_table()` function to create an extended selection table. You must also set the argument `extended = TRUE` (otherwise, the class would be a selection table). The following code converts the sample data into an extended selection table:\n\n```{r extn_sel_4.3, eval = FALSE}\n\n\n#  global parameters\nwarbleR_options(wav.path = \"./examples\")\n\next_st <- selection_table(X = lbh_selec_table, pb = FALSE, \n          extended = TRUE)\n\n```\n\n```{r extn_sel_4.33, eval = TRUE, echo = FALSE}\n\next_st <- selection_table(X = lbh_selec_table, pb = FALSE, \n          extended = TRUE)\n\n\n```\n\n \n\nAnd that is. Now the acoustic data and the selection data (as well as the additional metadata) are all together in a single R object.\n\n \n\n::: {.alert .alert-info}\n<font size=\"5\">Exercise</font>\n\n \n\n-   Run the example code in the `selection_table()` function documentation\n\n-   What do the arguments \"mar\", \"by.song\" and \"whole.recs\" do?\n:::\n\n \n\n### Handling extended selection tables\n\nSeveral functions can be used to deal with objects of this class. You can test if the object belongs to the *extended_selection_table*:\n\n```{r extn_sel_5}\n\nis_extended_selection_table(ext_st)\n\n```\n\n \n\nYou can subset the selection in the same way that any other data frame and it will still keep its attributes:\n\n```{r extn_sel_6}\n\next_st2 <- ext_st[1:2, ]\n\nis_extended_selection_table(ext_st2)\n\n```\n\nThere is also a generic version of `print()` for this class of objects:\n\n```{r extn_sel_7}\n\n## print\nprint(ext_st)\n\n```\n\n... which is equivalent to:\n\n```{r extn_sel_7.1, eval=FALSE}\n\next_st\n\n```\n\n```{r extn_sel_7/2, echo=FALSE}\n\nprint(ext_st)\n\n```\n\n \n\nYou can also join them in rows. Here the original *extended_selection_table* is divided into 2 and bound again using `rbind()`:\n\n```{r extn_sel_8, eval = FALSE}\n\next_st3 <- ext_st[1:5, ]\n\next_st4 <- ext_st[6:11, ]\n\next_st5 <- rbind(ext_st3, ext_st4)\n\n#print\next_st5\n\n```\n\n```{r extn_sel_8.1, echo=FALSE}\n\next_st3 <- ext_st[1:5, ]\n\next_st4 <- ext_st[6:11, ]\n\next_st5 <- rbind(ext_st3, ext_st4)\n\n#print\nprint(ext_st5)\n\n```\n\n```{r extn_sel_8.2}\n\n# are they equal?\nall.equal(ext_st, ext_st5)\n\n```\n\n \n\nThe 'wave' objects can be read individually using `read_sound_file()`, a wrapper for the `readWave()` function of **tuneR**, which can handle extended selection tables:\n\n```{r extn_sel_8.21}\n\nwv1 <- read_sound_file(X = ext_st, index = 3, from = 0, to = 0.37)\n\n```\n\n \n\nThese are regular 'wave' objects:\n\n```{r extn_sel_8.22, out.width= 750}\n\nclass(wv1)\n\nwv1\n\nspectro(wv1, wl = 150, grid = FALSE, scale = FALSE, ovlp = 90)\n```\n\n \n\n```{r extn_sel_8.23, out.width= 750}\npar(mfrow = c(3, 2), mar = rep(0, 4))\n\nfor(i in 1:6){\n  \n  wv <- read_sound_file(X = ext_st, index = i, from = 0.05, to = 0.32)\n\n  spectro(wv, wl = 150, grid = FALSE, scale = FALSE, axisX = FALSE,\n          axisY = FALSE, ovlp = 90)\n\n}\n\n```\n\n \n\nThe `read_sound_file()` function requires the selection table, as well as the row index (i.e. the row number) to be able to read the 'wave' objects. It can also read a regular 'wave' file if the path is provided.\n\nNote that other functions that modify data frames are likely to delete the attributes in which the 'wave' objects and metadata are stored. For example, the merge and the extended selection box will remove its attributes:\n\n```{r extn_sel_8.24}\n\n# create new data base\nY <- data.frame(sound.files = ext_st$sound.files, site = \"La Selva\", lek = c(rep(\"SUR\", 5), rep(\"CCL\", 6)))\n\n# combine\nmrg_ext_st <- merge(ext_st, Y, by = \"sound.files\")\n\n# check class\nis_extended_selection_table(mrg_ext_st)\n\n```\n\n \n\nIn this case, we can use the `fix_extended_selection_table()` function to transfer the attributes of the original extended selection table:\n\n```{r extn_sel_8.25}\n\n# fix\nmrg_ext_st <- fix_extended_selection_table(X = mrg_ext_st, Y = ext_st)\n\n# check class\nis_extended_selection_table(mrg_ext_st)\n\n```\n\n \n\nThis works as long as some of the original sound files are retained and no other selections are added.\n\n& nbsp;\n\n### Selection table size\n\nThe size of the extended selection box will depend on the number of selections, the sampling rate, the duration of the selection and the length of margins (i.e. additional time you want to keep on each side of the selection). In this example, a selection table with 1000 selections is created simply by repeating the sample data frame several times and then is converted to an extended selection table:\n\n```{r extn_sel_9, eval=FALSE}\n\nlng.selec.table <- do.call(rbind, replicate(100, lbh_selec_table, \n                        simplify = FALSE))[1:1000,]\n\nlng.selec.table$selec <- 1:nrow(lng.selec.table)\n\nnrow(lng.selec.table)\n\nlng_ext_st <- selection_table(X = lng.selec.table, pb = FALSE, \n                        extended = TRUE)\n\nlng_ext_st\n\n```\n\n```{r extn_sel_9.2, echo=FALSE}\n\nlng.selec.table <- do.call(rbind, replicate(100, lbh_selec_table, \n                        simplify = FALSE))[1:1000,]\n\nlng.selec.table$selec <- 1:nrow(lng.selec.table)\n\nlng_ext_st <- selection_table(X = lng.selec.table, pb = FALSE, \n                        extended = TRUE)\n\nprint(lng_ext_st)\n\n\n```\n\n```{r extn_sel_9.3}\n\nformat(object.size(lng_ext_st), units = \"auto\")\n\n```\n\n \n\nAs you can see, the object size is only \\~ 31 MB. Then, as a guide, a selection box with 1000 selections similar to those of 'lbh_selec_table' (average duration of \\~ 0.15 seconds) at a sampling rate of 22.5 kHz and the default margin (mar = 0.1) will generate an extended selection box \\~ 31 MB or \\~ 310 MB for a selection table of 10,000 rows.\n\n \n\n### Analysis using extended selection tables\n\nThese objects can be used as input for most **warbleR** functions. Here are some examples of **warbleR** functions using *extended_selection_table*:\n\n#### Spectral parameters\n\n```{r extn_sel_12.1, eval=TRUE}\n\n#  spectrographic parameters\nsp <- spectro_analysis(ext_st)\n\nsp\n```\n\n \n\n#### Signal-to-noise ratio\n\n```{r extn_sel_12.5, eval=TRUE}\n\nsnr <- sig2noise(ext_st, mar = 0.05)\n\nsnr\n```\n\n \n\n#### Dynamic time warping (DTW)\n\n```{r extn_sel_12.7, eval=FALSE}\n\ndtw.dist <- freq_DTW(ext_st, img = FALSE)\n\ndtw.dist\n\n```\n\n```{r extn_sel_12.8, echo=TRUE}\n\ndtw.dist <- freq_DTW(ext_st, img = FALSE)\n\nas.data.frame(dtw.dist)\n\n```\n\n \n\n### Performance\n\nThe use of *extended_selection_table* objects can improve performance (in our case, measured as time). Here we use **microbenchmark** to compare the performance of `sig2noise()` and **ggplot2** to plot the results:\n\n```{r extn_sel_13, out.width= 750, dpi = 100}\n\n# load packages\nlibrary(microbenchmark)\nlibrary(ggplot2)\n\n# take first 100 selections\nmbmrk.snr <- microbenchmark(extended = sig2noise(lng_ext_st[1:100, ], \n      mar = 0.05), regular = sig2noise(lng.selec.table[1:100, ], \n                    mar = 0.05), times = 50)\n\nautoplot(mbmrk.snr) + ggtitle(\"sig2noise\")\n\n```\n\n \n\nThe function runs much faster in the extended selection tables. Performance gain is likely to improve when longer recordings and data sets are used (that is, to compensate for computer overload).\n\n \n\n### Create selections 'by song'\n\nThe extended selection above were made by element. That is, each sound file within the object contains a single selection (that is, a 1: 1 correspondence between the selections and the 'wave' objects). However, extended selection tables can also be created using a higher hierarchical level with the argument `by.song`. In this case, \"song\" represents a higher level that contains one or more selections and that the user may want to keep together for a particular analysis (for example, the duration of the intervals). The `by.song` argument takes the name of the column of characters or factors with the IDs of the different\" songs \"within a sound file (note that the function assumes that a given song can only be found in only one sound file, so the selections with the same song ID, but from different sound files are taken as different 'songs').\n\nTo create a selection table by song, let's add an artificial song column to our example data in which each of the sound files has 2 songs:\n\n```{r extn_sel_14}\n\n# add column\nlbh_selec_table$song <- c(1, 1, 2, 1, 2, 1, 1, 2, 1, 2, 2)\n\n```\n\n \n\nThe data looks like this:\n\n```{r, extn_sel_15, echo= FALSE}\n\nlbh_selec_table\n\n```\n\n \n\nNow we can create an extended selection table 'by song' using the column name 'song' as input for the argument `by.song`:\n\n```{r extn_sel_16}\n\nbs_ext_st <- selection_table(X = lbh_selec_table, extended = TRUE,\n                             by.song = \"song\")\n\n```\n\nIn this case, we should only have 8 'wave' objects instead of 11 as when the object was created 'by selection':\n\n```{r extn_sel_17}\n\n# by element\nlength(attr(ext_st, \"wave.objects\"))\n\n# by song\nlength(attr(bs_ext_st, \"wave.objects\"))\n\n```\n\nAgain, these objects can also be used in any analyzes:\n\n```{r extn_sel_18}\n\n# signal to noise ratio\nbs_snr <- sig2noise(bs_ext_st, mar = 0.05)\n\nbs_snr\n```\n\n \n\n::: {.alert .alert-info}\n<font size=\"5\">Exercise</font>\n\n \n\n-   Compare the size of an extended selection table created by element to that of one created by song using the sample data\n:::\n\n \n\n### Sharing acoustic data\n\nThis new object class allows to share complete data sets, including acoustic data. For example, the following code downloads a subset of the data used in [Araya-Salas *et al* (2019)](https://marce10.github.io/uploads/araya-salas-2019-a.pdf) (can also be downloaded from  [Araya-Salas *et al* (2017)](https://github.com/maRce10/PR_BIR_2024/raw/master/data/extended.selection.table.araya-salas.et.al.2017.bioacoustics.100.sels.rds):\n\n```{r extn.sel_19, eval = FALSE}\n\nURL <- \"https://github.com/maRce10/PR_BIR_2024/raw/master/data/extended.selection.table.araya-salas.et.al.2017.bioacoustics.100.sels.rds\"\n\ndat <- readRDS(gzcon(url(URL)))\n\nnrow(dat)\n\nformat(object.size(dat), units = \"auto\")\n\n```\n\n```{r extn.sel_19-2, echo = FALSE}\n\ndat <- readRDS(\"./data/extended.selection.table.araya-salas.et.al.2017.bioacoustics.100.sels.rds\")\n\nnrow(dat)\n\nformat(object.size(dat), units = \"auto\")\n\n```\n\nThe total size of the 100 sound files from which these selections were taken adds up to 1.1 GB. The size of the extended selection table is only 10.1 MB.\n\nThis data is ready to be used:\n\n```{r, eval = TRUE}\nsp <- spectro_analysis(dat, bp = c(2, 10))\n\nhead(sp)\n```\n\n... and the spectrograms can be visualized as follows:\n\n```{r extn.sel_21, out.width= 750}\n\npar(mfrow = c(3, 2), mar = rep(0, 4))\n\nfor(i in 1:6){\n  \n  wv <- read_sound_file(X = dat, index = i, from = 0.17, to = 0.4)\n\n  spectro(wv, wl = 250, grid = FALSE, scale = FALSE, axisX = FALSE,\n          axisY = FALSE, ovlp = 90, flim = c(0, 12), \n          palette = reverse.gray.colors.1)\n}\n\n```\n\nThe **NatureSounds** package contains an extended selection table with long-billed hermit hummingbirds vocalizations from 10 different song types:\n\n```{r}\n\ndata(\"Phae.long.est\")\n\nPhae.long.est\n\ntable(Phae.long.est$lek.song.type)\n\n```\n\nThe ability to compress large data sets and the ease of performing analyzes that require a single R object can simplify the exchange of data and the reproducibility of bioacoustic analyzes.\n\n \n\n::: {.alert .alert-info}\n<font size=\"5\">Exercise</font>\n\n \n\n-   Download the extended selection tables of bat social calls from the [this figshare repository](https://figshare.com/articles/dataset/Supplementary_materials_Ontogeny_of_an_interactive_call-and-response_system_in_Spix_s_disc-winged_bats_PART_1/11651772) (scroll till the end of the file list) and create spectrograms for the first 5 selections of each table (either `spectrograms()` or `spectro()` would work)\n:::\n\n \n\n## **warbleR** functions and the workflow of analysis in bioacoustics\n\nBioacoustic analyzes generally follow a specific processing sequence and analysis. This sequence can be represented schematically like this:\n\n```{r, eval = FALSE, echo = FALSE}\n\nlibrary(warbleR)\n\nwf <- ls(\"package:warbleR\")\n\nwf <- wf[-c(2, 7, 8, 10, 12, 16, 17, 19, 20, 23, 24, 28, 31, 32, 33, 38, 42, 43, 44, 47, 50, 53, 59, 64, 66, 68, 68, 72, 74, 80, 81, 85, 90, 93, 94, 96)]\n\ndf <- data.frame(funciones = wf, `Obtener-preparar grabaciones` = \"\", `Anotar` = \"\", `Medir` = \"\",  `Revision` = \"\", `Inspección visual` = \"\", `Análisis estadístico` = \"\", `Otros` = \"\")\n\ndf2 <- edit(df)\n\n\ndf2$`organizar.anotaciones` <- \"\" \n\nnames(df2) <- names(df2)[c(1:3, 9, 4:8)]\n\ndf3 <- edit(df2)\n\ndf4 <- df3\n\ndf4[is.na(df4)] <- \"\"\n\ndf4 <- df4[df4$Obtener.preparar.grabaciones != \"borrar\", ]\n\nnames(df4) <- c(\"Función\", \"Obtener-preparar grabaciones\", \"Anotar\", \"Organizar anotaciones\", \"Medir estructura\", \"Verificar\", \"Inspección visual\", \"Análisis estadístico\", \"Otros\")\n\nrownames(df4) <- 1:nrow(df4)\n\ndf5 <- df4[order(df4$`Obtener-preparar grabaciones`, df4$Anotar, df4$`Organizar anotaciones`, df4$`Medir estructura`, df4$Verificar, df4$`Inspección visual`, df4$`Análisis estadístico`, df4$Otros, decreasing = TRUE),]\n\ndf4 <- df4[c(5, 8, 18, 29, 34, 35, 37, 38, 39, 55, 56, 26, 1, 19, 40, 46, 4, 11, 16, 17, 24, 25, 32, 41, 45, 7, 12, 13, 14, 15, 23, 27, 30, 42, 47, 48, 57, 2,  3, 28, 44, 50, 51, 52, 58, 9, 10, 21, 22, 59, 6, 20, 31, 33, 36, 43, 49, 53, 54), ]\n\n# write.csv(df4, \"cuadro de funciones warbleR.csv\", row.names = FALSE)\n\n```\n\n<img src=\"images/analysis-workflow.png\" alt=\"analysis workflow\"/>\n\n \n\nWe can group **warbleR** functions according to the bioacoustic analysis stages.\n\n \n\n### Get and prepare recordings\n\nThe `query_xc()` function allows you to search and download sounds from the free access database [Xeno-Canto](https://xeno-canto.org/). You can also convert .mp3 files to .wav, change the sampling rate of the files and correct corrupt files, among other functions.\n\n```{r, echo = FALSE}\n\ncf2 <- cf[cf$Obtener.preparar.grabaciones == \"x\", c(\"Function\", \"Description\", \"Works.on\", \"Output\")]\n\ncf2$Function <- kableExtra::cell_spec(x = cf2$Function, link = paste0(\"https://marce10.github.io/warbleR/reference/\", cf2$Function, \".html\"))\n\nkbl <- knitr::kable(cf2, align = \"c\", row.names = F,  format = \"html\", escape = F)\n\nkbl <- kableExtra::column_spec(kbl, 1, bold = TRUE)\n\nkbl <- kableExtra::column_spec(kbl, 2:4, italic = TRUE)\n\nkbl <-  kableExtra::kable_styling(kbl, bootstrap_options = \"striped\", font_size = 14)\n\nkbl\n\n```\n\n \n\n### Annotating sound\n\nIt is recommended to make annotations in other programs and then import them into R (for example in Raven and import them with the **Rraven** package). However, **warbleR** offers some functions to facilitate manual or automatic annotation of sound files, as well as the subsequent manipulation:\n\n```{r, echo = FALSE}\n\ncf2 <- cf[cf$Anotar == \"x\",  c(\"Function\", \"Description\", \"Works.on\", \"Output\")]\n\ncf2$Function <- kableExtra::cell_spec(x = cf2$Function, link = paste0(\"https://marce10.github.io/warbleR/reference/\", cf2$Function, \".html\"))\n\nkbl <- knitr::kable(cf2, align = \"c\", row.names = F,  format = \"html\", escape = F)\n\nkbl <- kableExtra::column_spec(kbl, 1, bold = TRUE)\n\nkbl <- kableExtra::column_spec(kbl, 2:4, italic = TRUE)\n\nkbl <-  kableExtra::kable_styling(kbl, bootstrap_options = \"striped\", font_size = 14)\n\nkbl\n\n```\n\n \n\n### Organize annotations\n\nThe annotations (or selection tables) can be manipulated and refined with a variety of functions. Selection tables can also be converted into the compact format *extended selection tables*:\n\n```{r, echo = FALSE}\n\ncf2 <- cf[cf$`Anotar` == \"x\",  c(\"Function\", \"Description\", \"Works.on\", \"Output\")]\n\ncf2$Function <- kableExtra::cell_spec(x = cf2$Function, link = paste0(\"https://marce10.github.io/warbleR/reference/\", cf2$Function, \".html\"))\n\nkbl <- knitr::kable(cf2, align = \"c\", row.names = F,  format = \"html\", escape = F)\n\nkbl <- kableExtra::column_spec(kbl, 1, bold = TRUE)\n\nkbl <- kableExtra::column_spec(kbl, 2:4, italic = TRUE)\n\nkbl <- kableExtra::kable_styling(kbl, bootstrap_options = \"striped\", font_size = 14)\n\nkbl\n\n```\n\n \n\n### Measure acoustic signal structure\n\nMost **warbleR** functions are dedicated to quantifying the structure of acoustic signals listed in selection tables using batch processing. For this, 4 main measurement methods are offered:\n\n1.  Spectrographic parameters\n2.  Cross correlation\n3.  Dynamic time warping (DTW)\n4.  Statistical descriptors of cepstral coefficients\n\nMost functions gravitate around these methods, or variations of these methods:\n\n```{r, echo = FALSE}\n\ncf2 <- cf[cf$`Medir.estructura` == \"x\",  c(\"Function\", \"Description\", \"Works.on\", \"Output\")]\n\ncf2$Function <- kableExtra::cell_spec(x = cf2$Function, link = paste0(\"https://marce10.github.io/warbleR/reference/\", cf2$Function, \".html\"))\n\nkbl <- knitr::kable(cf2, align = \"c\", row.names = F,  format = \"html\", escape = F)\n\nkbl <- kableExtra::column_spec(kbl, 1, bold = TRUE)\n\nkbl <- kableExtra::column_spec(kbl, 2:4, italic = TRUE)\n\nkbl <-  kableExtra::kable_styling(kbl, bootstrap_options = \"striped\", font_size = 14)\n\nkbl\n\n```\n\n \n\n::: {.alert .alert-info}\n<font size=\"5\">Exercise</font>\n\n \n\n-   Compare the performance of `spectro_analysis()` on the example 'lbh_selec_table' with \"the argument 'fast = TRUE' vs 'fast = FALSE'. What does this argument do and which `seewave` function might be involved?\n:::\n\n \n\n### Verify annotations\n\nFunctions are provided to detect inconsistencies in the selection tables or modify selection tables. The package also offers several functions to generate spectrograms showing the annotations, which can be organized by annotation categories. This allows you to verify if the annotations match the previously defined categories, which is particularly useful if the annotations were automatically generated.\n\n```{r, echo = FALSE}\n\ncf2 <- cf[cf$Verificar == \"x\",  c(\"Function\", \"Description\", \"Works.on\", \"Output\")]\n\ncf2$Function <- kableExtra::cell_spec(x = cf2$Function, link = paste0(\"https://marce10.github.io/warbleR/reference/\", cf2$Function, \".html\"))\n\nkbl <- knitr::kable(cf2, align = \"c\", row.names = F,  format = \"html\", escape = F)\n\nkbl <- kableExtra::column_spec(kbl, 1, bold = TRUE)\n\nkbl <- kableExtra::column_spec(kbl, 2:4, italic = TRUE)\n\nkbl <-  kableExtra::kable_styling(kbl, bootstrap_options = \"striped\", font_size = 14)\n\nkbl\n\n```\n\n \n\n### Visually inspection of annotations and measurements\n\n```{r, echo = FALSE}\n\ncf2 <- cf[cf$`Inspeccion.visual` == \"x\",  c(\"Function\", \"Description\", \"Works.on\", \"Output\")]\n\ncf2$Function <- kableExtra::cell_spec(x = cf2$Function, link = paste0(\"https://marce10.github.io/warbleR/reference/\", cf2$Function, \".html\"))\n\nkbl <- knitr::kable(cf2, align = \"c\", row.names = F,  format = \"html\", escape = F)\n\nkbl <- kableExtra::column_spec(kbl, 1, bold = TRUE)\n\nkbl <- kableExtra::column_spec(kbl, 2:4, italic = TRUE)\n\nkbl <-  kableExtra::kable_styling(kbl, bootstrap_options = \"striped\", font_size = 14)\n\nkbl\n\n\n```\n\n \n\n### Additional functions\n\nFinally, **warbleR** offers functions to simplify the use of extended selection tables, organize large numbers of images with spectrograms and generate elaborated signal visualizations:\n\n```{r, echo = FALSE}\n\ncf2 <- cf[cf$Analisis.estadistico == \"x\" | cf$Otros == \"x\",  c(\"Function\", \"Description\", \"Works.on\", \"Output\")]\n\ncf2$Function <- kableExtra::cell_spec(x = cf2$Function, link = paste0(\"https://marce10.github.io/warbleR/reference/\", cf2$Function, \".html\"))\n\nkbl <- knitr::kable(cf2, align = \"c\", row.names = F,  format = \"html\", escape = F)\n\nkbl <- kableExtra::column_spec(kbl, 1, bold = TRUE)\n\nkbl <- kableExtra::column_spec(kbl, 2:4, italic = TRUE)\n\nkbl <- kableExtra::kable_styling(kbl, bootstrap_options = \"striped\", font_size = 14)\n\nkbl\n\n```\n\n \n\n::: {.alert .alert-info}\n<font size=\"5\">Exercise</font>\n\n \n\n-   Run the examples of the functions `phylo_spectro()` and `color_spectro()`\n\n-   Use the `query_xc()` and `map_xc()` functions to explore the geographical distribution of the Xeno-Canto recordings of a species (of bird) of your interest (if any!)\n:::\n\n \n\n------------------------------------------------------------------------\n\n## References\n\n1.  Araya-Salas M, G Smith-Vidaurre & M Webster. (2019). Assessing the effect of sound file compression and background noise on measures of acoustic signal structure. Bioacoustics 4622, 1--17\n2.  Araya-Salas M, Smith-Vidaurre G (2017) warbleR: An R package to streamline analysis of animal acoustic signals. Methods Ecol Evol 8:184--191.\n\n \n\n------------------------------------------------------------------------\n\n<font size=\"4\">Session information</font>\n\n```{r session info, echo=F}\n\nsessionInfo()\n\n```\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"kable","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"show","code-overflow":"wrap","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":true,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"toc-depth":2,"number-sections":true,"highlight-style":"pygments","css":["styles.css"],"output-file":"intro_to_warbler.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.4.551","toc-location":"left","toc-title":"Contents","code-copy":true,"date":"today","title":"<font size=\"7\"><b>Introduction to warbleR</b></font>"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}