[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Bioacoustic data analysis with R 2024",
    "section": "",
    "text": "Bioacoustic data analysis with R\n\n\nPR Stats\n\n\n\nMarcelo Araya-Salas, PhD\n\n\n\nOctober 14 - 18, 2024\n\n\n\n\nThe study of animal acoustic signals is a central tool for many fields in behavior, ecology, evolution and biodiversity monitoring. The accessibility of recording equipment and growing availability of open-access acoustic libraries provide an unprecedented opportunity to study animal acoustic signals at large temporal, geographic and taxonomic scales. However, the diversity of analytical methods and the multidimensionality of these signals posts significant challenges to conduct analyses that can quantify biologically meaningful variation. The recent development of acoustic analysis tools in the R programming environment provides a powerful means for overcoming these challenges, facilitating the gathering and organization of large acoustic data sets and the use of more elaborated analyses that better fit the studied acoustic signals and associated biological questions. The course will introduce students on the basic concepts in animal acoustic signal research as well as hands-on experience on analytical tools in R.\n\nObjetive\nTraining biological science students and researchers in the detection and analysis of animal sounds in R. Specifically, it seeks to familiarize participants with computational tools in the R environment aiming at curating, detecting and analyzing animal acoustic signals, with an especial focus on quantifying fine-scale structural variation. The course will introduce the most relevant acoustics concepts to allow a detailed understanding of the metrics used for characterize acoustic signals. It will also guide participants through a variety of R packages for bioacoustics analysis, including seewave, tuneR, warbleR and baRulho."
  },
  {
    "objectID": "course_prep.html",
    "href": "course_prep.html",
    "title": "Bioacoustic data analysis with R 2024",
    "section": "",
    "text": "Install or update R on the computer you will use during the course (https://cran.r-project.org). I assume that you already have it installed, but try to update it if you have a R version &lt; 4.0.0. You can find which R version you have by running this in the R console:\n\n\nversion$version.string\n\n\nUpdate all R packages if you already had R installed (⚠️ this step can take a long time to run ⚠️):\n\n\nupdate.packages(ask = FALSE)\n\n\nInstall or update the RStudio interface (https://www.rstudio.com/products/rstudio/download/, choose the free version). Optional but advised.\nMake a directory called “BIAC04”, this will be your working directory for the course.\nOpen RStudio and select the tab “Tools” then “Global Options” (last option). Select the “Code” option, then select the box for “Soft-wrap R source files”.\nAlso in Rstudio: Select the “Pane Layout” option and move “Source” to the top left pane and “Console” to the top right pane. For those of you unfamiliar with RStudio, the source is your script, where you save code in a physical file (usually .R script) and the console prints the output of the code you run from the source. You can write code in the console, but it will not be saved in a physical file. This layout allocates more screen space to the most useful panes. Hit “Apply” and “Ok”.\nAlso in Rstudio: Go back up to the “File” tab and select “New Project”, then select the “BIAC04” directory.\nNow in the R console in Rstudio: Run the following code to install the latest developmental versions (from github) of warbleR, Rraven, PhenotypeSpace, ohun, baRulho and dynaSpec (remove the packages first if you have them installed already).\n\n\n# package to install other packages from github\nif (!requireNamespace(\"sketchy\"))\n  install.packages(\"sketchy\") \n\n# load package\nlibrary(sketchy)\n\n# install/load packages\nload_packages(packages = c(\n  \"pracma\",\n  \"Sim.DiffProc\",\n  \"bioacoustics\",\n  \"phonTools\",\n  \"soundgen\",\n  \"audio\",\n  github = \"maRce10/warbleR\",\n  github = \"maRce10/Rraven\",\n  github = \"maRce10/ohun\",\n  github = \"maRce10/suwo\",\n  github = \"maRce10/baRulho\",\n  github = \"maRce10/dynaSpec\",\n  github = \"maRce10/PhenotypeSpace\"\n )\n)\n\nif you have any issue installing ‘bioacoustics’ take a look at this fix: https://stackoverflow.com/questions/53092646/unable-to-install-warbler-package-using-mac-os\n\nwarbleR depends heavily on the R package seewave. Seewave may require some extra steps to get installed. Take a look at seewave’s website for further help: http://rug.mnhn.fr/seewave (and then go to “installation” and scroll down)\nInstall Raven lite from ttp://ravensoundsoftware.com/raven-pricing/(scroll down to “Raven Lite 2.0” and click on “Order Free Raven Lite 2.0 License”). Ignore if you have any Raven version already installed.\nInstall ffmpeg (only needed for dynaSpec package, not critical):\n\nhttps://ffmpeg.org/download.html\ntake a look at this link if you have issues installing ffmpeg on windows:\nhttps://github.com/maRce10/dynaSpec/issues/3\n\nInstall Audacity (not critical, you can use Adobe Audition instead):\n\nhttps://www.audacityteam.org/download/\n\nInstall SOX. It can be downloaded from here (not critical but could be useful): http://sox.sourceforge.net (Not critical)\nInstall FLAC. It can be downloaded from here (also not critical): https://xiph.org/flac/download.html (Not critical)\nNote that you can also run the code using google colab. Take a look at this notebook: https://colab.research.google.com/\n\n \n\nA few tips to make sure you will take full advantage of the course:\n\nSet aside a physical space, hopefully as isolated as possible from external stimuli\nUse headphones/earphones to avoid any interference from echoes or external noises\nIdeally, read the materials ahead of time (I know! it’s time comsuming)\nMake sure you have anything you need before the start of the class\nBe ready a few minutes before the start of the class\nTry to focus as much as possible in the course, close other programs or unnecessary internet browser tabs (i.e. instagram, twitter, etc). This will also make the computer more efficient (less likely to get slow)\nComment your code"
  },
  {
    "objectID": "r_basics.html#objetives",
    "href": "r_basics.html#objetives",
    "title": "R basics",
    "section": "Objetives",
    "text": "Objetives\n\nRevisit the basic syntax and data structures in R\nGet familiar with documentation and help resources"
  },
  {
    "objectID": "r_basics.html#what-is-r",
    "href": "r_basics.html#what-is-r",
    "title": "R basics",
    "section": "1 What is R?",
    "text": "1 What is R?\n\nA free Domain-Specific-Language (DSL) for statistics and data analysis\nA collection of over 19514 (may-12-2024) libraries\nA large and active community across industry and academia\nA way to talk “directly” to your computer\n\nHistorically:\n\nBased on the S Programming Language\nAround 20 years old (Lineage dates from 1975 - almost 40 years ago)"
  },
  {
    "objectID": "r_basics.html#rstudio",
    "href": "r_basics.html#rstudio",
    "title": "R basics",
    "section": "2 Rstudio",
    "text": "2 Rstudio\nIntegrated development environment (IDE) for R. Includes:\n\nA console\nSyntax-highlighting editor that supports direct code execution\nTools for plotting, history, debugging and workspace management"
  },
  {
    "objectID": "r_basics.html#elements-of-the-r-language",
    "href": "r_basics.html#elements-of-the-r-language",
    "title": "R basics",
    "section": "3 Elements of the R language",
    "text": "3 Elements of the R language\n\nVectors\nLists\nMatrices\nData Frames\nFunctions (including operators)\nAttributes\nTables\nArrays\nEnvironments\n\nData structure\nThe basic data structure in R is the vector. There are two basic types of vectors: atomic vectors and lists.\nThey have three common properties:\n\nType, typeof() (~ class/mode)\nLength, length() (number of elements)\nAttributes, attributes() (metadata)\n\nThey differ in the types of their elements: all elements of an atomic vector must be the same type, whereas the elements of a list can have different types.\n\n\n\n\n\n\n\nHomogeneous\nHeterogeneous\n\n\n\n\n1d\nAtomic vector\nList\n\n\n2d\nMatrix\nData frame\n\n\nnd\nArray\n\n\n\n\n\n\n\n \nR has no 0-dimensional elements (scalars). Individual numbers or strings are actually vectors of length one.\nAtomic vectors\nTypes of atomic vectors:\n\nLogical (boolean)\nInteger\nNumeric (double)\nCharacter\n\nVectors are built using c():\n\n\nCode\n\nx &lt;- 1\nx1 &lt;- c(1)\n\nall.equal(x, x1)\n## [1] TRUE\n\nclass(x)\n## [1] \"numeric\"\n\ny &lt;- \"something\"\n\nclass(y)\n## [1] \"character\"\n\nw &lt;- 1L\n\nclass(w)\n## [1] \"integer\"\n \nz &lt;- TRUE\n\nclass(z)\n## [1] \"logical\"\n\nq &lt;- factor(1)\n\nclass(q)\n## [1] \"factor\"\n\n\n \nVectors can only contain entries of the same type. Different types will be coerced to the most flexible type:\n\n\nCode\n\nv &lt;- c(10, 11, 12, 13)\n\nclass(v)\n## [1] \"numeric\"\n\nis.integer(v)\n## [1] FALSE\n\ny &lt;- c(\"Amazona\", \"Ara\", \"Eupsittula\", \"Myiopsitta\")\n\nclass(y)\n## [1] \"character\"\n\nis.integer(y)\n## [1] FALSE\n\nx &lt;- c(1,2,3, \"Myiopsitta\")\n\nx\n## [1] \"1\"          \"2\"          \"3\"          \"Myiopsitta\"\n\nclass(x)\n## [1] \"character\"\n\n\n \nMissing values are specified with NA, which is a logical vector of length 1. NA will always be coerced to the correct type if used inside c():\n\n\nCode\n\nv &lt;- c(10, 11, 12, 13, NA)\n\nclass(v)\n## [1] \"numeric\"\n\nv &lt;- c(letters[1:3], NA)\n\nclass(v)\n## [1] \"character\"\n\n\n \nLists\nCan contain objects of different classes and sizes. Lists are built using list():\n\n\nCode\nl &lt;- list(ID = c(\"a\", \"b\", \"c\", \"d\", \"e\"), \n          size = c(1, 2, 3, 4, 5), \n          observed = c(FALSE, TRUE, FALSE, FALSE, FALSE))\n\nl\n\n\n$ID\n[1] \"a\" \"b\" \"c\" \"d\" \"e\"\n\n$size\n[1] 1 2 3 4 5\n\n$observed\n[1] FALSE  TRUE FALSE FALSE FALSE\n\n\nCode\nclass(l)\n\n\n[1] \"list\"\n\n\nCode\nstr(l)\n\n\nList of 3\n $ ID      : chr [1:5] \"a\" \"b\" \"c\" \"d\" ...\n $ size    : num [1:5] 1 2 3 4 5\n $ observed: logi [1:5] FALSE TRUE FALSE FALSE FALSE\n\n\n… and dimensions:\n\n\nCode\nl &lt;- list(ID = c(\"a\", \"b\", \"c\", \"d\", \"e\"), \n          size = c(1, 2, 3, 4, 5, 6), \n          observed = c(FALSE, TRUE, FALSE, FALSE, FALSE), \n          l)\n\nstr(l)\n\n\nList of 4\n $ ID      : chr [1:5] \"a\" \"b\" \"c\" \"d\" ...\n $ size    : num [1:6] 1 2 3 4 5 6\n $ observed: logi [1:5] FALSE TRUE FALSE FALSE FALSE\n $         :List of 3\n  ..$ ID      : chr [1:5] \"a\" \"b\" \"c\" \"d\" ...\n  ..$ size    : num [1:5] 1 2 3 4 5\n  ..$ observed: logi [1:5] FALSE TRUE FALSE FALSE FALSE\n\n\nCode\nl2 &lt;- list(l, l)\n\nstr(l2)\n\n\nList of 2\n $ :List of 4\n  ..$ ID      : chr [1:5] \"a\" \"b\" \"c\" \"d\" ...\n  ..$ size    : num [1:6] 1 2 3 4 5 6\n  ..$ observed: logi [1:5] FALSE TRUE FALSE FALSE FALSE\n  ..$         :List of 3\n  .. ..$ ID      : chr [1:5] \"a\" \"b\" \"c\" \"d\" ...\n  .. ..$ size    : num [1:5] 1 2 3 4 5\n  .. ..$ observed: logi [1:5] FALSE TRUE FALSE FALSE FALSE\n $ :List of 4\n  ..$ ID      : chr [1:5] \"a\" \"b\" \"c\" \"d\" ...\n  ..$ size    : num [1:6] 1 2 3 4 5 6\n  ..$ observed: logi [1:5] FALSE TRUE FALSE FALSE FALSE\n  ..$         :List of 3\n  .. ..$ ID      : chr [1:5] \"a\" \"b\" \"c\" \"d\" ...\n  .. ..$ size    : num [1:5] 1 2 3 4 5\n  .. ..$ observed: logi [1:5] FALSE TRUE FALSE FALSE FALSE\n\n\n \nAttributes\nObjects can have attributes. Attributes allow to store metadata about the object. Attributes are kind of named lists. Attributes can be accessed individually with attr() or all at once (as a list) with attributes():\n\n\nCode\ny &lt;- 1:10\n\nmean(y)\n\n\n[1] 5.5\n\n\nCode\nattr(y, \"my_attribute\") &lt;- \"This is an attribute\"\n\n\nattr(y, \"my_attribute\")\n\n\n[1] \"This is an attribute\"\n\n\nCode\nstr(y)\n\n\n int [1:10] 1 2 3 4 5 6 7 8 9 10\n - attr(*, \"my_attribute\")= chr \"This is an attribute\"\n\n\n \nMost attributes are lost when modifying a vector:\n\n\nCode\nattributes(y[1])\n\n\nNULL\n\n\n \nThe only attributes not lost are the three most important:\n\nNames, a character vector giving each element a name, described in names\nDimensions\nClass\n\n\n\n\nCode\nw &lt;- structure(c(a =1, b = 2), my_attribute = \"This is not an apple\")\n\nattributes(w)\n\n\n$names\n[1] \"a\" \"b\"\n\n$my_attribute\n[1] \"This is not an apple\"\n\n\nCode\nattributes(w[1])\n\n\n$names\n[1] \"a\"\n\n\nCode\nclass(w[1])\n\n\n[1] \"numeric\"\n\n\n \nFactors\nAttributes are used to define factors. A factor is a vector that can contain only predefined values, and is used to store categorical data.\nFactors are built on top of integer vectors using two attributes:\n\nclass “factor”: makes them behave differently from regular integer vectors\nlevels: defines the set of allowed values\n\n\n\nCode\nx &lt;- factor(c(\"a\", \"b\", \"b\", \"a\"))\nx\n\n\n[1] a b b a\nLevels: a b\n\n\nCode\nlevels(x)\n\n\n[1] \"a\" \"b\"\n\n\nCode\nstr(x)\n\n\n Factor w/ 2 levels \"a\",\"b\": 1 2 2 1\n\n\n \nFactors look like character vectors but they are actually integers:\n\n\nCode\nx &lt;- factor(c(\"a\", \"b\", \"b\", \"a\"))\n\nc(x)\n\n\n[1] a b b a\nLevels: a b\n\n\n \nMatrices\nAll entries are of the same type:\n\n\nCode\nm &lt;- matrix(c(1, 2, 3, 11, 12, 13), nrow = 2)\n\ndim(m)\n\n\n[1] 2 3\n\n\nCode\nm\n\n\n     [,1] [,2] [,3]\n[1,]    1    3   12\n[2,]    2   11   13\n\n\nCode\nclass(m)\n\n\n[1] \"matrix\" \"array\" \n\n\nCode\nm &lt;- matrix(c(1, 2, 3, 11, 12,\"13\"), nrow = 2)\nm\n\n\n     [,1] [,2] [,3]\n[1,] \"1\"  \"3\"  \"12\"\n[2,] \"2\"  \"11\" \"13\"\n\n\n \nData frames\nSpecial case of lists. Can contain entries of different types:\n\n\nCode\nm &lt;- data.frame(ID = c(\"a\", \"b\", \"c\", \"d\", \"e\"), \n                size = c(1, 2, 3, 4, 5), \n                observed = c(FALSE, TRUE, FALSE, FALSE, FALSE))\n\ndim(m)\n\n\n[1] 5 3\n\n\nCode\nm\n\n\n\n\n\n\nID\nsize\nobserved\n\n\n\n\na\n1\nFALSE\n\n\nb\n2\nTRUE\n\n\nc\n3\nFALSE\n\n\nd\n4\nFALSE\n\n\ne\n5\nFALSE\n\n\n\n\n\n\nCode\nclass(m)\n\n\n[1] \"data.frame\"\n\n\nCode\nis.data.frame(m)\n\n\n[1] TRUE\n\n\nCode\nis.list(m)\n\n\n[1] TRUE\n\n\nCode\nstr(m)\n\n\n'data.frame':   5 obs. of  3 variables:\n $ ID      : chr  \"a\" \"b\" \"c\" \"d\" ...\n $ size    : num  1 2 3 4 5\n $ observed: logi  FALSE TRUE FALSE FALSE FALSE\n\n\n \nBut vectors should have the same length:\n\n\nCode\nm &lt;- data.frame(ID = c(\"a\", \"b\", \"c\", \"d\", \"e\"), \n                size = c(1, 2, 3, 4, 5, 6), \n                observed = c(FALSE, TRUE, FALSE, FALSE, FALSE))\n\n\nError in data.frame(ID = c(\"a\", \"b\", \"c\", \"d\", \"e\"), size = c(1, 2, 3, : arguments imply differing number of rows: 5, 6"
  },
  {
    "objectID": "r_basics.html#data-subsetting",
    "href": "r_basics.html#data-subsetting",
    "title": "R basics",
    "section": "4 Data subsetting",
    "text": "4 Data subsetting\nIndexing\nElements within objects can be called by indexing. To subset a vector simply call the object position using square brackets:\n\n\nCode\nx &lt;- c(1, 3, 4, 10, 15, 20, 50, 1, 6)\n\nx[1]\n\n\n[1] 1\n\n\nCode\nx[2]\n\n\n[1] 3\n\n\nCode\nx[2:3]\n\n\n[1] 3 4\n\n\nCode\nx[c(1,3)]\n\n\n[1] 1 4\n\n\n \nElements can be removed in the same way:\n\n\nCode\nx[-1]\n\n\n[1]  3  4 10 15 20 50  1  6\n\n\nCode\nx[-c(1,3)]\n\n\n[1]  3 10 15 20 50  1  6\n\n\n \nMatrices and data frames required 2 indices [row, column]:\n\n\nCode\nm &lt;- matrix(c(1, 2, 3, 11, 12, 13), nrow = 2)\n\nm[1, ]\n\n\n[1]  1  3 12\n\n\nCode\nm[, 1]\n\n\n[1] 1 2\n\n\nCode\nm[1, 1]\n\n\n[1] 1\n\n\nCode\nm[-1, ]\n\n\n[1]  2 11 13\n\n\nCode\nm[, -1]\n\n\n     [,1] [,2]\n[1,]    3   12\n[2,]   11   13\n\n\nCode\nm[-1, -1]\n\n\n[1] 11 13\n\n\nCode\ndf &lt;- data.frame(family = c(\"Psittacidae\", \"Trochilidae\", \n                            \"Psittacidae\"), \n  genus = c(\"Amazona\", \"Phaethornis\", \"Ara\"), \n    species = c(\"aestiva\", \"philippii\", \"ararauna\"))\n\ndf\n\n\n\n\n\n\nfamily\ngenus\nspecies\n\n\n\n\nPsittacidae\nAmazona\naestiva\n\n\nTrochilidae\nPhaethornis\nphilippii\n\n\nPsittacidae\nAra\nararauna\n\n\n\n\n\n\nCode\ndf[1, ]\n\n\n\n\n\n\nfamily\ngenus\nspecies\n\n\n\n\nPsittacidae\nAmazona\naestiva\n\n\n\n\n\n\nCode\ndf[, 1]\n\n\n[1] \"Psittacidae\" \"Trochilidae\" \"Psittacidae\"\n\n\nCode\ndf[1, 1]\n\n\n[1] \"Psittacidae\"\n\n\nCode\ndf[-1, ]\n\n\n\n\n\n\n\nfamily\ngenus\nspecies\n\n\n\n\n2\nTrochilidae\nPhaethornis\nphilippii\n\n\n3\nPsittacidae\nAra\nararauna\n\n\n\n\n\n\nCode\ndf[, -1]\n\n\n\n\n\n\ngenus\nspecies\n\n\n\n\nAmazona\naestiva\n\n\nPhaethornis\nphilippii\n\n\nAra\nararauna\n\n\n\n\n\n\nCode\ndf[-1, -1]\n\n\n\n\n\n\n\ngenus\nspecies\n\n\n\n\n2\nPhaethornis\nphilippii\n\n\n3\nAra\nararauna\n\n\n\n\n\n\nCode\ndf[,\"family\"]\n\n\n[1] \"Psittacidae\" \"Trochilidae\" \"Psittacidae\"\n\n\nCode\ndf[,c(\"family\", \"genus\")]\n\n\n\n\n\n\nfamily\ngenus\n\n\n\n\nPsittacidae\nAmazona\n\n\nTrochilidae\nPhaethornis\n\n\nPsittacidae\nAra\n\n\n\n\n\n\n \nLists require 1 index within double square brackets [[index]]:\n\n\nCode\nl &lt;- list(ID = c(\"a\", \"b\", \"c\", \"d\", \"e\"), size = c(1, 2, 3, 4, 5), observed = c(FALSE, TRUE, FALSE, FALSE, FALSE))\n\nl[[1]]\n\n\n[1] \"a\" \"b\" \"c\" \"d\" \"e\"\n\n\nCode\nl[[3]]\n\n\n[1] FALSE  TRUE FALSE FALSE FALSE\n\n\n \nElements within lists can also be subset in the same string of code:\n\n\nCode\nl[[1]][1:2]\n\n\n[1] \"a\" \"b\"\n\n\nCode\nl[[3]][2]\n\n\n[1] TRUE\n\n\n \nExploring objects\n\n\nCode\nstr(df)\n\n\n'data.frame':   3 obs. of  3 variables:\n $ family : chr  \"Psittacidae\" \"Trochilidae\" \"Psittacidae\"\n $ genus  : chr  \"Amazona\" \"Phaethornis\" \"Ara\"\n $ species: chr  \"aestiva\" \"philippii\" \"ararauna\"\n\n\nCode\nnames(df)\n\n\n[1] \"family\"  \"genus\"   \"species\"\n\n\nCode\ndim(df)\n\n\n[1] 3 3\n\n\nCode\nnrow(df)\n\n\n[1] 3\n\n\nCode\nncol(df)\n\n\n[1] 3\n\n\nCode\nhead(df)\n\n\n\n\n\n\nfamily\ngenus\nspecies\n\n\n\n\nPsittacidae\nAmazona\naestiva\n\n\nTrochilidae\nPhaethornis\nphilippii\n\n\nPsittacidae\nAra\nararauna\n\n\n\n\n\n\nCode\ntail(df)\n\n\n\n\n\n\nfamily\ngenus\nspecies\n\n\n\n\nPsittacidae\nAmazona\naestiva\n\n\nTrochilidae\nPhaethornis\nphilippii\n\n\nPsittacidae\nAra\nararauna\n\n\n\n\n\n\nCode\ntable(df$genus)\n\n\n\n    Amazona         Ara Phaethornis \n          1           1           1 \n\n\nCode\ntypeof(df)\n\n\n[1] \"list\"\n\n\n\n\nCode\nView(df)\n\n\n \n\nExercise\n \n\nUsing the example data iris to create a data subset with only the observations of the species ‘setosa’\nNow create a data subset containing the observations of both ‘setosa’ and ‘versicolor’\nAlso with iris create a data subset with the observations for which iris$Sepal.length is higher than 6\nHow many observations have a sepal length higher than 6?"
  },
  {
    "objectID": "r_basics.html#functions",
    "href": "r_basics.html#functions",
    "title": "R basics",
    "section": "5 Functions",
    "text": "5 Functions\nAll functions are created by the function function() and follow the same structure:\n\n* Modified from Grolemund 2014  \nR comes with many functions that you can use to do sophisticated tasks:\n\n\nCode\n# built in functions\nbi &lt;- builtins()\n\nlength(bi)\n\n\n[1] 1388\n\n\nCode\nsample(bi, 10)\n\n\n [1] \".kappa_tri\"       \"isSymmetric\"      \"loadedNamespaces\" \"as.list.difftime\"\n [5] \"write\"            \".doWrap\"          \"print.srcfile\"    \"matrix\"          \n [9] \"mget\"             \"cos\"             \n\n\n \nOperators are functions:\n\n\nCode\n1 + 1\n\n\n[1] 2\n\n\nCode\n'+'(1, 1)\n\n\n[1] 2\n\n\nCode\n2 * 3\n\n\n[1] 6\n\n\nCode\n'*'(2, 3)\n\n\n[1] 6\n\n\n \nMost commonly used R operators\nArithmetic operators:\n\n\n                                 Operator       Description        \nc.......addition..               \"+\"            \"addition\"         \nc.......subtraction..            \"-\"            \"subtraction\"      \nc.......multiplication..         \"*\"            \"multiplication\"   \nc.......division..               \"/\"            \"division\"         \nc....or.......exponent..         \"^ or **\"      \"exponent\"         \nc..x....y....modulus..x.mod.y... \"x %% y\"       \"modulus (x mod y)\"\nc..x.....y....integer.division.. \"x %/% y\"      \"integer division\" \n\n\n\n\nCode\n1 - 2\n\n\n[1] -1\n\n\nCode\n1 + 2\n\n\n[1] 3\n\n\nCode\n2 ^ 2\n\n\n[1] 4\n\n\n \nLogical operators:\n\n\n                                    Operator    Description               \nc.......less.than..                 \"&lt;\"         \"less than\"               \nc........less.than.or.equal.to..    \"&lt;=\"        \"less than or equal to\"   \nc.......greater.than..              \"&gt;\"         \"greater than\"            \nc........greater.than.or.equal.to.. \"&gt;=\"        \"greater than or equal to\"\nc........exactly.equal.to..         \"==\"        \"exactly equal to\"        \nc........not.equal.to..             \"!=\"        \"not equal to\"            \nc...x....Not.x..                    \"!x\"        \"Not x\"                   \nc..x...y.....tx.OR.y..              \"x | y\"     \"\\tx OR y\"                \nc..x...y....x.AND.y..               \"x & y\"     \"x AND y\"                 \nc..x..in..y....match..              \"x %in% y\"  \"match\"                   \n\n\n\n\nCode\n1 &lt; 2 \n\n\n[1] TRUE\n\n\nCode\n1 &gt; 2 \n\n\n[1] FALSE\n\n\nCode\n1 &lt;= 2 \n\n\n[1] TRUE\n\n\nCode\n1 == 2\n\n\n[1] FALSE\n\n\nCode\n1 != 2\n\n\n[1] TRUE\n\n\nCode\n1 &gt; 2 \n\n\n[1] FALSE\n\n\nCode\n5 %in% 1:6\n\n\n[1] TRUE\n\n\nCode\n5 %in% 1:4\n\n\n[1] FALSE\n\n\n \nMost functions are vectorized:\n\n\nCode\n1:6 * 1:6\n\n\n\n* Modified from Grolemund & Wickham 2017\n \n\n\n[1]  1  4  9 16 25 36\n\n\n\n\nCode\n1:6 - 1:6\n\n\n[1] 0 0 0 0 0 0\n\n\nR recycles vectors of unequal length:\n\n\nCode\n1:6 * 1:5\n\n\n\n* Modified from Grolemund & Wickham 2017\n \n\n\nWarning in 1:6 * 1:5: longitud de objeto mayor no es múltiplo de la longitud de\nuno menor\n\n\n[1]  1  4  9 16 25  6\n\n\n\n\nCode\n1:6 + 1:5\n\n\nWarning in 1:6 + 1:5: longitud de objeto mayor no es múltiplo de la longitud de\nuno menor\n\n\n[1]  2  4  6  8 10  7"
  },
  {
    "objectID": "r_basics.html#style-matters",
    "href": "r_basics.html#style-matters",
    "title": "R basics",
    "section": "6 Style matters",
    "text": "6 Style matters\nBased on google’s R Style Guide\nFile names\nFile names should end in .R and, of course, be meaningful:\n\nGOOD: predict_ad_revenue.R\nBAD: foo.R\n\nObject names\nVariables and functions:\n\nLowercase\nUse an underscore (_) (HW style)\nGenerally, nouns for variables and verbs for functions\nStrive for names that are concise and meaningful (not always easy)\nAvoid using names of existing functions of variables\n\n\n\nCode\n  - GOOD: day_one: day_1, mean.day(),\n  \n  - BAD: dayOne, day1, firstDay_of.month, mean &lt;- function(x) sum(x), c &lt;- 10\n\n\n \nSyntax\nSpacing:\n\nUse spaces around operators and for argument within a function\nAlways put a space after a comma, and never before (just like in regular English)\nPlace a space before left parenthesis, except in a function call\n\n\n\nCode\n  - GOOD: \n          a &lt;- rnorm(n = 10, sd = 10, mean = 1)\n          tab.prior &lt;- table(df[df$days.from.opt &lt; 0, \"campaign.id\"])\n          total &lt;- sum(x[, 1])\n          total &lt;- sum(x[1, ])\n          if (debug)\n          mean(1:10)\n          \n  - BAD: \n         a&lt;-rnorm(n=10,sd=10,mean=1)\n         tab.prior &lt;- table(df[df$days.from.opt&lt;0, \"campaign.id\"])  # Needs spaces around '&lt;'\n         tab.prior &lt;- table(df[df$days.from.opt &lt; 0,\"campaign.id\"])  # Needs a space after the comma\n         tab.prior&lt;- table(df[df$days.from.opt &lt; 0, \"campaign.id\"])  # Needs a space before &lt;-\n         tab.prior&lt;-table(df[df$days.from.opt &lt; 0, \"campaign.id\"])  # Needs spaces around &lt;-\n         total &lt;- sum(x[,1])  # Needs a space after the comma\n         total &lt;- sum(x[ ,1])  # Needs a space after the comma, not before  \n         if(debug) # Needs a space before parenthesis\n         mean (1:10) # ) # Extra space before parenthesis\n\n\n \nCurly braces:\n\nAn opening curly brace should never go on its own line\nClosing curly brace should always go on its own line\nYou may omit curly braces when a block consists of a single statement\n\n\n\nCode\n  - GOOD:\n              if (is.null(ylim)) {\n              ylim &lt;- c(0, 0.06)\n            }\n                      \n            if (is.null(ylim))\n              ylim &lt;- c(0, 0.06)\n          \n  - BAD:\n            \n         if (is.null(ylim)) ylim &lt;- c(0, 0.06)\n                    \n         if (is.null(ylim)) {ylim &lt;- c(0, 0.06)} \n\n         if (is.null(ylim)) {\n           ylim &lt;- c(0, 0.06)\n           } \n\n\n \nAssigments:\n\nUse &lt;-, not =\n\n\n\nCode\n  - GOOD:\n         x &lt;- 5 \n          \n  - BAD:\n         x = 5\n\n\n \nCommenting guidelines:\n\nComment your code\nEntire commented lines should begin with # and one space\nShort comments can be placed after code preceded by two spaces, #, and then one space\n\n\n\nCode\n# Create histogram of frequency of campaigns by pct budget spent.\nhist(df$pct.spent,\n     breaks = \"scott\",  # method for choosing number of buckets\n     main   = \"Histogram: fraction budget spent by campaignid\",\n     xlab   = \"Fraction of budget spent\",\n     ylab   = \"Frequency (count of campaignids)\")\n\n\n \nGeneral Layout and Ordering (google style):\n\nCopyright statement comment (?)\nAuthor comment\nFile description comment, including purpose of program, inputs, and outputs\nsource() and library() statements\nFunction definitions\nExecuted statements, if applicable (e.g., print, plot)"
  },
  {
    "objectID": "r_basics.html#r-documentation",
    "href": "r_basics.html#r-documentation",
    "title": "R basics",
    "section": "7 R documentation",
    "text": "7 R documentation\nMost R resources are extremely well documented. So the first source for help you should go to when writting R code is the R documention itself. All packages are documented in the same standard way. Getting familiar with the format can simplify things a lot.\nPackage documentation\n\n \nReference manuals\nReference manuals are collections of the documentation for all functions in a package (only 1 per package):\n\ndynaSpec manual\nbaRulho manual\n\n \nFunction documentation\nAll functions (default or from loaded packages) must have a documentation that follows a standard format:\n\n\nCode\n?mean\n\nhelp(\"mean\")\n\n\n  \nThis documentation can also be shown in Rstudio by pressing F1 when the cursor is on the function name\n \nIf you don’t recall the function name try apropos():\n\n\nCode\napropos(\"mean\")\n\n\n [1] \".colMeans\"     \".rowMeans\"     \"colMeans\"      \"kmeans\"       \n [5] \"mean\"          \"mean.Date\"     \"mean.default\"  \"mean.difftime\"\n [9] \"mean.POSIXct\"  \"mean.POSIXlt\"  \"rowMeans\"      \"weighted.mean\"\n\n\n \nVignettes\nVignettes are illustrative documents or study cases detailing the use of a package (optional, can be several per package).\nVignettes can be called directly from R:\n\n\nCode\nvgn &lt;- browseVignettes() \n\n\n\n\nCode\nvignette()\n\n\nThey should also be listed in the package CRAN page.\n \nDemonstrations\nPackages may also include extended code demonstrations (‘demos’). To list demos in a package run demo(\"package name\"):\n\n\nCode\ndemo(package=\"stats\")\n\n# call demo directly\ndemo(\"nlm\")\n\n\n \n\nExercise\n \n\nWhat does the function cut() do?\nWhat is the breaks argument in cut() used for?\nRun the first 4 lines of code in the examples supplied in the cut() documentation\nHow many vignettes does the package warbleR has?"
  },
  {
    "objectID": "r_basics.html#references",
    "href": "r_basics.html#references",
    "title": "R basics",
    "section": "8 References",
    "text": "8 References\n\nAdvanced R, H Wickham\nGoogle’s R Style Guide\n\nHands-On Programming with R (Grolemund, 2014)"
  },
  {
    "objectID": "r_basics.html",
    "href": "r_basics.html",
    "title": "Basic elements of the R language",
    "section": "",
    "text": "To understand the basic blocks used in R programming\nTo become familiar with the main sources of standardized documentation in R"
  },
  {
    "objectID": "r_basics.html#section",
    "href": "r_basics.html#section",
    "title": "Basic elements of the R language",
    "section": "2.1  ",
    "text": "2.1"
  },
  {
    "objectID": "r_basics.html#objects-containing-data",
    "href": "r_basics.html#objects-containing-data",
    "title": "Basic elements of the R language",
    "section": "3.1 Objects containing data",
    "text": "3.1 Objects containing data\nThe basic data structure in R is the vector. With this all other object classes are built. To understand classes it is useful to think about the number of dimensions (1, 2 or more) and types of data they can contain: homogeneous (a single element type) or heterogeneous (or multiple element types).\n\n\n\n\n\nflowchart LR\n    classDef largeText font-size:18px, padding:15px;\n\n    D(Data objects) --&gt; D1(1 dimension)\n    D --&gt; D2(2 dimensions)\n    D1 --&gt; V(Vector)\n    D1 --&gt; L(List)\n    D2 --&gt; M(Matrix)\n    D2 --&gt;  DF(Data Frame)\n\n    style D fill:#40498E66, stroke:#000, stroke-width:2px, color:#FFF, width:180px\n    style D1 fill:#348AA666, stroke:#000, stroke-width:2px, color:#FFF, width:140px\n    style D2 fill:#348AA666, stroke:#000, stroke-width:2px, color:#FFF, width:140px\n    style DF fill:#49C1AD66, stroke:#000, stroke-width:2px, color:#000\n    style V fill:#49C1AD66, stroke:#000, stroke-width:2px, color:#000\n    style M fill:#49C1AD66, stroke:#000, stroke-width:2px, color:#000\n    style L fill:#49C1AD66, stroke:#000, stroke-width:2px, color:#000\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHomogeneous\nHeterogeneous\n\n\n\n\n1d\nAtomic vector\nList\n\n\n2d\nMatrix\nData frame\n\n\nnd\nArray\n\n\n\n\n\n\n\n\n3.1.1 1 dimension objects\nThere are two basic types of vectors: atomic vectors and lists.\nThey have three common properties:\n\nType, typeof() (class/mode).\nLength, length() (number of elements)\nAttributes, attributes() (metadata)\n\nThey differ in the types of their elements: all elements of an atomic vector must be of the same type, while the elements of a list can have different types.\n\n3.1.1.1 Atomic vectors\nTypes of atomic vectors:\n\nLogical (Boolean)\nInteger\nNumeric (double)\nCharacters\nFactors\n\nVectors are constructed with the c() function, they can be numeric:\n\n\nCode\nx &lt;- 1\nx1 &lt;- c(1)\n\nall.equal(x, x1)\n\n\n[1] TRUE\n\n\nCode\nclass(x)\n\n\n[1] \"numeric\"\n\n\nCharacters:\n\n\nCode\ny &lt;- \"something\"\n\nclass(y)\n\n\n[1] \"character\"\n\n\nLogical:\n\n\nCode\nz &lt;- TRUE\n\nclass(z)\n\n\n[1] \"logical\"\n\n\nOr factor:\n\n\nCode\nq &lt;- factor(1)\n\nclass(q)\n\n\n[1] \"factor\"\n\n\nTherefore, the individual numbers or strings are actually vectors of length one:\n\n\nCode\nclass(1)\n\n\n[1] \"numeric\"\n\n\nCode\nclass(\"a\")\n\n\n[1] \"character\"\n\n\nVectors can only contain elements of the same type. Different types of elements will be forced to the most flexible type:\n\n\nCode\nx &lt;- c(1, 2, \"a\")\n\nx\n\n\n[1] \"1\" \"2\" \"a\"\n\n\nCode\nclass(x)\n\n\n[1] \"character\"\n\n\nMissing values are specified with NA, which is a logical vector of length 1. NA will always be interpreted to the correct type if used inside c():\n\n\nCode\nv &lt;- c(10, 11, NA)\n\nclass(v)\n\n\n[1] \"numeric\"\n\n\nCode\nv &lt;- c(\"a\", \"b\", NA)\n\nclass(v)\n\n\n[1] \"character\"\n\n\n\n\n\n3.1.1.2 Factors\nVectors with factors are very similar to character vectors. However, a factor can only contain predefined values, known as levels. Attributes are used to define the levels of the factor.\nFactors are built on integer vectors using two attributes:\n\n“factor” class: makes them behave differently from normal character vectors.\nlevels: defines the set of allowed values\n\n\n\nCode\nx &lt;- factor(c(\"a\", \"b\", \"b\", \"a\"))\nx\n\n\n[1] a b b a\nLevels: a b\n\n\nCode\nlevels(x)\n\n\n[1] \"a\" \"b\"\n\n\nCode\nstr(x)\n\n\n Factor w/ 2 levels \"a\",\"b\": 1 2 2 1\n\n\nThe factors look like character vectors, but are actually integers:\n\n\nCode\nx &lt;- factor(c(\"a\", \"b\", \"b\", \"a\"))\n\nc(x)\n\n\n[1] a b b a\nLevels: a b\n\n\n\n\n3.1.1.3 Lists\nCan contain objects of different classes and sizes. Lists are constructed with list():\n\n\nCode\nl &lt;- list(\"a\", 1, FALSE)\n\nl\n\n\n[[1]]\n[1] \"a\"\n\n[[2]]\n[1] 1\n\n[[3]]\n[1] FALSE\n\n\nCode\nclass(l)\n\n\n[1] \"list\"\n\n\nCode\nstr(l)\n\n\nList of 3\n $ : chr \"a\"\n $ : num 1\n $ : logi FALSE\n\n\nIn fact, they can be seen as drawers where you can put any other type of object:\n\n\nCode\nl &lt;- list(c(\"a\", \"b\"), \n          c(1, 2, 3, 4), \n          c(FALSE, TRUE, FALSE))\n\nl\n\n\n[[1]]\n[1] \"a\" \"b\"\n\n[[2]]\n[1] 1 2 3 4\n\n[[3]]\n[1] FALSE  TRUE FALSE\n\n\nCode\nstr(l)\n\n\nList of 3\n $ : chr [1:2] \"a\" \"b\"\n $ : num [1:4] 1 2 3 4\n $ : logi [1:3] FALSE TRUE FALSE\n\n\n\n\n\n3.1.2 2-dimensional objects\n\n3.1.2.1 Matrices\nAll elements are of the same type:\n\n\nCode\nm &lt;- matrix(c(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"), nrow = 2)\n\ndim(m)\n\n\n[1] 2 3\n\n\nCode\nm\n\n\n     [,1] [,2] [,3]\n[1,] \"a\"  \"c\"  \"e\" \n[2,] \"b\"  \"d\"  \"f\" \n\n\nCode\nclass(m)\n\n\n[1] \"matrix\" \"array\" \n\n\nCode\nm &lt;- matrix(c(\"a\", \"b\", \"c\", \"d\", \"e\", 1), nrow = 2)\nm\n\n\n     [,1] [,2] [,3]\n[1,] \"a\"  \"c\"  \"e\" \n[2,] \"b\"  \"d\"  \"1\" \n\n\n\n\n3.1.2.2 Data Frames\nSpecial case of lists. It can contain elements of different types:\n\n\nCode\nm &lt;-\n  data.frame(\n    ID = c(\"a\", \"b\", \"c\", \"d\", \"e\"),\n    size = c(1, 2, 3, 4, 5),\n    observed = c(FALSE, TRUE, FALSE, FALSE, FALSE)\n  )\n\ndim(m)\n\n\n[1] 5 3\n\n\nCode\nm\n\n\n\n\n\n\nID\nsize\nobserved\n\n\n\n\na\n1\nFALSE\n\n\nb\n2\nTRUE\n\n\nc\n3\nFALSE\n\n\nd\n4\nFALSE\n\n\ne\n5\nFALSE\n\n\n\n\n\n\nCode\nclass(m)\n\n\n[1] \"data.frame\"\n\n\nCode\nis.data.frame(m)\n\n\n[1] TRUE\n\n\nCode\nis.list(m)\n\n\n[1] TRUE\n\n\nCode\nstr(m)\n\n\n'data.frame':   5 obs. of  3 variables:\n $ ID      : chr  \"a\" \"b\" \"c\" \"d\" ...\n $ size    : num  1 2 3 4 5\n $ observed: logi  FALSE TRUE FALSE FALSE FALSE\n\n\nBut the vectors must have the same length:\n\n\nCode\nm &lt;-\n  data.frame(\n    ID = c(\"a\", \"b\", \"c\", \"d\", \"e\"),\n    size = c(1, 2, 3, 4, 5, 6),\n    observed = c(FALSE, TRUE, FALSE, FALSE, FALSE)\n  )\n\n\nError in data.frame(ID = c(\"a\", \"b\", \"c\", \"d\", \"e\"), size = c(1, 2, 3, : arguments imply differing number of rows: 5, 6"
  },
  {
    "objectID": "r_basics.html#exercise-1",
    "href": "r_basics.html#exercise-1",
    "title": "Basic elements of the R language",
    "section": "3.2 Exercise 1",
    "text": "3.2 Exercise 1\n\nCreate a numeric vector with 8 elements containing positive and negative numbers.\nCreate a character vector with the names of the provinces of Costa Rica.\nAdd to the above point vector an NA\nCreate a numeric matrix with 3 columns and 3 rows\nCreate a character matrix with 4 columns and 3 rows\nWhat class of object is ‘iris’ and what are its dimensions (hint: iris is an object available by default in your environment)?\nCreate a data frame with a numeric column, a character column and a factor column."
  },
  {
    "objectID": "r_basics.html#functions-objects-that-perform-tasks",
    "href": "r_basics.html#functions-objects-that-perform-tasks",
    "title": "Basic elements of the R language",
    "section": "3.3 Functions: objects that perform tasks",
    "text": "3.3 Functions: objects that perform tasks\nAll functions are created with the function() function and follow the same structure:\n\n* Modified from Grolemund 2014  \n\n3.3.1 Integrated functions\n\n3.3.1.1 Basic functions\nR comes with many functions that you can use to do sophisticated tasks:\n\n\nCode\n# built in functions\nbi &lt;- builtins(internal = FALSE)\n\nlength(bi)\n\n\n[1] 1388\n\n\nSome functions come by default with R basic. New functions can be loaded as part of additional packages or even created by the user.\n\n\n\n\n\nflowchart LR\n    classDef largeText font-size:18px, padding:15px;\n\n    F(Functions) --&gt; BF(Integraded functions)\n    BF --&gt; OP(Operators)\n    BF --&gt; BA(Basic functions)\n    F --&gt; PF(Packages)\n    F --&gt; UF(User defined functions)\n\n    class R,D,D1,D2,F largeText;\n\n    style F fill:#357BA266, stroke:#000, stroke-width:2px, color:#FFF, width:120px\n    style BF fill:#A0DFB966, stroke:#000, stroke-width:2px, color:#000\n    style BA fill:#DEF5E566, stroke:#000, stroke-width:2px, color:#000\n    style OP fill:#DEF5E566, stroke:#000, stroke-width:2px, color:#000    \n    style PF fill:#A0DFB966, stroke:#000, stroke-width:2px, color:#000000\n    style UF fill:#A0DFB966, stroke:#000, stroke-width:2px, color:#000\n\n\n\n\n\n\n\n\n\n3.3.1.2 Operators\nOperators are functions:\n\n\nCode\n1 + 1\n\n\n[1] 2\n\n\nCode\n'+'(1, 1)\n\n\n[1] 2\n\n\nCode\n2 * 3\n\n\n[1] 6\n\n\nCode\n'*'(2, 3)\n\n\n[1] 6\n\n\n\n3.3.1.2.1 Most used operators\nArithmetic operators:\n\n\n\n\n\n\nOperator\nDescription\n\n\n\n\n+\nsum\n\n\n-\nsubtraction\n\n\n*\nmultiplication\n\n\n/\ndivision\n\n\n^ or **\nexponential\n\n\n\n\n\n\n\n\n\n\nCode\n1 - 2\n\n\n[1] -1\n\n\nCode\n1 + 2\n\n\n[1] 3\n\n\nCode\n2 ^ 2\n\n\n[1] 4\n\n\nCode\n2 ** 2\n\n\n[1] 4\n\n\nCode\n2:3 %in% 2:4\n\n\n[1] TRUE TRUE\n\n\nLogical operators:\n\n\n\nOperator\nDescription\n\n\n\n\n&lt;\nlower than\n\n\n&lt;=\nlower than or equal to\n\n\n&gt;\nhigher than\n\n\n&gt;=\nhigher than or equal to\n\n\n==\nexactly the same\n\n\n!=\ndifferent than\n\n\n!x\nIs not x\n\n\nx | y\nx O y\n\n\nx & y\nx Y y\n\n\nx %in% y\ncorrespondence\n\n\n\n\n\nCode\n1 &lt; 2 \n\n\n[1] TRUE\n\n\nCode\n1 &gt; 2 \n\n\n[1] FALSE\n\n\nCode\n1 &lt;= 2 \n\n\n[1] TRUE\n\n\nCode\n1 == 2\n\n\n[1] FALSE\n\n\nCode\n1 != 2\n\n\n[1] TRUE\n\n\nCode\n1 &gt; 2 \n\n\n[1] FALSE\n\n\nCode\n5 %in% 1:6\n\n\n[1] TRUE\n\n\nCode\n5 %in% 1:4\n\n\n[1] FALSE\n\n\n \n\n\n\n\n3.3.2 Vectorization\nMost functions are vectorized:\n\n\nCode\n1:6 * 1:6\n\n\n\n* Modified from Grolemund & Wickham 2017\n \n\n\n[1]  1  4  9 16 25 36\n\n\n\n\nCode\n1:6 - 1:6\n\n\n[1] 0 0 0 0 0 0\n\n\nR recycles vectors of unequal length:\n\n\nCode\n1:6 * 1:5\n\n\n\n* Modified from Grolemund & Wickham 2017\n\n \n\n3.3.3 Additional package functions\nThese are functions that are included in additional packages that can be installed and loaded into R. To be used the package must be installed and loaded, e.g. to use the corTest function of the “psych” package we must first install. The packages are installed from the CRAN (Comprehensive R Archive Network) server with the install.packages() function:\n\n\nCode\ninstall.packages(\"psych\")\n\n\n… and load the package:\n\n\nCode\nlibrary(psych)\n\n\nOnce ‘psych’ is installed and loaded, we can call the corTest function:\n\n\nCode\ncorTest(iris$Sepal.Length, iris$Sepal.Width)\n\n\nCall:corTest(x = iris$Sepal.Length, y = iris$Sepal.Width)\nCorrelation matrix \n[1] -0.12\nSample Size \n[1] 150\nThese are the unadjusted probability values.\n  The probability values  adjusted for multiple tests are in the p.adj object. \n[1] 0.15\n\n To see confidence intervals of the correlations, print with the short=FALSE option\n\n\nThe use of external packages is the most useful feature of R since it allows to make use of an almost infinite number of specialized functions in different tasks as well as in very diverse fields of science and industry.\nWe can explore the packages available for R at the CRAN website (click on the “packages” link)."
  },
  {
    "objectID": "r_basics.html#exercise-2",
    "href": "r_basics.html#exercise-2",
    "title": "Basic elements of the R language",
    "section": "3.4 Exercise 2",
    "text": "3.4 Exercise 2\n\nSearch for a package you are interested in on CRAN\nInstall the package and load it\nRun the example code of one of its functions"
  },
  {
    "objectID": "r_basics.html#object-manipulation",
    "href": "r_basics.html#object-manipulation",
    "title": "Basic elements of the R language",
    "section": "3.5 Object manipulation",
    "text": "3.5 Object manipulation"
  },
  {
    "objectID": "r_basics.html#extracting-subsets-using-indexing",
    "href": "r_basics.html#extracting-subsets-using-indexing",
    "title": "Basic elements of the R language",
    "section": "3.6 Extracting subsets using indexing",
    "text": "3.6 Extracting subsets using indexing\nElements within objects can be called by indexing. To subset a vector simply call the position of the object using square brackets:\n\n\nCode\nx &lt;- c(\"a\", \"b\", \"c\", \"d\", \"e\", \"a\")\n\nx[1]\n\n\n[1] \"a\"\n\n\nCode\nx[2]\n\n\n[1] \"b\"\n\n\nCode\nx[2:3]\n\n\n[1] \"b\" \"c\"\n\n\nCode\nx[c(1,3)]\n\n\n[1] \"a\" \"c\"\n\n\n \nThe elements can be removed in the same way:\n\n\nCode\nx[-1]\n\n\n[1] \"b\" \"c\" \"d\" \"e\" \"a\"\n\n\nCode\nx[-c(1,3)]\n\n\n[1] \"b\" \"d\" \"e\" \"a\"\n\n\n \nThe position of the indices can also be given by a conditional evaluation. For instance, this code selects the elements in x in which the value is “a”:\n\n\nCode\nx[x == \"a\"]\n\n\n[1] \"a\" \"a\"\n\n\nNotice that there are two steps in this process. First we create a logical vector in which TRUE means that the condition is met and FALSE that is not:\n\n\nCode\nis_a &lt;- x == \"a\"\n\nis_a\n\n\n[1]  TRUE FALSE FALSE FALSE FALSE  TRUE\n\n\n.. and then we use it to subset the data frame:\n\n\nCode\nx[is_a]\n\n\n[1] \"a\" \"a\"\n\n\nConditional evaluations can also be used for numeric vectors (e.g. ‘&gt;’, ‘==’) and to subset bidimensional objects based on columns or rows.\nMatrices and data frames require 2 indices [row, column]:\n\n\nCode\nm &lt;- matrix(c(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"), nrow = 2)\n\nm[1, ]\n\n\n[1] \"a\" \"c\" \"e\"\n\n\nCode\nm[, 1]\n\n\n[1] \"a\" \"b\"\n\n\nCode\nm[1, 1]\n\n\n[1] \"a\"\n\n\nCode\nm[-1, ]\n\n\n[1] \"b\" \"d\" \"f\"\n\n\nCode\nm[, -1]\n\n\n     [,1] [,2]\n[1,] \"c\"  \"e\" \n[2,] \"d\"  \"f\" \n\n\nCode\nm[-1, -1]\n\n\n[1] \"d\" \"f\"\n\n\nCode\ndf &lt;- data.frame(\n  provincia = c(\"San José\", \"Guanacaste\", \"Guanacaste\"), \n  canton = c(\"Montes de Oca\", \"Nicoya\", \"Liberia\"), \n    distrito = c(\"San Rafael\", \"Nosara\", \"Nacascolo\")\n  )\n\ndf\n\n\n\n\n\n\nprovincia\ncanton\ndistrito\n\n\n\n\nSan José\nMontes de Oca\nSan Rafael\n\n\nGuanacaste\nNicoya\nNosara\n\n\nGuanacaste\nLiberia\nNacascolo\n\n\n\n\n\n\nCode\ndf[1, ]\n\n\n\n\n\n\nprovincia\ncanton\ndistrito\n\n\n\n\nSan José\nMontes de Oca\nSan Rafael\n\n\n\n\n\n\nCode\ndf[, 1]\n\n\n[1] \"San José\"   \"Guanacaste\" \"Guanacaste\"\n\n\nCode\ndf[1, 1]\n\n\n[1] \"San José\"\n\n\nCode\ndf[-1, ]\n\n\n\n\n\n\n\nprovincia\ncanton\ndistrito\n\n\n\n\n2\nGuanacaste\nNicoya\nNosara\n\n\n3\nGuanacaste\nLiberia\nNacascolo\n\n\n\n\n\n\nCode\ndf[, -1]\n\n\n\n\n\n\ncanton\ndistrito\n\n\n\n\nMontes de Oca\nSan Rafael\n\n\nNicoya\nNosara\n\n\nLiberia\nNacascolo\n\n\n\n\n\n\nCode\ndf[-1, -1]\n\n\n\n\n\n\n\ncanton\ndistrito\n\n\n\n\n2\nNicoya\nNosara\n\n\n3\nLiberia\nNacascolo\n\n\n\n\n\n\nData frames can also be subsetted using the name of the columns:\n\n\nCode\ndf[,\"provincia\"]\n\n\n[1] \"San José\"   \"Guanacaste\" \"Guanacaste\"\n\n\nCode\ndf[,c(\"provincia\", \"canton\")]\n\n\n\n\n\n\nprovincia\ncanton\n\n\n\n\nSan José\nMontes de Oca\n\n\nGuanacaste\nNicoya\n\n\nGuanacaste\nLiberia\n\n\n\n\n\n\nCode\ndf$provincia\n\n\n[1] \"San José\"   \"Guanacaste\" \"Guanacaste\"\n\n\n \nLists require 1 index between double square brackets [[index]]:\n\n\nCode\nl &lt;- list(c(\"a\", \"b\"),\n          c(1, 2, 3),\n          c(FALSE, TRUE, FALSE, FALSE))\n\nl[[1]]\n\n\n[1] \"a\" \"b\"\n\n\nCode\nl[[3]]\n\n\n[1] FALSE  TRUE FALSE FALSE\n\n\n \nElements within lists can also be subsets in the same code string:\n\n\nCode\nl[[1]][1:2]\n\n\n[1] \"a\" \"b\"\n\n\nCode\nl[[3]][2]\n\n\n[1] TRUE"
  },
  {
    "objectID": "r_basics.html#explore-objects",
    "href": "r_basics.html#explore-objects",
    "title": "Basic elements of the R language",
    "section": "3.7 Explore objects",
    "text": "3.7 Explore objects\nThe following basic R functions (default) can help us to explore the structure of objects:\n\n\nCode\nstr(df)\n\n\n'data.frame':   3 obs. of  3 variables:\n $ provincia: chr  \"San José\" \"Guanacaste\" \"Guanacaste\"\n $ canton   : chr  \"Montes de Oca\" \"Nicoya\" \"Liberia\"\n $ distrito : chr  \"San Rafael\" \"Nosara\" \"Nacascolo\"\n\n\nCode\nnames(df)\n\n\n[1] \"provincia\" \"canton\"    \"distrito\" \n\n\nCode\ndim(df)\n\n\n[1] 3 3\n\n\nCode\nnrow(df)\n\n\n[1] 3\n\n\nCode\nncol(df)\n\n\n[1] 3\n\n\nCode\nhead(df)\n\n\n\n\n\n\nprovincia\ncanton\ndistrito\n\n\n\n\nSan José\nMontes de Oca\nSan Rafael\n\n\nGuanacaste\nNicoya\nNosara\n\n\nGuanacaste\nLiberia\nNacascolo\n\n\n\n\n\n\nCode\ntail(df)\n\n\n\n\n\n\nprovincia\ncanton\ndistrito\n\n\n\n\nSan José\nMontes de Oca\nSan Rafael\n\n\nGuanacaste\nNicoya\nNosara\n\n\nGuanacaste\nLiberia\nNacascolo\n\n\n\n\n\n\nCode\ntable(df$provincia)\n\n\n\nGuanacaste   San José \n         2          1 \n\n\nCode\nclass(df)\n\n\n[1] \"data.frame\"\n\n\n\n\nCode\nView(df)"
  },
  {
    "objectID": "r_basics.html#exercise-3",
    "href": "r_basics.html#exercise-3",
    "title": "Basic elements of the R language",
    "section": "3.8 Exercise 3",
    "text": "3.8 Exercise 3\n\nUse the example data iris to create a subset of data with only the observations of the species setosa.\nNow create a subset of data containing the observations of both setosa and versicolor.\nAlso with iris create a subset of data with the observations for which iris$Sepal.length is greater than 6\nHow many observations have a sepal length greater than 6?"
  },
  {
    "objectID": "r_basics.html#file-names",
    "href": "r_basics.html#file-names",
    "title": "Basic elements of the R language",
    "section": "4.1 File names",
    "text": "4.1 File names\nFile names must end in .R and, of course, be self-explanatory:\n\nGood: graph_posterior_probability.R\nBad: graf.R"
  },
  {
    "objectID": "r_basics.html#object-names",
    "href": "r_basics.html#object-names",
    "title": "Basic elements of the R language",
    "section": "4.2 Object names",
    "text": "4.2 Object names\nVariables and functions:\n\nLowercase\nUse an underscore\nIn general, names for variables and verbs for functions.\nKeep names concise and meaningful (not always easy).\nAvoid using names of existing functions of variables\n\n\n\nCode\n- GOOD: day_one: day_1, mean_weight(),\n  \n- BAD: dayone, day1, first_day.of.month"
  },
  {
    "objectID": "r_basics.html#syntax",
    "href": "r_basics.html#syntax",
    "title": "Basic elements of the R language",
    "section": "4.3 Syntax",
    "text": "4.3 Syntax\n\n4.3.1 Spaces\n\nUse spaces around operators and for arguments within a function.\nAlways put a space after a comma, and never before (as in normal English).\nPlace a space before the left parenthesis, except in a function call.\n\n\n\nCode\n  - GOOD: \n          a &lt;- rnorm(n = 10, sd = 10, mean = 1)\n          total &lt;- sum(x[1, ])\n\n  - BAD: \n         a&lt;-rnorm(n=10,sd=10,mean=1) \n         total &lt;- sum(x[,1])  \n\n\n \n\n4.3.1.1 Brackets\n\nThe opening key should never go on its own line.\nThe closing brace must always be on its own line.\nYou can omit braces when a block consists of only one statement\n\n\n\nCode\n  - GOOD:\n              if (is.null(ylim)) {\n              ylim &lt;- c(0, 0.06)\n            }\n                      \n            if (is.null(ylim))\n              ylim &lt;- c(0, 0.06)\n          \n  - BAD:\n            \n         if (is.null(ylim)) ylim &lt;- c(0, 0.06)\n                    \n         if (is.null(ylim)) {ylim &lt;- c(0, 0.06)} \n\n         if (is.null(ylim)) {\n           ylim &lt;- c(0, 0.06)\n           } \n\n\n \n\n\n4.3.1.2 Create objects\n\nUse &lt;-, instead of =\n\n\n\nCode\n  - GOOD:\n         x &lt;- 5 \n          \n  - BAD:\n         x = 5\n\n\n \n\n\n4.3.1.3 Suggestions to add comments\n\nComment your code\nEntire commented lines should begin with # and a space.\nShort comments can be placed after the code preceded by two spaces, #, and then a space.\n\n\n\nCode\n# Create histogram of frequency of campaigns by pct budget spent.\nhist(df$pct.spent,\n     breaks = \"scott\",  # method for choosing number of buckets\n     main   = \"Histogram: individuals per unit of time\",\n     xlab   = \"Individual count\",\n     ylab   = \"Frequency\")"
  },
  {
    "objectID": "r_basics.html#package-documentation",
    "href": "r_basics.html#package-documentation",
    "title": "Basic elements of the R language",
    "section": "5.1 Package documentation",
    "text": "5.1 Package documentation"
  },
  {
    "objectID": "r_basics.html#reference-manuals",
    "href": "r_basics.html#reference-manuals",
    "title": "Basic elements of the R language",
    "section": "5.2 Reference manuals",
    "text": "5.2 Reference manuals\nReference manuals are collections of documentation for all the functions of a package (only 1 per package):\n\ndynaSpec manual\nbaRulho manual"
  },
  {
    "objectID": "r_basics.html#documentation-of-functions",
    "href": "r_basics.html#documentation-of-functions",
    "title": "Basic elements of the R language",
    "section": "5.3 Documentation of functions",
    "text": "5.3 Documentation of functions\nAll functions (default or loaded packages) must have documentation that follows a standard format:\n\n\nCode\n?mean\n\nhelp(\"mean\")\n\n\n\nThis documentation can also be displayed in Rstudio by pressing F1 when the cursor is on the function name.\nIf you do not remember the function name try apropos():\n\n\nCode\napropos(\"mean\")\n\n\n [1] \".colMeans\"      \".rowMeans\"      \"circadian.mean\" \"circular.mean\" \n [5] \"colMeans\"       \"geometric.mean\" \"harmonic.mean\"  \"kmeans\"        \n [9] \"mean\"           \"mean.Date\"      \"mean.default\"   \"mean.difftime\" \n[13] \"mean.POSIXct\"   \"mean.POSIXlt\"   \"rowMeans\"       \"weighted.mean\" \n[17] \"winsor.mean\"    \"winsor.means\""
  },
  {
    "objectID": "r_basics.html#vignettes-vignettes",
    "href": "r_basics.html#vignettes-vignettes",
    "title": "Basic elements of the R language",
    "section": "5.4 Vignettes (vignettes)",
    "text": "5.4 Vignettes (vignettes)\nVignettes are illustrative documents or case studies detailing the use of a package (optional, can be several per package).\nVignettes can be called directly from R:\n\n\nCode\nvgn &lt;- browseVignettes() \n\n\n\n\nCode\nvignette()\n\n\nTambién deberían aparecer en la página del paquete en CRAN."
  },
  {
    "objectID": "r_basics.html#exercise-4",
    "href": "r_basics.html#exercise-4",
    "title": "Basic elements of the R language",
    "section": "5.5 Exercise 4",
    "text": "5.5 Exercise 4\n\nWhat does the cut() function do?\nWhat is the breaks argument used for in cut()?\nRun the first 4 lines of code from the examples provided in the cut() documentation.\nHow many bullets does the warbleR package have?"
  },
  {
    "objectID": "r_basics.html#session-info",
    "href": "r_basics.html#session-info",
    "title": "Basic elements of the R language",
    "section": "Session info",
    "text": "Session info\n\n\nR version 4.3.2 (2023-10-31)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 22.04.2 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.10.0 \nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.10.0\n\nlocale:\n [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              \n [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    \n [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   \n [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 \n [9] LC_ADDRESS=C               LC_TELEPHONE=C            \n[11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       \n\ntime zone: America/Costa_Rica\ntzcode source: system (glibc)\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] psych_2.3.12\n\nloaded via a namespace (and not attached):\n [1] vctrs_0.6.5       nlme_3.1-155      svglite_2.1.3     cli_3.6.3        \n [5] knitr_1.48        rlang_1.1.4       xfun_0.47         stringi_1.8.4    \n [9] highr_0.11        jsonlite_1.8.9    glue_1.8.0        colorspace_2.1-1 \n[13] htmltools_0.5.8.1 scales_1.3.0      rmarkdown_2.28    grid_4.3.2       \n[17] evaluate_1.0.0    munsell_0.5.1     kableExtra_1.4.0  fastmap_1.2.0    \n[21] yaml_2.3.10       lifecycle_1.0.4   stringr_1.5.1     compiler_4.3.2   \n[25] htmlwidgets_1.6.4 rstudioapi_0.16.0 lattice_0.20-45   systemfonts_1.1.0\n[29] digest_0.6.37     viridisLite_0.4.2 R6_2.5.1          parallel_4.3.2   \n[33] mnormt_2.1.1      magrittr_2.0.3    tools_4.3.2       xml2_1.3.6"
  },
  {
    "objectID": "program.html#day-1-video",
    "href": "program.html#day-1-video",
    "title": "Bioacoustic data analysis with R 2024",
    "section": "1 Day 1 (video)",
    "text": "1 Day 1 (video)\n\n\n1.1 Aditional resources\n\n1.1.1 Readings\n\nAlston, J. M., & Rick, J. A. (2021). A beginner’s guide to conducting reproducible research. Bulletin of the Ecological Society of America, 102(2), 1-14.\nCulina, A., van den Berg, I., Evans, S., & Sánchez-Tójar, A. (2020). Low availability of code in ecology: A call for urgent action. PLoS Biology, 18(7), e3000763.\nKöhler, J., Jansen, M., Rodríguez, A., Kok, P. J. R., Toledo, L. F., Emmrich, M., … & Vences, M. (2017). The use of bioacoustics in anuran taxonomy: theory, terminology, methods and recommendations for best practice. Zootaxa, 4251(1), 1-124. (at least the first 28 pages)\n\n\n\n1.1.2 Videos\n\nIntroduction to digital audio\nDigital audio artifacts: (Video 1, Video 2)\n\n\n\n \nIntroduction Introduction\n\nHow animal acoustic signals look like?\nAnalytical workflow in bioacoustics research\nAdvantages of programming\nCourse outline\n\n \nWhat is sound? Sound\n\n\nCreate a Rstudio project for the course\nDownload this folder into the course project directory\n\n\n\nSound as a time series\nSound as a digital object\nAcoustic data in R\n‘wave’ object structure\n‘wave’ object manipulations\nadditional formats\n\n \n\n1.2 Homework\n\nUse the function query_xenocanto() from the suwo package to check the availability of recordings for any bird species (do not download at this step) (check this brief tutorial on how to do that)\nSubset the data frame returned by the function to get a subset of subspecies/populations or recordings from a specific country and for certain vocalization type (using base R subsetting tools)\nDownload the associated recordings using query_xenocanto() again\nExplore the recordings with any spectrogram creating GUI program"
  },
  {
    "objectID": "program.html#day-2-video",
    "href": "program.html#day-2-video",
    "title": "Bioacoustic data analysis with R 2024",
    "section": "2 Day 2 (video)",
    "text": "2 Day 2 (video)\n\n\n2.1 Additional resources\n\n2.1.1 Raven tutorials\n\nIntroduction to the Raven Pro Interface\nIntroduction to selections and measurements\nSaving, retrieving, and exporting selection tables\nUsing annotations\n\n\n\nBuilding spectrograms Building spectrograms\n\nFourier transform\nBuilding a spectrogram\nCharacteristics and limitations\nSpectrograms in R\n\nPackage seewave seewave\n\nExplore, modify and measure ‘wave’ objects\nSpectrograms and oscillograms\nFiltering and re-sampling\nAcoustic measurements\n\n \n\n2.2 Homework\n\nUse Raven Pro to annotate some of the signals found in the xeno-canto recordings you downloaded previously"
  },
  {
    "objectID": "program.html#day-3-video",
    "href": "program.html#day-3-video",
    "title": "Bioacoustic data analysis with R 2024",
    "section": "3 Day 3 (video)",
    "text": "3 Day 3 (video)\n\n\n3.1 Additional resources\n\n3.1.1 Readings\n\nArasco, A. G., Manser, M., Watson, S. K., Kyabulima, S., Radford, A. N., Cant, M. A., & Garcia, M. (2024). Testing the acoustic adaptation hypothesis with vocalizations from three mongoose species. Animal Behaviour, 187, 71-95.\n\n\n\n \nAnnotation software annotations\n\nRaven / audacity\nOpen and explore recordings\nModify-optimize visualization parameters\nAnnotate signals\n\nQuantifying acoustic signal structure Quantify structure\n\nSpectro-temporal measurements (spectro_analysis())\nParameter description\nHarmonic content\nCepstral coefficients (mfcc_stats())\nCross-correlation (cross_correlation())\nDynamic time warping (freq_DTW())\nSignal-to-noise ratio (sig2noise())\nInflections (inflections())\nParameters at other levels (song_analysis())\n\n \n\n3.2 Homework\n\nDouble-check annotations using warbleR’s dedicated functions\n\n\nCreate single spectrograms of each annotation\nCreate full spectrograms of all sound files along with annotations\nCreate catalogs\n\n \n\nDouble-check annotations using Raven (export data from R to Raven)"
  },
  {
    "objectID": "program.html#day-4-video",
    "href": "program.html#day-4-video",
    "title": "Bioacoustic data analysis with R 2024",
    "section": "4 Day 4 (video)",
    "text": "4 Day 4 (video)\n\n\n4.1 Additional resources\n\n4.1.1 Readings\n\nOdom, K. J., Cain, K. E., Hall, M. L., Langmore, N. E., Mulder, R. A., Kleindorfer, S., … & Webster, M. S. (2021). Sex role similarity and sexual selection predict male and female song elaboration and dimorphism in fairy‐wrens. Ecology and evolution, 11(24), 17901-17919.\n\n\n\n \nQuality control in recordings and annotations Quality checks\n\nCheck and modify sound file format (check_wavs(), info_wavs(), duration_wavs(), mp32wav() y fix_wavs())\nTuning spectrogram parameters (tweak_spectro())\nDouble-checking selection tables (check_sels(), spectrograms(), full_spectrograms() & catalog())\nRe-adjusting selections (tailor_sels())\n\nCharacterizing hierarchical levels in acoustic signals\n\nCreating ‘song’ spectrograms (full_spectrograms(), spectrograms())\n‘Song’ parameters (song_analysis())\n\n \n\n4.2 Homework\n\nSelect best quality signals for analysis\nMeasure acoustic parameters\nSummarize variation at higher hierachical levels (if necessary)"
  },
  {
    "objectID": "program.html#day-5-video",
    "href": "program.html#day-5-video",
    "title": "Bioacoustic data analysis with R 2024",
    "section": "5 Day 5 (video)",
    "text": "5 Day 5 (video)\n\n\n5.1 Additional resources\n\n5.1.1 Readings\n\nBlog post: Potential issues of the ‘spectral parameters/PCA’ approach\nBlog post: Choosing the right method for measuring acoustic signal structure\n\n\n\n \nChoosing the right method for quantifying structure Comparing methods\n\nCompare different methods for quantifying structure (compare_methods())\n\nQuantifying acoustic spaces Acoustic space\n\nIntro to PhenotypeSpace\nQuanitfying space size\nComparing sub-spaces"
  },
  {
    "objectID": "sound.html",
    "href": "sound.html",
    "title": "Sound",
    "section": "",
    "text": "Sound waves are characterized by compression and expansion of the medium as sound energy moves through it. There is also back and forth motion of the particles making up the medium:\ntaken from https://dosits.org\nThe variation in pressure that is perceived at a fixed point in space can be represented by a graph of pressure (amplitude) by time:\nSounds waves are typically quantified by their frequency (number of cycles per second, Hz) and amplitude (relative intensity)."
  },
  {
    "objectID": "sound.html#objetives",
    "href": "sound.html#objetives",
    "title": "Sound",
    "section": "Objetives",
    "text": "Objetives\n\nLearn the basic aspects of sound as a physical phenomenom\nGet familiar with how sound is represented as a digital object in R"
  },
  {
    "objectID": "sound.html#sampling-frequency",
    "href": "sound.html#sampling-frequency",
    "title": "Sound",
    "section": "0.1 Sampling frequency",
    "text": "0.1 Sampling frequency\nDigitizing implies discretizing, which requires some sort of regular sampling. Sampling frequency refers to how many samples of the pressure level of the environment are taken per second. A 440 Hz sine wave recorded at 44100 Hz would have around 100 samples per cycle. This plot shows 2 cycles of a 440 Hz sine wave sampled (vertical dotted lines) at 44100 Hz:"
  },
  {
    "objectID": "sound.html#nyquist-frequency",
    "href": "sound.html#nyquist-frequency",
    "title": "Sound",
    "section": "0.2 Nyquist frequency",
    "text": "0.2 Nyquist frequency\nSampling should be good enough so the regularity of the sine wave can be reconstructed from the sampled data. Low sampling frequencies of a high frequency sine wave might not be able to provide enough information. For instance, the same 440 Hz sine wave sampled at 22050 Hz looks like this:\n\n\n\n\n\n\n\n\n\n \nAs you can see way less samples are taken per unit of time. The threshold at which samples cannot provide a reliable estimate of the regularity of a sine wave is called Nyquist frequency and corresponds to half of the frequency of the sine wave. This is how the 2 cycles of the 440 Hz would look like when sampled at its Nyquist frequency (sampling frequency of 880 Hz):"
  },
  {
    "objectID": "sound.html#quantization",
    "href": "sound.html#quantization",
    "title": "Sound",
    "section": "0.3 Quantization",
    "text": "0.3 Quantization\nOnce we know at which point amplitude samples will be taken we just need to measure it. This process is called quantization. The range of amplitude values is discretized in a number of intervals equals to 2 ^ bits. Hence, it involves some rounding of the actual amplitude values and some data loss. This is the same 440 Hz sine wave recorded at 44100 kHz quantized at 2 bits (2^2 = 4 intervals):\n\n\n\n\n\n\n\n\n\n \nRounding and data loss is more obvious if we add lines to the sampled points:\n\n\n\n\n\n\n\n\n\n \nThis is the same signal quantized at 3 bits (2^3 = 8 intervals):\n\n\n\n\n\n\n\n\n\n \n4 bits (2^4 = 16 intervals):\n\n\n\n\n\n\n\n\n\n \n.. and 8 bits (2^8 = 256 intervals):\n\n\n\n\n\n\n\n\n\n \nAt this point quantization involves very little information loss. 16 bits is probably the most common dynamic range used nowadays. As you can imagine, the high number of intervals (2^16 = 65536) allows for great precision in the quantization of amplitude."
  },
  {
    "objectID": "sound.html#non-specific-classes",
    "href": "sound.html#non-specific-classes",
    "title": "Sound",
    "section": "1.1 Non-specific classes",
    "text": "1.1 Non-specific classes\n\n1.1.1 Vectors\nAny numerical vector can be treated as a sound if a sampling frequency is provided. For example, a 440 Hz sinusoidal sound sampled at 8000 Hz for one second can be generated like this:\n\n\nCode\nlibrary(seewave)\n\n# create sinewave at 440 Hz\ns1 &lt;- sin(2 * pi * 440 * seq(0, 1, length.out = 8000))\n\nis.vector(s1)\n\n\n[1] TRUE\n\n\nCode\nmode(s1)\n\n\n[1] \"numeric\"\n\n\n \nThese sequences of values only make sense when specifying the sampling rate at which they were created:\n\n\nCode\noscillo(s1, f = 8000, from = 0, to = 0.01)\n\n\n\n\n\n\n\n\n\n \n\n\n1.1.2 Matrices\nYou can read any single column matrix:\n\n\nCode\ns2 &lt;- as.matrix(s1)\n\nis.matrix(s2)\n\n\n[1] TRUE\n\n\nCode\ndim(s2)\n\n\n[1] 8000    1\n\n\nCode\noscillo(s2, f = 8000, from = 0, to = 0.01)\n\n\n\n\n\n\n\n\n\n \nIf the matrix has more than one column, only the first column will be considered:\n\n\nCode\nx &lt;- rnorm(8000)\n\ns3 &lt;- cbind(s2, x)\n\nis.matrix(s3)\n\n\n[1] TRUE\n\n\nCode\ndim(s3)\n\n\n[1] 8000    2\n\n\nCode\noscillo(s3, f = 8000, from = 0, to = 0.01)\n\n\n\n\n\n\n\n\n\n \n\n\n1.1.3 Time series\nThe class ts and related functions ts(), as.ts(), is.ts() can also be used to generate sound objects in R. Here the command to similarly generate a series of time is shown corresponding to a 440 Hz sinusoidal sound sampled at 8000 Hz for one second:\n\n\nCode\ns4 &lt;- ts(data = s1, start = 0, frequency = 8000)\n\nstr(s4)\n\n\n Time-Series [1:8000] from 0 to 1: 0 0.339 0.637 0.861 0.982 ...\n\n\n \nTo generate a random noise of 0.5 seconds:\n\n\nCode\ns4 &lt;- ts(data = runif(4000, min = -1, max = 1), start = 0, end = 0.5, frequency = 8000)\n\nstr(s4)\n\n\n Time-Series [1:4001] from 0 to 0.5: -0.4714 -0.0189 -0.0405 0.5881 -0.1182 ...\n\n\n \nThe frequency() and deltat() functions return the sampling frequency (\\(f\\)) and the time resolution (\\(Delta t\\)) respectively:\n\n\nCode\nfrequency(s4)\n\n\n[1] 8000\n\n\nCode\ndeltat(s4)\n\n\n[1] 0.000125\n\n\n \nAs the frequency is incorporated into the ts objects, it is not necessary to specify it when used within functions dedicated to audio:\n\n\nCode\noscillo(s4, from = 0, to = 0.01)\n\n\n\n\n\n\n\n\n\n \nIn the case of multiple time series, seewave functions will consider only the first series:\n\n\nCode\ns5 &lt;- ts(data = s3, f = 8000)\n\nclass(s5)\n\n\n[1] \"mts\"    \"ts\"     \"matrix\" \"array\" \n\n\nCode\noscillo(s5, from = 0, to = 0.01)"
  },
  {
    "objectID": "sound.html#dedicated-r-classes-for-sound",
    "href": "sound.html#dedicated-r-classes-for-sound",
    "title": "Sound",
    "section": "1.2 Dedicated R classes for sound",
    "text": "1.2 Dedicated R classes for sound\nThere are 3 kinds of objects corresponding to the wav binary format or themp3 compressed format:\n\nWave class of the package tuneR\nsound class of the package phonTools\nAudioSample class of the package audio\n\n \n\n1.2.1 Wave class (tuneR)\nThe Wave class comes with the tuneR package. This S4 class includes different “slots” with the amplitude data (left or right channel), the sampling frequency (or frequency), the number of bits (8/16/24/32) and the type of sound (mono/stereo). High sampling rates (&gt; 44100 Hz) can be read on these types of objects.\nThe function to import .wav files from the hard drive is readWave:\n\n\nCode\n# load packages\nlibrary(tuneR)\n\ns6 &lt;- readWave(\"./examples/Phae.long1.wav\")\n\n\n \nWe can verify the class of the object like this:\n\n\nCode\n# object class\nclass(s6)\n\n\n[1] \"Wave\"\nattr(,\"package\")\n[1] \"tuneR\"\n\n\n \nS4 objects have a structure similar to lists but use ‘@’ to access each position (slot):\n\n\nCode\n# structure\nstr(s6)\n\n\nFormal class 'Wave' [package \"tuneR\"] with 6 slots\n  ..@ left     : int [1:56251] 162 -869 833 626 103 -2 43 19 47 227 ...\n  ..@ right    : num(0) \n  ..@ stereo   : logi FALSE\n  ..@ samp.rate: int 22500\n  ..@ bit      : int 16\n  ..@ pcm      : logi TRUE\n\n\nCode\n# extract 1 position\ns6@samp.rate\n\n\n[1] 22500\n\n\n \n\n“Pulse-code modulation (PCM) is a method used to digitally represent sampled analog signals. It is the standard form of digital audio. In a PCM stream, the amplitude of the analog signal is sampled regularly at uniform intervals, and each sample is quantized to the nearest value within a range of digital steps” (Wikipedia).\n\n \nThe samples come in the slot ‘@left’:\n\n\nCode\n# samples\ns6@left[1:40]\n\n\n [1]  162 -869  833  626  103   -2   43   19   47  227   -4  205  564  171  457\n[16]  838 -216   60   76 -623 -213  168 -746 -248  175 -512  -58  651  -85 -213\n[31]  586   40 -407  371  -51 -587  -92   94 -527   40\n\n\n \nThe number of samples is given by the duration and the sampling rate.\n \n\nExercise\n\nHow can we calculate the duration of the wave object using the information in the object?\n\n \n\nExtract the first second of audio from the object s6 using indexing (and squared brackets)\n\n\n \nAn advantage of using readWave() is the ability to read specific segments of sound files, especially useful with long files. This is done using the from andto arguments and specifying the units of time with the units arguments. The units can be converted into “samples”, “minutes” or “hours”. For example, to read only the section that begins in 1s and ends in 2s of the file “Phae.long1.wav”:\n\n\nCode\ns7 &lt;- readWave(\"./examples/Phae.long1.wav\", from = 1, to = 2, units = \"seconds\")\n\ns7\n\n\n\nWave Object\n    Number of Samples:      22500\n    Duration (seconds):     1\n    Samplingrate (Hertz):   22500\n    Channels (Mono/Stereo): Mono\n    PCM (integer format):   TRUE\n    Bit (8/16/24/32/64):    16 \n\n\n \nThe .mp3 files can be imported to R although they are imported inWave format. This is done using the readMP3() function:\n\n\nCode\ns7 &lt;- readMP3(\"./examples/Phae.long1.mp3\")\n\ns7\n\n\n\nWave Object\n    Number of Samples:      56448\n    Duration (seconds):     2.56\n    Samplingrate (Hertz):   22050\n    Channels (Mono/Stereo): Mono\n    PCM (integer format):   TRUE\n    Bit (8/16/24/32/64):    16 \n\n\n \nTo obtain information about the object (sampling frequency, number of bits, mono/stereo), it is necessary to use the indexing of S4 class objects:\n\n\nCode\ns7@samp.rate\n\n\n[1] 22050\n\n\nCode\ns7@bit\n\n\n[1] 16\n\n\nCode\ns7@stereo\n\n\n[1] FALSE\n\n\n \nA property that does not appear in these calls is that readWave does not normalize the sound. The values that describe the sound will be included between \\(\\pm2^{bit} - 1\\):\n\n\nCode\nrange(s7@left)\n\n\n[1] -32768  32767\n\n\n \n\nExercise\nThe function Wave can be used to create wave objects.\n \n\nRun the example code in the function documentation\nPlot the oscillogram for the first 0.01 s of ‘Wobj’\nNote that the function sine provides a shortcut that can be used to create wave object with a sine wave. Check out other similar functions described in the sine function documentation. Try 4 of these alternative functions and plot the oscillogram of the first 0.01 s for each of them.\n\n\n \nThe function read_sound_files from warbleR is a wrapper over several sound file reading functions, that can read files in ‘wav’, ‘mp3’, ‘flac’ and ‘wac’ format:\n\n\nCode\nlibrary(warbleR)\n\n# wave\nrsf1 &lt;- read_sound_file(\"Phaethornis-eurynome-15607.wav\", path = \"./examples\")\n\nclass(rsf1)\n\n\n[1] \"Wave\"\nattr(,\"package\")\n[1] \"tuneR\"\n\n\nCode\n# mp3\nrsf2 &lt;- read_sound_file(\"Phaethornis-striigularis-154074.mp3\", path = \"./examples\")\n\nclass(rsf2)\n\n\n[1] \"Wave\"\nattr(,\"package\")\n[1] \"tuneR\"\n\n\nCode\n# flac\nrsf3 &lt;- read_sound_file(\"Phae.long1.flac\", path = \"./examples\")\n\nclass(rsf3)\n\n\n[1] \"Wave\"\nattr(,\"package\")\n[1] \"tuneR\"\n\n\nCode\n# wac\nrsf4 &lt;- read_sound_file(\"recording_20170716_230503.wac\", path = \"./examples\")\n\nclass(rsf4)\n\n\n[1] \"Wave\"\nattr(,\"package\")\n[1] \"tuneR\"\n\n\n \nThe function can also read recordings hosted in an online repository:\n\n\nCode\nrsf5 &lt;- read_sound_file(X = \"https://xeno-canto.org/35340/download\")\n\nclass(rsf5)\n\n\n[1] \"Wave\"\nattr(,\"package\")\n[1] \"tuneR\"\n\n\nCode\nrsf6 &lt;- read_sound_file(X = \"https://github.com/maRce10/OTS_BIR_2024/raw/master/examples/Phae.long1.flac\")\n\nclass(rsf6)\n\n\n[1] \"Wave\"\nattr(,\"package\")\n[1] \"tuneR\""
  },
  {
    "objectID": "sound.html#class-sound-phontools",
    "href": "sound.html#class-sound-phontools",
    "title": "Sound",
    "section": "1.3 Class sound (phonTools)",
    "text": "1.3 Class sound (phonTools)\nThe loadsound() function of phonTools also imports ‘wave’ sound files into R, in this case as objects of class sound:\n\n\nCode\nlibrary(phonTools)\n\ns8 &lt;- loadsound(\"./examples/Phae.long1.wav\")\n\ns8\n\n\n\n      Sound Object\n\n   Read from file:         ./examples/Phae.long1.wav\n   Sampling frequency:     22500  Hz\n   Duration:               2500.044  ms\n   Number of Samples:      56251 \n\n\nCode\nstr(s8)\n\n\nList of 5\n $ filename  : chr \"./examples/Phae.long1.wav\"\n $ fs        : int 22500\n $ numSamples: num 56251\n $ duration  : num 2500\n $ sound     : Time-Series [1:56251] from 0 to 2.5: 0.00494 -0.02652 0.02542 0.0191 0.00314 ...\n - attr(*, \"class\")= chr \"sound\"\n\n\n \nThis function only imports files with a dynamic range of 8 or 16 bits."
  },
  {
    "objectID": "sound.html#class-audiosample-audio",
    "href": "sound.html#class-audiosample-audio",
    "title": "Sound",
    "section": "1.4 Class audioSample (audio)",
    "text": "1.4 Class audioSample (audio)\nThe audio package is another option to handle .wav files. The sound can be imported using the load.wave() function. The class of the resulting object is audioSample which is essentially a numerical vector (for mono) or a numerical matrix with two rows (for stereo). The sampling frequency and resolution are saved as attributes:\n\n\nCode\nlibrary(audio)\n\ns10 &lt;- load.wave(\"./examples/Phae.long1.wav\")\n\nhead(s10)\n\n\nsample rate: 22500Hz, mono, 16-bits\n[1]  4.943848e-03 -2.652058e-02  2.542114e-02  1.910400e-02  3.143311e-03\n[6] -6.103702e-05\n\n\nCode\ns10$rate\n\n\n[1] 22500\n\n\nCode\ns10$bits\n\n\n[1] 16\n\n\n \nThe main advantage of the audio package is that the sound can be acquired directly within an R session. This is achieved first by preparing a NAs vector and then using therecord() function. For example, to obtain a mono sound of 5 seconds sampled at 16 kHz:\n\n\nCode\ns11 &lt;- rep(NA_real_, 16000 * 5)\n\nrecord(s11, 16000, 1)\n\n\n \nA recording session can be controlled by three complementary functions: pause(), rewind(), and resume()."
  },
  {
    "objectID": "sound.html#export-sounds-from-r",
    "href": "sound.html#export-sounds-from-r",
    "title": "Sound",
    "section": "1.5 Export sounds from R",
    "text": "1.5 Export sounds from R\nFor maximum compatibility with other sound programs, it may be useful to save a sound as a simple .txt file. The following commands will write a “tico.txt” file:\n\n\nCode\ndata(tico)\n\nexport(tico, f = 22050)"
  },
  {
    "objectID": "sound.html#format-.wav",
    "href": "sound.html#format-.wav",
    "title": "Sound",
    "section": "1.6 Format ‘.wav’",
    "text": "1.6 Format ‘.wav’\ntuneR and audio have a function to write .wav files: writeWave() and save.wave() respectively. Within seewave, the savewav() function, which is based on writeWave(), can be used to save data in .wav format. By default, the object name will be used for the name of the .wav file:\n\n\nCode\nsavewav(tico)"
  },
  {
    "objectID": "sound.html#format-.flac",
    "href": "sound.html#format-.flac",
    "title": "Sound",
    "section": "1.7 Format ‘.flac’",
    "text": "1.7 Format ‘.flac’\nFree Lossless Audio Codec (FLAC) is a file format for lossless audio data compression. FLAC reduces bandwidth and storage requirements without sacrificing the integrity of the audio source. Audio sources encoded in FLAC are generally reduced in size from 40 to 50 percent. See the flac website for more details (flac.sourceforge.net).\nThe .flac format cannot be used as such with R. However, the wav2flac()function allows you to call the FLAC software directly from the console. Therefore, FLAC must be installed on your operating system. If you have a .wav file that you want to compress in .flac, call:\n\n\nCode\nwav2flac(file = \"./examples/Phae.long1.wav\", overwrite = FALSE)\n\n\n \nTo compress a .wav file to a .flac format, the argument reverse = TRUE must be used:\n\n\nCode\nwav2flac(\"Phae.long1.flac\", reverse = TRUE)\n\n\n \nThis table, taken from Sueur (2018), summarizes the functions available to import and export sound files in R. The table is incomplete since it does not mention the functions of the phonTools package:\n\n\n \n\nExercise\n\nHow does the sampling rate affect the size of an audio file? (hint: create 2 sounds files with the same data but different sampling rates; use sine())\nHow does the dynamic range affect the size of an audio file?\nUse the system.time() function to compare the performance of the different functions to import audio files in R. For this use the file “LBH.374.SUR.wav” (Long-billed hermit songs) which lasts about 2 min\n\nThe following code creates a plot similar to oscillo but using dots instead of lines:\n\n\nCode\n# generate sine wave\nwav &lt;- sine(freq = 440, duration = 500, xunit = \"samples\", samp.rate = 44100)\n\n# plot\nplot(wav@left)\n\n\n\n\n\n\n\n\n\n\n\n \n\nUse the function downsample() to reduce the sampling rate of ‘wav’ (below 44100) and plot the output object. Decrease the sampling rate until you cannot recognize the wave pattern from the original wave object. Try several values so you get a sense at which sampling rate this happens."
  },
  {
    "objectID": "sound.html#references",
    "href": "sound.html#references",
    "title": "Sound",
    "section": "1.8 References",
    "text": "1.8 References\n\nSueur J, Aubin T, Simonis C. 2008. Equipment review: seewave, a free modular tool for sound analysis and synthesis. Bioacoustics 18(2):213–226.\nSueur, J. (2018). Sound Analysis and Synthesis with R.\nSueur J. (2018). I/O of sound with R. seewave package vignette. url: https://cran.r-project.org/web/packages/seewave/vignettes/seewave_IO.pdf\n\n\nSession information\n\n\nR version 4.3.2 (2023-10-31)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 22.04.2 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.10.0 \nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.10.0\n\nlocale:\n [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              \n [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    \n [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   \n [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 \n [9] LC_ADDRESS=C               LC_TELEPHONE=C            \n[11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       \n\ntime zone: America/Costa_Rica\ntzcode source: system (glibc)\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] audio_0.1-11       phonTools_0.2-2.2  warbleR_1.1.32     NatureSounds_1.0.4\n[5] tuneR_1.4.7        knitr_1.48         seewave_2.2.3     \n\nloaded via a namespace (and not attached):\n [1] viridis_0.6.5      utf8_1.2.4         generics_0.1.3     bitops_1.0-8      \n [5] stringi_1.8.4      digest_0.6.37      magrittr_2.0.3     evaluate_1.0.0    \n [9] grid_4.3.2         fastmap_1.2.0      jsonlite_1.8.9     brio_1.1.5        \n[13] formatR_1.14       gridExtra_2.3      fansi_1.0.6        viridisLite_0.4.2 \n[17] scales_1.3.0       pbapply_1.7-2      cli_3.6.3          rlang_1.1.4       \n[21] fftw_1.0-8         munsell_0.5.1      withr_3.0.1        yaml_2.3.10       \n[25] tools_4.3.2        parallel_4.3.2     dplyr_1.1.4        colorspace_2.1-1  \n[29] ggplot2_3.5.1      bioacoustics_0.2.8 vctrs_0.6.5        R6_2.5.1          \n[33] proxy_0.4-27       lifecycle_1.0.4    dtw_1.23-1         stringr_1.5.1     \n[37] htmlwidgets_1.6.4  MASS_7.3-55        pkgconfig_2.0.3    pillar_1.9.0      \n[41] gtable_0.3.5       moments_0.14.1     glue_1.8.0         Rcpp_1.0.13       \n[45] xfun_0.47          tibble_3.2.1       tidyselect_1.2.1   rstudioapi_0.16.0 \n[49] rjson_0.2.21       htmltools_0.5.8.1  rmarkdown_2.28     testthat_3.2.1.1  \n[53] signal_1.8-1       compiler_4.3.2     RCurl_1.98-1.16"
  }
]